//@ignore_object_type

int GUARD_COUNT = 40;
int NPCS[40]; //npcs
int player[20], RndTable[40], AIKnight[5];
int HumanScore, BotScore, ggOver, ScoreGap = 10; //10

int EnableMemoryReadWriteFunction(int t) {}

int GetScrDataField(int functionName)
{
    return GetMemory(GetMemory(0x75ae28) + (0x30 * functionName + 0x1c));
}

int GetScrCodeField(int functionName)
{
    return GetMemory(GetMemory(0x75ae28) + (0x30 * functionName + 0x20));
}

int FixCallOpcode(int curAddr, int targetAddr)
{
    SetMemory(curAddr + 1, targetAddr - curAddr - 5);
}

int OpcodeGetTargetAddr(int curAddr)
{
    return GetMemory(curAddr + 1) + curAddr + 5;
}

void OpcodeLoadEffectiveAddr(int loadAddr, int codeAddr, int offset)
{
    int targetAddr = OpcodeGetTargetAddr(codeAddr + offset);

    SetMemory(loadAddr + offset + 1, targetAddr - (loadAddr + offset) - 5);
}

void OpcodeCopiesAdvance(int destPtr, int callNodePtr, int startAddr, int endAddr)
{
    int destBase = destPtr, curAddr = startAddr;
    int vptr = GetScrDataField(OpcodeCopiesAdvance);

    while (curAddr <= endAddr)
    {
        Unused59(destPtr, Unknownb9(curAddr));
        if (Unknownb9(callNodePtr))
        {
            if (Unknownb9(callNodePtr) + 1 <= curAddr)
            {
                OpcodeLoadEffectiveAddr(destBase, startAddr, Unknownb9(callNodePtr) - startAddr);
                Unused59(vptr + 4, Unknownb9(vptr + 4) + 4);
            }
        }
        Unused59(vptr + 0x14, Unknownb9(vptr + 0x14) + 4);
        Unused59(vptr, Unknownb9(vptr) + 4);
    }
}

int Bear2BinTable()
{
	int arr[62], link, unit;
	if (!link)
	{
		arr[0] = 1918985538; arr[1] = 50;
		arr[16] = 20000; arr[17] = 90; arr[18] = 100; arr[19] = 40; 
		arr[21] = 1065353216; arr[23] = 65545; arr[24] = 1067450368; 
		arr[27] = 1; arr[28] = 1106247680; arr[29] = 50; 
		arr[30] = 1103626240; arr[31] = 2; arr[32] = 20; arr[33] = 30;
		arr[58] = 5547856; arr[59] = 5542784; 
        link = GetScrDataField(Bear2BinTable);
	}
	return link;
}

int ImportCreateAtFunc()
{
    int arr[20], ptr, link;
    if (!ptr)
    {
        arr[0] = 0xAA506856; arr[1] = 0x5068004D; arr[2] = 0xFF005072; arr[3] = 0xFF502414; arr[4] = 0x50042454;
        arr[5] = 0x082454FF; arr[6] = 0x4085048B; arr[7] = 0x680097BB; arr[8] = 0x004E3810; arr[9] = 0x2454FF50;
        arr[10] = 0x08C48304; arr[11] = 0xF685F08B; arr[12] = 0x006A0A74; arr[13] = 0x2454FF56; arr[14] = 0x08C48314;
        arr[15] = 0x50723068; arr[16] = 0x54FF5600; arr[17] = 0xC4830424; arr[18] = 0x5EC03118; arr[19] = 0x909090C3;
        link = GetScrDataField(ImportCreateAtFunc);
    }
    return link;
}

int CreateObjectAt(string name, float x, float y)
{
    int temp = GetMemory(0x5c3160), res;

    SetMemory(0x5c3160, ImportCreateAtFunc());
    res = CreateMover(SToInt(name), ToInt(x), y);
    SetMemory(0x5c3160, temp);
    if (res) return GetMemory(res + 0x2c);
    else return 0;
}

int GetOwner(int unit)
{
    int ptr = UnitToPtr(unit), ownerPtr;

    if (ptr)
    {
        ownerPtr = GetMemory(ptr + 0x1fc);
        if (ownerPtr)
            return GetMemory(ownerPtr + 0x2c);
    }
    return 0;
}

void GiveHideInventory(int unit, int headNode)
{
    int curNode = headNode, delNode;

    while (IsObjectOn(curNode))
    {
        if (IsObjectOn(ToInt(GetObjectZ(curNode))))
            Pickup(unit, ToInt(GetObjectZ(curNode)));
        delNode = curNode;
        curNode = GetOwner(curNode);
        Delete(delNode);
    }
}

void SetSpellRule()
{
    CmdLine("set spell SPELL_FUMBLE off");
}

void RegistQueue(int unit)
{
    int k;

    for (k = 4 ; k >= 0 ; k --)
    {
        if (!AIKnight[k])
        {
            AIKnight[k] = unit;
            LookWithAngle(GetPreviousItem(GetLastItem(unit)), k);
            break;
        }
    }
}

void InitRTable()
{
    int k;

    for (k = 39 ; k >= 0 ; k --)
        RndTable[k] = k;
    MixRndTable();
}

void MixRndTable()
{
    int k, temp, pic;

    for (k = 39 ; k >= 0 ; k --)
    {
        pic = Random(0, 39);
        temp = RndTable[k];
        RndTable[k] = RndTable[pic];
        RndTable[pic] = temp;
    }
}

int PopRndIndex()
{
    int cur, res;

    while (1)
    {
        res = RndTable[cur];
        cur ++;
        if (cur == 40)
        {
            MixRndTable();
            cur = 0;
        }
        if (!IsObjectOn(NPCS[res]))
            break;
    }
    return res;
}

void BonusEventDescription()
{
    UniPrintToAll("**이 맵에서 전사는 조심스럽게 걷기를 시전할 경우 대쉬(짧은거리를 순간적으로 이동)가 발동됩니다**");
    UniPrintToAll("**보너스 킬 획득 방법: 맵에 알파고가 단 한마리도 없을 시 인간 팀에게 킬 스코어 +1 을 더 줍니다**");
}

void startMent()
{
    UniPrintToAll("극한의 막장 인공지능과의 전투 in.익스사원___ 인간 대 알파고 Human VS AlphaGo                               -제작: happySoft");
    UniPrintToAll("**게임승리 조건: 자기 팀 점수가 상대팀 점수보다 " + IntToString(ScoreGap) + " 점 앞서면 승리합니다**");
    DisplayScore();
    FrameTimer(1, SearchIndexLoop);
    SecondTimer(10, BonusEventDescription);
}

void MapExit()
{
    RemoveCoopTeamMode();
    SelfDamageClassMapExit();
    UniPrintToAll("안녕히 가십시오 by. 알파고");
}

void PlayerDeath()
{
    AddBotScore();
    UniPrintToAll("방금 인간팀 소속 플레이어가 적에게 격추되었습니다. 플레이어가 자살한 경우에도 상대팀 킬에 누적되므로 주의하세요");
}

void InventoryEmptyAll(int unit)
{
    while (IsObjectOn(GetLastItem(unit)))
        Delete(GetLastItem(unit));
}

int PlayerClassOnInit(int plr, int pUnit)
{
    int pResult = plr;

    player[plr] = pUnit;
    player[plr + 10] = 1;

    DiePlayerHandlerEntry(pUnit);

    UniPrintToAll(PlayerIngameNick(pUnit) + " 님께서 게임에 참가하셨습니다");

    return pResult;
}

void PlayerClassFailedJoin()
{ }

void getPlayers()
{
    int i, plr;

    while (1)
    {
        if (CurrentHealth(other))
        {
            plr = CheckPlayer();
            for (i = 9 ; i >= 0 && plr < 0 ; i --)
            {
                if (!MaxHealth(player[i]))
                {
                    plr = PlayerClassOnInit(i, GetCaller());
                    break;
                }
            }
            if (plr >= 0)
            {
                teleportPlayer(plr);
                break;
            }
        }
        PlayerClassFailedJoin();
        break;
    }
}

int CheckPlayer()
{
    int k;

    for (k = 9 ; k >= 0 ; k --)
    {
        if (IsCaller(player[k]))
            return k;
    }
    return -1;
}

int PlayerClassCheckDeathFlag(int plr)
{
    return player[plr + 10] & 2;
}

void PlayerClassSetDeathFlag(int plr)
{
    player[plr + 10] ^= 2;
}

void PlayerClassOnAlive(int pUnit)
{
    if (UnitCheckEnchant(pUnit, GetLShift(31)))
    {
        Windbooster(pUnit);
        EnchantOff(pUnit, EnchantList(31));
        RemoveTreadLightly(pUnit);
    }
}

void PlayerClassOnFree(int plr)
{
    int ptr = UnitToPtr(player[plr]);

    if (ptr)
        CancelPlayerDialogWithPTR(ptr);
    player[plr] = 0;
    player[plr + 10] = 0;
}

//@brief. 데스 핸들러
void PlayerClassOnDeath(int plr)
{ }

void PlayerClassOnLoop()
{
    int i;

    for (i = 9 ; i >= 0 ; i --)
    {
        while (true)
        {
            if (MaxHealth(player[i]))
            {
                if (GetUnitFlags(player[i]) & 0x40)
                    1;
                else if (CurrentHealth(player[i]))
                {
                    PlayerClassOnAlive(player[i]);
                    break;
                }
                else
                {
                    if (PlayerClassCheckDeathFlag(i))
                        break;
                    else
                    {
                        PlayerClassSetDeathFlag(i);
                        PlayerClassOnDeath(i);
                    }
                    break;
                }
            }
            if (player[i + 10])
                PlayerClassOnFree(i);
            break;
        }
    }
    FrameTimer(1, PlayerClassOnLoop);
}

void Windbooster(int unit)
{
    if (!HasEnchant(unit, "ENCHANT_ANCHORED"))
    {
        Effect("RICOCHET", GetObjectX(unit), GetObjectY(unit), 0.0, 0.0);
        PushObjectTo(unit, UnitAngleCos(unit, 60.0), UnitAngleSin(unit, 60.0));
    }
}

void teleportPlayer(int plr)
{
    int wp = Waypoint("respawnLocation" + IntToString(Random(1, 18)));
    
    MoveObject(player[plr], GetWaypointX(wp), GetWaypointY(wp));
    DeleteObjectTimer(CreateObject("OblivionUp", wp), 30);
    Effect("TELEPORT", GetWaypointX(wp), GetWaypointY(wp), 0.0, 0.0);
    Effect("SMOKE_BLAST", GetWaypointX(wp), GetWaypointY(wp), 0.0, 0.0);
    AudioEvent("BlinkCast", wp);
}

void WarEnemyDetectHandler()
{
    int rnd = Random(0, 4);

    if (!rnd)
    {
        BerserkerInRange(GetTrigger(), GetCaller(), 10);
    }
    else if (rnd == 1)
    {
        WarriorWarcry(GetTrigger());
    }
    else if (rnd == 2)
    {
        WarThrowSword(GetTrigger(), GetCaller());
    }
    else if (rnd == 3)
    {
        WarriorStrikeSubPart(6);
    }
    else if (rnd == 4)
    {
        WarThrowSword(GetTrigger(), GetCaller());
        BerserkerInRange(GetTrigger(), GetCaller(), 10);
    }
}

void LookForEnemy()
{
    if (HasEnchant(self, "ENCHANT_PROTECT_FROM_POISON"))
    {
        if (IsConjurer(self))
        {
            AbsoluteTargetStrike(GetTrigger(), GetCaller(), 85.0, GetShootXBowFunc());
            //Test
            //UniChatMessage(self, "Guardian Number: " + IntToString(GetDirection(GetLastItem(self))), 120);
            //UniPrintToAll(IntToString(GetDirection(GetLastItem(self)))); //TODO: Remove me
            //TestEnd
        }
        else
        {
            WarEnemyDetectHandler();
        }
    }
    CheckResetSight(GetTrigger(), 30 * Random(4, 6));
}

void CheckResetSight(int unit, int delay)
{
    if (!HasEnchant(unit, "ENCHANT_DETECTING"))
    {
        AroundWallDestroy(unit);
        Enchant(unit, "ENCHANT_DETECTING", 0.0);
        FrameTimerWithArg(delay, unit, ResetUnitSight);
    }
}

void ResetUnitSight(int unit)
{
    EnchantOff(unit, "ENCHANT_DETECTING");
    Enchant(unit, "ENCHANT_BLINDED", 0.1);
    AggressionLevel(unit, 1.0);
}

void dontDie()
{
    UniPrintToAll("예외발생! 가디언(npc) 1 개가 손실되었습니다 .");
}

void hurtNPC()
{
    int die_hp = MaxHealth(self) - 150, dead;

    if (HasEnchant(self, "ENCHANT_SNEAK"))
    {
        die_hp += 50;
        if (HasClass(other, "MISSILE") && HasSubclass(other, "IMMUNE_FEAR"))
        {
            teleportRandomWarp(self);
            CastSpellObjectObject("SPELL_COUNTERSPELL", self, self);
            RestoreHealth(self, 200);
        }
    }
    Damage(self, other, 10, 14);
    if (CurrentHealth(self) && CurrentHealth(self) < die_hp)
    {
        AlphagoDeathHandler();
        PlayerKillHandler(CheckPlayer());
    }
}

void PlayerKillHandler(int plr)
{
    if (plr + 1)
    {
        if (CurrentHealth(player[plr]))
            BerserkerNoDelayCore(plr);
    }
}

int CheckOwner(int unit)
{
    int i;

    for (i = 9 ; i >= 0 ; i --)
    {
        if (IsOwnedBy(unit, player[i]))
            return i;
    }
    return -1;
}

void AlphagoDeathHandler()
{
    int dead;

    MoveWaypoint(46, GetObjectX(self), GetObjectY(self));
    FrameTimerWithArg(3, CreateObject("InvisibleLightBlueHigh", 46), PutAlphagoDeathText);
    dead = CreateObject("Swordsman", 46);
    DeleteObjectTimer(dead, 150);
    LookAtObject(dead, other);
    Damage(dead, 0, 255, 14);
    RestoreHealth(self, MaxHealth(self));
    CastSpellObjectObject("SPELL_CURE_POISON", self, self);
    EnchantOff(self, "ENCHANT_PROTECT_FROM_POISON");
    EnchantOff(self, "ENCHANT_SNEAK");
    EnchantOff(self, "ENCHANT_INFRAVISION");
    Enchant(self, "ENCHANT_FREEZE", 0.0);
    Enchant(self, "ENCHANT_BURNING", 0.0);
    getAutoPlaced(self);                        //here: NPC[idx + 40] = 0
    ObjectOff(self);
    UniPrintToAll("* 가디언 한마리를 격추 시켰습니다-! (인간팀 킬수 + 1)");
    if (!ggOver)
    {
        AIKnight[GetDirection(GetPreviousItem(GetLastItem(self)))] = 0;
        FrameTimerWithArg(150, PopRndIndex(), releaseKnight);
    }
    AddHumanScore();
}

int CheckGuardianCount(int max)
{
    int i, res = 0;

    for (i = 0 ; i < max ; i ++)
        res += (CurrentHealth(AIKnight[i]) > 0);
    return res;
}

void AllKillsBonus(int max)
{
    if (!CheckGuardianCount(max))
    {
        HumanScore ++;
        UniPrintToAll("지금 맵에 알파고가 전멸되었습니다! (알파고 싹쓸이 보너스 킬 +1)");
    }
}

int AddHumanScore()
{
    HumanScore ++;
    AllKillsBonus(5);
    if (!ggOver)
    {
        if (HumanScore > BotScore + ScoreGap)
        {
            ggOver = 1;
            VictoryEvent(48);
            return 1;
        }
    }
    return 0;
}

int AddBotScore()
{
    BotScore ++;
    if (!ggOver)
    {
        if (BotScore > HumanScore + ScoreGap)
        {
            ggOver = 1;
            DefeatGame(93);
            return 1;
        }
    }
    return 0;
}

void VictoryEvent(int wp)
{
    UniBroadcast("인간팀 승리! -- 대단합니다, 인간팀이 알파고 팀의 점수보다 " + IntToString(ScoreGap) + "점을 앞서 승리하였습니다...!");
    UniPrintToAll("축하합니다! 승리하셨습니다");
    ObjectOff(Object("mainSwitch"));
    strVictory();
    teleportAllPlayer(wp);
    CureHumanStatus();
    MoveObject(Object("PlayerStartLocation"), GetWaypointX(wp), GetWaypointY(wp));
    DeleteObjectTimer(CreateObject("LevelUp", wp), 600);
}

void DefeatGame(int wp)
{
    UniBroadcast("인간팀 패배! -- 이번 게임에서는 알파고 팀이 승리했습니다, 알파고 팀이 인간팀 점수보다 " + IntToString(ScoreGap) + "점 앞섰습니다");
    UniPrintToAll("패배하셨습니다");
    ObjectOff(Object("mainSwitch"));
    MoveWaypoint(1, GetWaypointX(wp) - 100.0, GetWaypointY(wp) - 100.0);
    StrDefeatTeam();
    MoveObject(Object("PlayerStartLocation"), GetWaypointX(wp), GetWaypointY(wp));
    teleportAllPlayer(wp);
}

void CureHumanStatus()
{
    int i;

    for (i = 9 ; i >= 0 ; i --)
    {
        if (CurrentHealth(player[i]))
        {
            CastSpellObjectObject("SPELL_CURE_POISON", player[i], player[i]);
            RestoreHealth(player[i], MaxHealth(player[i]) - CurrentHealth(player[i]));
        }
    }
}

void teleportAllPlayer(int arg_0)
{
    int i;
    
    for (i = 9 ; i >= 0 ; i --)
    {
        if (CurrentHealth(player[i]))
        {
            MoveObject(player[i], GetWaypointX(arg_0), GetWaypointY(arg_0));
            Enchant(player[i], "ENCHANT_ANCHORED", 0.0);
        }
    }
}

void perceiveToEnemy()
{
    int rnd, ptr;

    if (CurrentHealth(self) && HasEnchant(self, "ENCHANT_SNEAK") && !HasEnchant(self, "ENCHANT_CROWN"))
    {
        rnd = Random(0, 5);
        if (!rnd)
        {
            AbsoluteTargetStrike(GetTrigger(), GetCaller(), 9.0, GetMeteorShotFunc());
            CastSpellObjectLocation("SPELL_BURN", self, GetObjectX(other), GetObjectY(other));
            Enchant(self, "ENCHANT_CROWN", 3.0);
        }
        else if (rnd == 1)
        {
            if (!Random(0, 5))
                CastSpellObjectLocation(randomSummonUnit(), self, GetObjectX(other), GetObjectY(other));
            //HitFarLocation(self, GetObjectX(other), GetObjectY(other));
            AbsoluteTargetStrike(GetTrigger(), GetCaller(), 85.0, GetShootXBowFunc());
            Enchant(self, "ENCHANT_CROWN", 2.0);
        }
        else if (rnd == 2)
        {
            AbsoluteTargetStrike(GetTrigger(), GetCaller(), 10.5, GetFistShotFunc());
            FrameTimerWithArg(35, GetTrigger(), GuardianCastTeleport);
            PauseObject(self, 50);
            Enchant(self, "ENCHANT_CROWN", 5.0);
        }
        else if (rnd == 3)
        {
            MoveWaypoint(68, GetObjectX(self), GetObjectY(self));
            ptr = CreateObject("Wizard", 68);
            SetOwner(self, ptr);
            CastSpellObjectLocation("SPELL_TOXIC_CLOUD", ptr, GetObjectX(other), GetObjectY(other));
            Delete(ptr);
            CastSpellObjectObject("SPELL_PIXIE_SWARM", self, self);
            RunAway(self, other, 900);
            Enchant(self, "ENCHANT_CROWN", 3.0);
        }
        else if (rnd == 4)
        {
            CastSpellObjectObject("SPELL_PIXIE_SWARM", self, self);
            CastSpellObjectObject("SPELL_SLOW", self, other);
            PauseObject(self, 60);
            FrameTimerWithArg(30, GetTrigger(), GuardianCastTeleport);
        }
        else
        {
            //HitFarLocation(self, GetObjectX(other), GetObjectY(other));
            AbsoluteTargetStrike(GetTrigger(), GetCaller(), 85.0, GetShootXBowFunc());
            CastSpellObjectObject("SPELL_SLOW", self, other);
            Enchant(self, "ENCHANT_CROWN", 2.0);
        }
    }
}

void ForceTeleport(int unit)
{
    int wp;
    if (CurrentHealth(unit))
    {
        Effect("TELEPORT", GetObjectX(unit), GetObjectY(unit), 0.0, 0.0);
        Effect("SMOKE_BLAST", GetObjectX(unit), GetObjectY(unit), 0.0, 0.0);
        MoveWaypoint(1, GetObjectX(unit), GetObjectY(unit));
        AudioEvent("BlinkCast", 1);
        if (IsObjectOn(unit))
            wp = Waypoint("respawnLocation" + IntToString(Random(1, 18)));
        else
            wp = 92;
        MoveObject(unit, GetWaypointX(wp), GetWaypointY(wp));
        Effect("TELEPORT", GetWaypointX(wp), GetWaypointY(wp), 0.0, 0.0);
        Effect("SMOKE_BLAST", GetWaypointX(wp), GetWaypointY(wp), 0.0, 0.0);
        AudioEvent("BlinkCast", wp);
    }
}

void teleportRandomWarp(int arg_0)
{
    int var_0;
    
    if (CurrentHealth(arg_0) && !HasEnchant(arg_0, "ENCHANT_ANCHORED") && !HasEnchant(arg_0, "ENCHANT_BURNING"))
    {
        Effect("TELEPORT", GetObjectX(arg_0), GetObjectY(arg_0), 0.0, 0.0);
        Effect("SMOKE_BLAST", GetObjectX(arg_0), GetObjectY(arg_0), 0.0, 0.0);
        MoveWaypoint(1, GetObjectX(arg_0), GetObjectY(arg_0));
        AudioEvent("BlinkCast", 1);
        var_0 = Waypoint("respawnLocation" + IntToString(Random(1, 18)));
        MoveObject(arg_0, GetWaypointX(var_0), GetWaypointY(var_0));
        Effect("TELEPORT", GetWaypointX(var_0), GetWaypointY(var_0), 0.0, 0.0);
        Effect("SMOKE_BLAST", GetWaypointX(var_0), GetWaypointY(var_0), 0.0, 0.0);
        AudioEvent("BlinkCast", var_0);
    }
}

void GuardianCastTeleport(int unit)
{
    int dest;
    if (CurrentHealth(unit) && IsObjectOn(unit))
    {
        dest = Waypoint("respawnLocation" + IntToString(Random(1, 18)));
        MoveWaypoint(1, GetObjectX(unit), GetObjectY(unit));
        MoveObject(unit, GetWaypointX(dest), GetWaypointY(dest));
        AudioEvent("BlinkCast", 1);
        SetOwner(unit, TeleportPortalDuration(1, unit, 24) + 1);
    }
}

int TeleportPortalDuration(int srcWp, int destU, int dur)
{
    int unit = CreateObject("Bomber", srcWp);

    DeleteObjectTimer(CreateObjectAt("InvisibleLightBlueHigh", GetObjectX(destU), GetObjectY(destU)), dur + 10);
    UnitNoCollide(CreateObjectAt("TeleportWake", GetObjectX(unit), GetObjectY(unit)));
    DeleteObjectTimer(unit + 2, dur);
    DeleteObjectTimer(unit, dur);
    ObjectOff(unit);
    Damage(unit, 0, MaxHealth(unit) + 1, -1);
    Frozen(unit, 1);
    SetCallback(unit, 9, UnitPortalEnter);
    Effect("TELEPORT", GetObjectX(unit), GetObjectY(unit), 0.0, 0.0);
    Effect("TELEPORT", GetObjectX(unit + 1), GetObjectY(unit + 1), 0.0, 0.0);
    Effect("SMOKE_BLAST", GetObjectX(unit), GetObjectY(unit), 0.0, 0.0);
    Effect("SMOKE_BLAST", GetObjectX(unit + 1), GetObjectY(unit + 1), 0.0, 0.0);

    return unit;
}

void UnitPortalEnter()
{
    if (CurrentHealth(other) && IsObjectOn(other))
    {
        Effect("SMOKE_BLAST", GetObjectX(other), GetObjectY(other), 0.0, 0.0);
        MoveObject(other, GetObjectX(GetTrigger() + 1), GetObjectY(GetTrigger() + 1));
        Effect("SMOKE_BLAST", GetObjectX(other), GetObjectY(other), 0.0, 0.0);
        Effect("TELEPORT", GetObjectX(other), GetObjectY(other), 0.0, 0.0);
        UnitPortalEntryHandler();
    }
}

void UnitPortalEntryHandler()
{
    int owner = GetOwner(GetTrigger() + 1), unit;

    if (CurrentHealth(owner) && CurrentHealth(other) && IsAttackedBy(other, owner) && IsObjectOn(owner))
    {
        AbsoluteTargetStrike(owner, GetCaller(), 85.0, GetShootXBowFunc());
        ConjShotFireball(owner, GetCaller());
        /*unit = CreateObjectAt("ArcherBolt", GetObjectX(other), GetObjectY(other));
        LookWithAngle(unit, GetDirection(other));
        SetOwner(owner, unit);*/
        if (!HasEnchant(owner, "ENCHANT_TELEKINESIS"))
        {
            Enchant(owner, "ENCHANT_TELEKINESIS", 2.0);
            if (HasEnchant(owner, "ENCHANT_ANTI_MAGIC"))
                AbsoluteTargetStrike(owner, other, 85.0, GetShootXBowFunc());
            else
            {
                AbsoluteTargetStrike(owner, GetCaller(), 10.5, GetFistShotFunc());
                FrameTimerWithArg(Random(12, 21), owner, GuardianCastTeleport);
            }
        }
    }
}

void ConjShotFireball(int owner, int target)
{
    int unit;

    if (HasEnchant(owner, "ENCHANT_ETHEREAL"))
        return;
    else
    {
        Enchant(owner, "ENCHANT_ETHEREAL", 3.0);
        unit = CreateObjectAt("InvisibleLightBlueHigh", GetObjectX(owner), GetObjectY(owner));
        SetOwner(owner, unit);
        Raise(unit, ToFloat(target));
        FrameTimerWithArg(1, unit, ShotFireballHandler);
    }
}

void ShotFireballHandler(int ptr)
{
    int owner = GetOwner(ptr), target = ToInt(GetObjectZ(ptr)), count = GetDirection(ptr);

    if (CurrentHealth(owner) && CurrentHealth(target) && count < 12)
    {
        if (IsVisibleTo(owner, target))
        {
            MoveWaypoint(1, GetObjectX(owner), GetObjectY(owner));
            AudioEvent("FireballWand", 1);
            LookAtObject(owner, target);
            if (count % 5 == 4)
                AbsoluteTargetStrike(owner, target, 85.0, GetShootXBowFunc());
            else
                AbsoluteTargetStrike(owner, target, 3.2, GetFireballShotFunc());
            LookWithAngle(ptr, count + 1);
        }
        else
            LookWithAngle(ptr, 100);
        FrameTimerWithArg(9, ptr, ShotFireballHandler);
    }
    else
        Delete(ptr);
}

void AlphagoShootXBow(int sUnit)
{
    int owner = GetOwner(sUnit), target = ToInt(GetObjectZ(sUnit)), mis;
    float dt = Distance(GetObjectX(sUnit), GetObjectY(sUnit), GetObjectX(target), GetObjectY(target));
    float thresHold;

    if (CurrentHealth(owner) && CurrentHealth(target))
    {
        mis = EquipedXBow(owner, target, 19.0);
        thresHold = DistanceUnitToUnit(mis, target) / GetObjectZ(sUnit + 1);
        MoveObject(sUnit, GetObjectX(target) + UnitRatioX(target, sUnit, dt * thresHold), GetObjectY(target) + UnitRatioY(target, sUnit, dt * thresHold));
        if (IsVisibleTo(sUnit, owner))
        {
            PushObject(mis, -42.0, GetObjectX(sUnit), GetObjectY(sUnit));
        }
        else
        {
            PushObject(mis, -42.0, GetObjectX(target), GetObjectY(target));
        }
    }
    Delete(sUnit);
    Delete(sUnit + 1);
}

void PushObjectTarget(int unit, int target, float force)
{
    PushObjectTo(unit, UnitRatioX(target, unit, force), UnitRatioY(target, unit, force));
}

int EquipedXBow(int owner, int target, float gap)
{
    int mis = CreateObjectAt("ArcherBolt", GetObjectX(owner) + UnitRatioX(target, owner, gap), GetObjectY(owner) + UnitRatioY(target, owner, gap));
    int inv = GetQuiverByInventory(owner);

    if (inv)
        CopyQuiverPropertyData(mis, inv);
    LookAtObject(mis, target);
    SetOwner(owner, mis);
    Enchant(mis, "ENCHANT_VILLAIN", 0.0);

    return mis;
}

void CopyQuiverPropertyData(int dst, int src)
{
    int dstPtr = UnitToPtr(dst), srcPtr = UnitToPtr(src), temp, i;

    if (dstPtr && srcPtr)
    {
        temp = GetMemory(dstPtr + 0x2b4);
        if (temp)
        {
            SetMemory(temp, GetMemory(GetMemory(srcPtr + 0x2b4)));
            SetMemory(temp + 4, GetMemory(GetMemory(srcPtr + 0x2b4) + 4));
            SetMemory(temp + 8, GetMemory(GetMemory(srcPtr + 0x2b4) + 8));
            SetMemory(temp + 12, GetMemory(GetMemory(srcPtr + 0x2b4) + 12));
            for (i = 31 ; i >= 0 ; i --)
                SetMemory(dstPtr + 0x230 + (i * 4), 0x200);
        }
    }
}

int GetQuiverByInventory(int unit)
{
    int inv = GetLastItem(unit);

    while (IsObjectOn(inv))
    {
        if (HasSubclass(inv, "QUIVER") && HasClass(inv, "WEAPON"))
            return inv;
        inv = GetPreviousItem(inv);
    }
    return 0;
}

void WarriorStrikeSubPart(int delay)
{
    int ptr = CreateObjectAt("InvisibleLightBlueHigh", GetObjectX(self), GetObjectY(self));

    SetOwner(self, ptr);
    Raise(ptr, ToFloat(GetCaller()));
    FrameTimerWithArg(delay, ptr, WarriorTripleMissile);
}

void WarriorTripleMissile(int ptr)
{
    int caster = GetOwner(ptr), target = ToInt(GetObjectZ(ptr)), i;

    if (CurrentHealth(caster) && CurrentHealth(target))
    {
        LookWithAngle(ptr, GetDirection(caster) - 30);
        for (i = 0 ; i < 13 ; i ++)
        {
            SpawnBullet(caster, GetObjectX(caster) + UnitAngleCos(ptr, 17.0), GetObjectY(caster) + UnitAngleSin(ptr, 17.0), 70, 33.0);
            LookWithAngle(ptr, GetDirection(ptr) + 5);
        }
    }
    Delete(ptr);
}

int SpawnBullet(int owner, float x, float y, int dam, float force)
{
    int unit = CreateObjectAt("OgreShuriken", x, y);
    int ptr = GetMemory(0x750710);

    SetMemory(GetMemory(ptr + 0x2bc) + 4, dam);
    LookAtObject(unit, owner);
    LookWithAngle(unit, GetDirection(unit) + 128);
    PushObjectTo(unit, UnitRatioX(unit, owner, force), UnitRatioY(unit, owner, force));
    SetOwner(owner, unit);
    return unit;
}

void WarriorWarcry(int unit)
{
    if (!HasEnchant(unit, "ENCHANT_CROWN"))
    {
        MoveWaypoint(1, GetObjectX(unit), GetObjectY(unit));
        SplashHandler(unit, GetWarcryFxFunc(), GetWaypointX(1), GetWaypointY(1), 300.0);
        Enchant(unit, "ENCHANT_FREEZE", 0.8);
        Effect("JIGGLE", GetObjectX(unit), GetObjectY(unit), 23.0, 0.0);
        AudioEvent("WarcryInvoke", 1);
        Enchant(unit, "ENCHANT_CROWN", 5.0);
    }
}

int GetWarcryFxFunc()
{
    StopScript(WarcryEffect);
}

void WarcryEffect()
{
    int owner = GetOwner(GetOwner(self));

    if (CurrentHealth(owner))
    {
        Enchant(other, "ENCHANT_VILLAIN", 0.08);
        Damage(other, owner, 10, 14);
        if (HasClass(other, "PLAYER"))
            Enchant(other, "ENCHANT_ANTI_MAGIC", 5.0);
        else
            Enchant(other, "ENCHANT_HELD", 5.0);
    }
}

void HarpoonInRange(int owner, int target, int wait)
{
    int unit;

    if (CurrentHealth(owner) && CurrentHealth(target))
    {
        if (!HasEnchant(owner, "ENCHANT_ETHEREAL"))
        {
            Enchant(owner, "ENCHANT_ETHEREAL", 0.0);
            unit = CreateObjectAt("InvisibleLightBlueHigh", GetObjectX(owner), GetObjectY(owner));
            SetOwner(owner, unit);
            Raise(unit, ToFloat(target));
            LookWithAngle(unit, wait);
            FrameTimerWithArg(1, unit, HarpoonWaitStrike);
        }
    }
}

void HarpoonWaitStrike(int ptr)
{
    int count = GetDirection(ptr), owner = GetOwner(ptr), target = ToInt(GetObjectZ(ptr));

    while (1)
    {
        if (IsObjectOn(ptr) && CurrentHealth(owner) && CurrentHealth(target) && IsObjectOn(owner))
        {
            if (count)
            {
                if (IsVisibleTo(owner, target) && Distance(GetObjectX(owner), GetObjectY(owner), GetObjectX(target), GetObjectY(target)) < 400.0)
                    WarPullEnemy(owner, target);
                else
                {
                    LookWithAngle(ptr, count - 1);
                    FrameTimerWithArg(6, ptr, HarpoonWaitStrike);
                    break;
                }
            }
        }
        if (CurrentHealth(owner))
            EnchantOff(owner, "ENCHANT_ETHEREAL");
        if (IsObjectOn(ptr))
            Delete(ptr);
        break;
    }
}

void BerserkerInRange(int owner, int target, int wait)
{
    int unit;

    if (CurrentHealth(owner) && CurrentHealth(target))
    {
        if (!HasEnchant(owner, "ENCHANT_ETHEREAL"))
        {
            Enchant(owner, "ENCHANT_ETHEREAL", 0.0);
            unit = CreateObjectAt("InvisibleLightBlueHigh", GetObjectX(owner), GetObjectY(owner));
            SetOwner(owner, unit);
            Raise(unit, ToFloat(target));
            LookWithAngle(unit, wait);
            FrameTimerWithArg(1, unit, BerserkerWaitStrike);
        }
    }
}

void BerserkerWaitStrike(int ptr)
{
    int count = GetDirection(ptr), owner = GetOwner(ptr), target = ToInt(GetObjectZ(ptr));

    while (1)
    {
        if (IsObjectOn(ptr) && CurrentHealth(owner) && CurrentHealth(target) && IsObjectOn(owner))
        {
            if (count)
            {
                if (IsVisibleTo(owner, target) && Distance(GetObjectX(owner), GetObjectY(owner), GetObjectX(target), GetObjectY(target)) < 400.0)
                    BerserkerCharge(owner, target);
                else
                {
                    LookWithAngle(ptr, count - 1);
                    FrameTimerWithArg(6, ptr, BerserkerWaitStrike);
                    break;
                }
            }
        }
        if (CurrentHealth(owner))
            EnchantOff(owner, "ENCHANT_ETHEREAL");
        if (IsObjectOn(ptr))
            Delete(ptr);
        break;
    }
}

void BerserkerCharge(int owner, int target)
{
    int unit;

    if (CurrentHealth(owner) && CurrentHealth(target))
    {
        MoveWaypoint(1, GetObjectX(owner), GetObjectY(owner));
        AudioEvent("BerserkerChargeInvoke", 1);
        unit = CreateObjectAt("InvisibleLightBlueHigh", GetObjectX(owner), GetObjectY(owner));
        Raise(CreateObjectAt("InvisibleLightBlueHigh", GetObjectX(unit), GetObjectY(unit)), UnitRatioX(target, owner, 23.0));
        Raise(CreateObjectAt("InvisibleLightBlueHigh", GetObjectX(unit), GetObjectY(unit)), UnitRatioY(target, owner, 23.0));
        SetOwner(owner, unit);
        LookWithAngle(GetLastItem(owner), 0);
        SetCallback(owner, 9, BerserkerTouched);
        Raise(unit, ToFloat(target));
        LookAtObject(unit + 1, target);
        FrameTimerWithArg(1, unit, BerserkerLoop);
    }
}

void BerserkerLoop(int ptr)
{
    int owner = GetOwner(ptr), count = GetDirection(ptr);

    if (CurrentHealth(owner) && count < 60 && IsObjectOn(ptr) && IsObjectOn(owner))
    {
        if (CheckUnitFrontSight(owner, GetObjectZ(ptr + 1) * 1.5, GetObjectZ(ptr + 2) * 1.5) && !GetDirection(GetLastItem(owner)))
        {
            MoveObject(owner, GetObjectX(owner) + GetObjectZ(ptr + 1), GetObjectY(owner) + GetObjectZ(ptr + 2));
            LookWithAngle(owner, GetDirection(ptr + 1));
            Walk(owner, GetObjectX(owner), GetObjectY(owner));
        }
        else
            LookWithAngle(ptr, 100);
        FrameTimerWithArg(1, ptr, BerserkerLoop);
    }
    else
    {
        SetCallback(owner, 9, WarNormalCollide);
        Delete(ptr);
        Delete(ptr + 1);
        Delete(ptr + 2);
    }
}

void BerserkerTouched()
{
    if (IsObjectOn(self))
    {
        while (1)
        {
            if (!GetCaller() || (HasClass(other, "IMMOBILE") && !HasClass(other, "DOOR")))
            {
                Enchant(self, "ENCHANT_HELD", 1.0);
                AroundWallDestroy(self);
            }
            else if (CurrentHealth(other))
            {
                GreenSparkFx(GetObjectX(self), GetObjectY(self));
                if (IsAttackedBy(self, other))
                    Damage(other, self, 150, 2);
                else
                    break;
            }
            else
                break;
            LookWithAngle(GetLastItem(self), 1);
            break;
        }
    }
}

void WarNormalCollide()
{
    if (!GetCaller())
        AroundWallDestroy(self);
}

void ConHarpoonCollide()
{
    int target;

    if (GetCaller())
    {
        if (!HasEnchant(self, "ENCHANT_PROTECT_FROM_MAGIC") && IsObjectOn(self))
        {
            if (GetUnitThingID(other) == 526)
            {
                target = GetOwner(other);
                Enchant(self, "ENCHANT_PROTECT_FROM_MAGIC", 2.0);
                if (HasEnchant(self, "ENCHANT_ANTI_MAGIC"))
                {
                    LookAtObject(self, target);
                    AbsoluteTargetStrike(GetTrigger(), target, 9.0, GetMeteorShotFunc());
                    AbsoluteTargetStrike(GetTrigger(), target, 85.0, GetShootXBowFunc());
                }
                else
                {
                    if (DistanceUnitToUnit(target, self) < 300.0)
                    {
                        LookAtObject(self, target);
                        AbsoluteTargetStrike(GetTrigger(), target, 9.0, GetMeteorShotFunc());
                        AbsoluteTargetStrike(GetTrigger(), target, 85.0, GetShootXBowFunc());
                        CastSpellObjectLocation("SPELL_BURN", self, GetObjectX(target), GetObjectY(target));
                    }
                    else
                    {
                        AbsoluteTargetStrike(GetTrigger(), target, 10.5, GetFistShotFunc());
                        FrameTimerWithArg(30, GetTrigger(), GuardianCastTeleport);
                    }
                }
            }
        }
    }
    else
        AroundWallDestroy(self);
}

void releaseKnight(int arg_0)
{
    int wp;
    
    UniPrintToAll("* " + IntToString(arg_0) + " 번 가디언이 맵에 투입됩니다");
    
    wp = Waypoint("respawnLocation" + IntToString(Random(1, 18)));
    MoveObject(NPCS[arg_0], GetWaypointX(wp), GetWaypointY(wp));
    ObjectOn(NPCS[arg_0]);
    if (!HasSubclass(GetLastItem(NPCS[arg_0]), "HAMMER"))
    {
        Enchant(NPCS[arg_0], "ENCHANT_SNEAK", 0.0);
        Enchant(NPCS[arg_0], "ENCHANT_VAMPIRISM", 0.0);
    }
    RegistQueue(NPCS[arg_0]);
    Enchant(NPCS[arg_0], "ENCHANT_PROTECT_FROM_POISON", 0.0);
    Enchant(NPCS[arg_0], "ENCHANT_INFRAVISION", 0.0);
    Effect("TELEPORT", GetWaypointX(wp), GetWaypointY(wp), 0.0, 0.0);
    AudioEvent("TeleportOut", wp);
    EnchantOff(NPCS[arg_0], "ENCHANT_FREEZE");
    EnchantOff(NPCS[arg_0], "ENCHANT_BURNING");
}

int FindOutQuiver(int unit)
{
    int inv = GetLastItem(unit);

    while (IsObjectOn(inv))
    {
        if (HasClass(inv, "WEAPON") && HasSubclass(inv, "QUIVER"))
            return inv;
        inv = GetPreviousItem(inv);
    }
    return 0;
}

void QuiverSetAllImpactPropert(int quiv)
{
    int ptr = UnitToPtr(quiv);

    if (ptr)
    {
        SetMemory(GetMemory(ptr + 0x2b4) + 8, GetMemory(0x5BA444));
        SetMemory(GetMemory(ptr + 0x2b4) + 12, GetMemory(0x005BA24C));
    }
}

void CheckImpactQuiver(int unit)
{
    int quiv = FindOutQuiver(unit);

    if (IsObjectOn(quiv))
    {
        QuiverSetAllImpactPropert(quiv);
    }
}

void initializeKnightHammers(int num)
{
    float temp;

    if (num < GUARD_COUNT)
    {
        NPCS[num] = Object("arenaNPC" + IntToString(num + 1));
        ObjectOff(NPCS[num]);
        temp = IntToFloat(num * 23);
        MoveObject(NPCS[num], GetWaypointX(47) - temp, GetWaypointY(47) + temp);
        Enchant(NPCS[num], "ENCHANT_FREEZE", 0.0);
        Enchant(NPCS[num], "ENCHANT_BURNING", 0.0);
        if (num >= 20)
        {
            SetCallback(NPCS[num], 9, ConHarpoonCollide);
            SetUnitScanRange(NPCS[num], 600.0);
            //CheckImpactQuiver(NPCS[num]); //TODO: Remove it. just test
        }
        else
            SetCallback(NPCS[num], 9, WarNormalCollide);
        LookWithAngle(GetLastItem(NPCS[num]), num);
        nonCrashInventoryOfKnight(NPCS[num]);
        FrameTimerWithArg(1, num + 1, initializeKnightHammers);
    }
    else
    {
        FrameTimerWithArg(120, PopRndIndex(), releaseKnight);
        FrameTimerWithArg(140, PopRndIndex(), releaseKnight);
        FrameTimerWithArg(170, PopRndIndex(), releaseKnight);
    }
}

void nonCrashInventoryOfKnight(int unit)
{
    int inv = GetLastItem(unit);

    while (IsObjectOn(inv))
    {
        if (!HasEnchant(inv, "ENCHANT_INVULNERABLE"))
            Enchant(inv, "ENCHANT_INVULNERABLE", 0.0);
        inv = GetPreviousItem(inv);
    }
}

void loopGuardianAi()
{
    int i, k, plr;

    for (i = 0 ; i < 5; i ++)
    {
        if (CurrentHealth(AIKnight[i]))
        {
            plr = SearchTargetPlayer(AIKnight[i]);
            if (plr >= 0)
            {
                if (Distance(GetObjectX(AIKnight[i]), GetObjectY(AIKnight[i]), GetObjectX(player[plr]), GetObjectY(player[plr])) < 200.0 && HasEnchant(AIKnight[i], "ENCHANT_SNEAK") && !HasEnchant(AIKnight[i], "ENCHANT_VILLAIN"))
                {
                    Enchant(AIKnight[i], "ENCHANT_VILLAIN", 15.0);
                    GuardianCastTeleport(AIKnight[i]);
                }
                AroundWallDestroy(AIKnight[i]);
                CreatureFollow(AIKnight[i], player[plr]);
                AggressionLevel(AIKnight[i], 1.0);
            }
        }
    }
    if (!ggOver)
        FrameTimer(60, loopGuardianAi);
}

int SearchTargetPlayer(int unit)
{
    int k, target = -1;
    float temp = 8192.0, rad;

    for (k = 9 ; k >= 0 ; k --)
    {
        if (CurrentHealth(player[k]))
        {
            rad = Distance(GetObjectX(unit), GetObjectY(unit), GetObjectX(player[k]), GetObjectY(player[k]));
            if (rad < temp)
            {
                temp = rad;
                target = k;
            }
        }
    }
    return target;
}

void loopGuardianStat()
{
    int i;

    for (i = 4 ; i >= 0 ; i --)
    {
        if (CurrentHealth(AIKnight[i]))
        {
            if (GetDirection(GetLastItem(AIKnight[i])) < 20)
            {
                if (!HasSubclass(GetLastItem(AIKnight[i]), "HAMMER"))
                {
                    violateRule();
                    break;
                }
            }
            else
            {
                if (!HasSubclass(ExportQuiver(AIKnight[i]), "QUIVER"))
                {
                    violateRule();
                    break;
                }
            }
        }
    }
    if (!ggOver)
        FrameTimer(2, loopGuardianStat);
}

int ExportQuiver(int unit)
{
    int inv = GetLastItem(unit), i;

    for (i = 0 ; i < 6 && IsObjectOn(inv) ; i ++)
        inv = GetPreviousItem(inv);
    return inv;
}

void violateRule()
{
    UniPrintToAll("펌블 쓰지말랬지-!!");
    ObjectOff(Object("mainSwitch"));
    teleportAllPlayer(75);
}

void getAutoPlaced(int arg_0)
{
    int idx = GetDirection(GetLastItem(arg_0));
    float place = IntToFloat(idx * 23);

    MoveObject(arg_0, GetWaypointX(47) - place, GetWaypointY(47) + place);
    NPCS[idx + 40] = 0;
}

void DisplayScore()
{
    UniChatMessage(GetMaster(), "스코어 보드판\n인간팀 킬수:\t" + IntToString(HumanScore) + "킬\n알파고팀 킬수:\t" + IntToString(BotScore) + "킬", 60);
    SecondTimer(1, DisplayScore);
}

string randomSummonUnit()
{
    string table = {"SUMMON_GHOST", "SUMMON_EMBER_DEMON", "SUMMON_EVIL_CHERUB", "SUMMON_MECHANICAL_FLYER", "FIST"};

    return "SPELL_" + ToStr(SToInt(table) + Random(0, 4));
}

int GetMaster()
{
    int unit;

    if (!unit)
    {
        unit = CreateObject("Hecubah", 73);
        Frozen(unit, 1);
    }
    return unit;
}

float IntToFloat(int x)
{
	int i, pos = x;
	float result = 0.0;
	if (pos < 0)
		pos = -pos;
	for (i = 0; i < 32; i+=1)
	{
		if (pos & 0x80000000)
			result += 1.0;
		pos = pos << 1;
		if (i != 31)
			result *= 2.0;
	}
	if (x < 0)
		return -result;
	else
		return result;
}

void strVictory()
{
	int arr[38], i;
	string name = "DrainManaOrb";
	
	arr[0] = 2082988096; arr[1] = 1132584967; arr[2] = 2021689456; arr[3] = 2101523; arr[4] = 131108; arr[5] = 1140867072; arr[6] = 143132800; arr[7] = 2115109080; arr[8] = 670301187; arr[9] = 71320830; 
	arr[10] = 25364616; arr[11] = 805306898; arr[12] = 773070848; arr[13] = 71566400; arr[14] = 2139748352; arr[15] = 283233795; arr[16] = 35660322; arr[17] = 83870788; arr[18] = 8; arr[19] = 286355728; 
	arr[20] = 36569632; arr[21] = 2139358208; arr[22] = 143261568; arr[23] = 17829902; arr[24] = 35619362; arr[25] = 134234116; arr[26] = 142674056; arr[27] = 536936720; arr[28] = 1069679136; arr[29] = 71597952; 
	arr[30] = 8915199; arr[31] = 2131763473; arr[32] = 536870978; arr[33] = 2084602936; arr[34] = 1619574667; arr[35] = 534839311; arr[36] = 1107304448; arr[37] = 1074004095; 
	while (i < 38)
	{
		drawstrVictory(arr[i], name);
		i ++;
	}
}

void drawstrVictory(int arg_0, string name)
{
	int count, i;
	float pos_x, pos_y;

	if (!count)
	{
		pos_x = GetWaypointX(76);
		pos_y = GetWaypointY(76);
	}
	for (i = 1 ; i > 0 && count < 1178 ; i <<= 1)
	{
		if (i & arg_0)
			CreateObject(name, 76);
		if (count % 108 == 107)
			MoveWaypoint(76, GetWaypointX(76) - 214.000000, GetWaypointY(76) + 2.000000);
		else
			MoveWaypoint(76, GetWaypointX(76) + 2.000000, GetWaypointY(76));
		count ++;
	}
	if (count >= 1178)
	{
		count = 0;
		MoveWaypoint(76, pos_x, pos_y);
	}
}

string PlayerName(int ptr)
{
    int addr = GetMemory(0x97bb40), xwis_id = GetMemory(GetMemory(ptr + 0x2ec) + 0x114) + 0x830;

    SetMemory(addr, GetMemory(xwis_id));
    SetMemory(addr + 4, GetMemory(xwis_id + 4));
    SetMemory(addr + 8, GetMemory(xwis_id + 8));
	StopScript(0);
}

int GetMemory(int addr)
{
    return Unknownb9(addr);
}

void SetMemory(int addr, int value)
{
    Unused59(addr, value);
}

float MathSine(int angle, float size)
{
    float var_0[91];
    int i, k;
 
    if (!ToInt(var_0[90]))
    {
        MoveWaypoint(angle + 1, GetWaypointX(angle), GetWaypointY(angle) - 1.0);
        for (i = 0 ; i <= 90 ; i ++)
        {
            var_0[i] = GetSineValue(angle, size);
            Delete(k + i + 1);
        }
        return var_0[0];
    }
    k = angle / 90;
    i = angle - (k * 90);

    if (k % 2) i = 90 - i;
    if ((angle / 180) % 2) return -var_0[i] * size;
	else return var_0[i] * size;
}

float GetSineValue(int wp, float c)
{
    float x_ratio = WayRatioX(wp, wp + 1), y_ratio = WayRatioY(wp, wp + 1), res;

    res = GetWaypointX(wp) - GetWaypointX(wp + 1);
    MoveWaypoint(wp + 1, GetWaypointX(wp) - (c * y_ratio) - x_ratio, GetWaypointY(wp) + (c * x_ratio) - y_ratio);
    return res;
}

float WayRatioX(int wp1, int wp2)
{
    return (GetWaypointX(wp1) - GetWaypointX(wp2)) * 1.0 / Distance(GetWaypointX(wp1), GetWaypointY(wp1), GetWaypointX(wp2), GetWaypointY(wp2));
}

float WayRatioY(int wp1, int wp2)
{
    return (GetWaypointY(wp1) - GetWaypointY(wp2)) * 1.0 / Distance(GetWaypointX(wp1), GetWaypointY(wp1), GetWaypointX(wp2), GetWaypointY(wp2));
}

float UnitAngleCos(int unit, float size)
{
    return MathSine((GetDirection(unit) * 45 / 32) + 90, size);
}

float UnitAngleSin(int unit, float size)
{
    return MathSine(GetDirection(unit) * 45 / 32, size);
}

string ToStr(int x)
{
    StopScript(x);
}

float UnitRatioX(int unit, int target, float size)
{
    return (GetObjectX(unit) - GetObjectX(target)) * size / Distance(GetObjectX(unit), GetObjectY(unit), GetObjectX(target), GetObjectY(target));
}

float UnitRatioY(int unit, int target, float size)
{
    return (GetObjectY(unit) - GetObjectY(target)) * size / Distance(GetObjectX(unit), GetObjectY(unit), GetObjectX(target), GetObjectY(target));
}

float ToFloat(int x)
{
    StopScript(x);
}

int ToInt(float x)
{
    StopScript(x);
}

void CharToWideChar(string x)
{
    int ptr = GetMemory(0x97bb40 + (4 * SToInt(x))), dump = 0x751030, arr[2], read, sh = 0xff, end = 0;

    while (1)
    {
        read = GetMemory(ptr);
        if (!(read & 0xff) || !((read >> 8) &0xff) || !((read >> 16) &0xff) || !((read >> 24) &0xff))
            end = 1;
        arr[0] = (read & sh) | (((read >> 8) & sh) << 16);
        arr[1] = ((read >> 16) & sh) | (((read >> 24) & sh) << 16);
        SetMemory(dump, arr[0]);
        SetMemory(dump + 4, arr[1]);
        dump += 8;
        ptr += 4;
        if (end)
            break;
    }
    SetMemory(dump, 0);
}

void UploadConsoleParse()
{
    int arr[7], ptr, link;

    if (!ptr)
    {
        arr[0] = 0;
        arr[1] = 0x443c8068; arr[2] = 0x68016a00; arr[3] = 0x751030; arr[4] = 0x82454ff;
        arr[5] = 0x310cc483; arr[6] = 0x90c3c0;
        ptr = CreateObject("InvisibleLightBlueHigh", 1);
        Raise(ptr, UploadConsoleParse);
        link = GetMemory(GetMemory(0x75ae28) + (0x30 * ToInt(GetObjectZ(ptr)) + 0x1c));
        Delete(ptr);
    }
    SetMemory(0x5c31cc, link + 4);
}

void CmdLine(string x)
{
    CharToWideChar(x);
    UploadConsoleParse();
    Unused50();
    SetMemory(0x5c31cc, 0x513c60);
}

void AbsoluteTargetStrike(int owner, int target, float threshold, int func)
{
    int unit = CreateObjectAt("InvisibleLightBlueLow", GetObjectX(target), GetObjectY(target));
    Raise(CreateObjectAt("InvisibleLightBlueLow", GetObjectX(owner), GetObjectY(owner)), threshold);

    SetOwner(owner, unit);
    Raise(unit, ToFloat(target));
    FrameTimerWithArg(1, unit, func);
}

void FistShot(int ptr)
{
    int owner = GetOwner(ptr), target = ToInt(GetObjectZ(ptr));
    float dt = Distance(GetObjectX(ptr), GetObjectY(ptr), GetObjectX(target), GetObjectY(target));
    float vectX = UnitRatioX(target, ptr, dt), vectY = UnitRatioY(target, ptr, dt);

    if (CurrentHealth(owner) && CurrentHealth(target) && IsObjectOn(owner))
    {
        MoveObject(ptr, GetObjectX(target) + (vectX * GetObjectZ(ptr + 1)), GetObjectY(target) + (vectY * GetObjectZ(ptr + 1)));
        if (IsVisibleTo(ptr, owner))
            CastSpellObjectLocation("SPELL_FIST", owner, GetObjectX(ptr), GetObjectY(ptr));
        else
            CastSpellObjectObject("SPELL_FIST", owner, target);
    }
    Delete(ptr);
    Delete(ptr + 1);
}

void MeteorShot(int ptr)
{
    int owner = GetOwner(ptr), target = ToInt(GetObjectZ(ptr));
    float dt = Distance(GetObjectX(ptr), GetObjectY(ptr), GetObjectX(target), GetObjectY(target));
    float vectX = UnitRatioX(target, ptr, dt), vectY = UnitRatioY(target, ptr, dt);

    if (CurrentHealth(owner) && CurrentHealth(target) && IsObjectOn(owner))
    {
        MoveObject(ptr, GetObjectX(target) + (vectX * GetObjectZ(ptr + 1)), GetObjectY(target) + (vectY * GetObjectZ(ptr + 1)));
        if (IsVisibleTo(ptr, owner))
            CastSpellObjectLocation("SPELL_METEOR", owner, GetObjectX(ptr), GetObjectY(ptr));
        else
            CastSpellObjectObject("SPELL_METEOR", owner, target);
    }
    Delete(ptr);
    Delete(ptr + 1);
}

void ConjFireballShot(int ptr)
{
    int owner = GetOwner(ptr), target = ToInt(GetObjectZ(ptr)), unit;
    float dt = Distance(GetObjectX(ptr), GetObjectY(ptr), GetObjectX(target), GetObjectY(target));
    float vectX = UnitRatioX(target, ptr, dt), vectY = UnitRatioY(target, ptr, dt);

    if (CurrentHealth(owner) && CurrentHealth(target) && IsObjectOn(owner))
    {
        unit = CreateObjectAt("Fireball", GetObjectX(owner) + UnitRatioX(target, owner, 32.0), GetObjectY(owner) + UnitRatioY(target, owner, 32.0));
        SetOwner(owner, unit);
        MoveObject(ptr, GetObjectX(target) + (vectX * GetObjectZ(ptr + 1)), GetObjectY(target) + (vectY * GetObjectZ(ptr + 1)));
        if (IsVisibleTo(ptr, owner))
        {
            PushObjectTarget(unit, ptr, 35.0);
            LookAtObject(unit, ptr);
        }
        else
        {
            PushObjectTarget(unit, target, 35.0);
            LookAtObject(unit, target);
        }
    }
    Delete(ptr);
    Delete(ptr + 1);
}

int SToInt(string x)
{
    StopScript(x);
}

void PutBerserkerText(int unit)
{
    if (CurrentHealth(unit))
    {
        if (IsObjectOn(unit))
        {
            MoveWaypoint(1, GetObjectX(unit) - 60.0, GetObjectY(unit) + 30.0);
            FrameTimerWithArg(60, BerserkerText(), RemoveText);
        }
    }
}

int BerserkerText()
{
    int unit = CreateObject("RedPotion", 1) + 1;

    StrBerserkerCharge();
    LookWithAngle(CreateObject("InvisibleLightBlueLow", 1), 1);
    Delete(unit - 1);
    return unit;
}

void RemoveText(int arg)
{
    int loop = 1, ptr = arg;

    while (loop)
    {
        if (GetDirection(ptr)) loop = 0;
        Delete(ptr);
        ptr ++;
    }
}

void StrBerserkerCharge()
{
	int arr[24], i, count = 0;
	string name = "HealOrb";
	float pos_x = GetWaypointX(1), pos_y = GetWaypointY(1);

	arr[0] = 2117067330; arr[1] = 1174161156; arr[2] = 138449032; arr[3] = 135266592; arr[4] = 270803490; arr[5] = 100419588; arr[6] = 151554180; arr[7] = 135397640; 
	arr[8] = 2116165890; arr[9] = 133986823; arr[10] = 143147140; arr[11] = 269566241; arr[12] = 573104386; arr[13] = 72370244; arr[14] = 168337544; arr[15] = 571609361; 
	arr[16] = 1112023298; arr[17] = 75759688; arr[18] = 554180753; arr[19] = 1058083361; arr[20] = 570828834; arr[21] = 71631936; arr[22] = 524416; arr[23] = 16781313; 
	
	for (i = 0 ; i < 24 ; i ++)
		count = DrawStrBerserkerCharge(arr[i], name, count);
	MoveWaypoint(1, pos_x, pos_y);
}

int DrawStrBerserkerCharge(int arg, string name, int count)
{
	int i;

	for (i = 1 ; i > 0 && count < 744 ; i <<= 1)
	{
		if (i & arg)
			CreateObject(name, 1);
		if (count % 68 == 67)
			MoveWaypoint(1, GetWaypointX(1) - 134.0, GetWaypointY(1) + 2.0);
		else
			MoveWaypoint(1, GetWaypointX(1) + 2.0, GetWaypointY(1));
		count ++;
	}
	return count;
}

void PutAlphagoDeathText(int unit)
{
    MoveWaypoint(1, GetObjectX(unit) - 60.0, GetObjectY(unit) + 30.0);
    FrameTimerWithArg(60, AlphagoDeathText(), RemoveText);
    Delete(unit);
}

int AlphagoDeathText()
{
    int unit = CreateObject("RedPotion", 1) + 1;

    StrAlphagoIsDead();
    LookWithAngle(CreateObject("InvisibleLightBlueLow", 1), 1);
    Delete(unit - 1);
    return unit;
}

void StrAlphagoIsDead()
{
	int arr[23], i, count = 0;
	string name = "HealOrb";
	float pos_x = GetWaypointX(1), pos_y = GetWaypointY(1);

	arr[0] = 2083512892; arr[1] = 1338253319; arr[2] = 16781840; arr[3] = 1109458976; arr[4] = 143888516; arr[5] = 285737216; arr[6] = 1149535268; arr[7] = 138414080; 
	arr[8] = 606324513; arr[9] = 1107313156; arr[10] = 553650680; arr[11] = 671224034; arr[12] = 267403292; arr[13] = 1074823442; arr[14] = 1073741858; arr[15] = 4458640; 
	arr[16] = 2081407266; arr[17] = 2114695; arr[18] = 545327376; arr[19] = 2145582592; arr[20] = 67653696; arr[21] = 1049086; arr[22] = 528613376; 
	for (i = 0 ; i < 23 ; i ++)
		count = DrawStrAlphagoIsDead(arr[i], name, count);
	MoveWaypoint(1, pos_x, pos_y);
}

int DrawStrAlphagoIsDead(int arg, string name, int count)
{
	int i;

	for (i = 1 ; i > 0 && count < 713 ; i <<= 1)
	{
		if (i & arg)
			CreateObject(name, 1);
		if (count % 65 == 64)
			MoveWaypoint(1, GetWaypointX(1) - 128.0, GetWaypointY(1) + 2.0);
		else
			MoveWaypoint(1, GetWaypointX(1) + 2.0, GetWaypointY(1));
		count ++;
	}
	return count;
}

void StrDefeatTeam()
{
	int arr[16], i, count = 0;
	string name = "ManaBombOrb";
	float pos_x = GetWaypointX(1), pos_y = GetWaypointY(1);

	arr[0] = 2116362942; arr[1] = 609223748; arr[2] = 1351123081; arr[3] = 334571796; arr[4] = 623023138; arr[5] = 1384399876; arr[6] = 142641528; arr[7] = 1911102625; 
	arr[8] = 580133423; arr[9] = 71303242; arr[10] = 2131314853; arr[11] = 689217537; arr[12] = 1042423874; arr[13] = 1141394373; arr[14] = 151035912; arr[15] = 510; 
	
	for (i = 0 ; i < 16 ; i ++)
		count = DrawStrDefeatTeam(arr[i], name, count);
	MoveWaypoint(1, pos_x, pos_y);
}

int DrawStrDefeatTeam(int arg, string name, int count)
{
	int i;

	for (i = 1 ; i > 0 && count < 496 ; i <<= 1)
	{
		if (i & arg)
			CreateObject(name, 1);
		if (count % 44 == 43)
			MoveWaypoint(1, GetWaypointX(1) - 86.0, GetWaypointY(1) + 2.0);
		else
			MoveWaypoint(1, GetWaypointX(1) + 2.0, GetWaypointY(1));
		count ++;
	}
	return count;
}

void LinkBear2BinScript(int unit)
{
    int ptr = UnitToPtr(unit);

    if (ptr)
        SetMemory(GetMemory(ptr + 0x2ec) + 0x1e4, Bear2BinTable());
}

void BerserkerNoDelayCore(int plr)
{
    int arr[10];

    if (!MaxHealth(arr[plr]))
    {
        arr[plr] = CreateObject("Bear2", 81 + plr);
        LinkBear2BinScript(arr[plr]);
        CreateObjectAt("Rat", GetObjectX(arr[plr]), GetObjectY(arr[plr]) + 23.0);
        SetOwner(player[plr], arr[plr]);
        LookAtObject(arr[plr], arr[plr] + 1);
        HitLocation(arr[plr], GetObjectX(arr[plr] + 1), GetObjectY(arr[plr] + 1));
        FrameTimerWithArg(3, arr[plr], RemoveCoreUnits);
    }
}

void RemoveCoreUnits(int ptr)
{
    Delete(ptr);
    Delete(ptr + 1);
}

int GetShootXBowFunc()
{
    StopScript(AlphagoShootXBow);
}

int GetFistShotFunc()
{
    StopScript(FistShot);
}

int GetMeteorShotFunc()
{
    StopScript(MeteorShot);
}

int GetFireballShotFunc()
{
    StopScript(ConjFireballShot);
}

int ImportUnitToPtrFunc()
{
    int arr[10], ptr, link;
    if (!arr[0])
    {
        arr[0] = 0x50725068; arr[1] = 0x2414FF00; arr[2] = 0x511B6068; arr[3] = 0x54FF5000; arr[4] = 0xC4830424;
        arr[5] = 0x7230680C; arr[6] = 0xFF500050; arr[7] = 0x83042454; arr[8] = 0xC03108C4; arr[9] = 0x909090C3; 
        ptr = CreateObject("AmbBeachBirds", 1);
        Raise(ptr, ImportUnitToPtrFunc);
        link = GetMemory(GetMemory(0x75ae28) + (0x30 * ToInt(GetObjectZ(ptr)) + 0x1c));
        Delete(ptr);
    }
    return link;
}

int UnitToPtr(int unit)
{
    int temp = GetMemory(0x5c336c), res;
    SetMemory(0x5c336c, ImportUnitToPtrFunc());
    res = Unknownb8(unit);
    SetMemory(0x5c336c, temp);
	return res;
}

void WarThrowSword(int owner, int target)
{
    int unit;

    if (CurrentHealth(owner) && CurrentHealth(target))
    {
        MoveWaypoint(1, GetObjectX(owner) + UnitRatioX(target, owner, 20.0), GetObjectY(owner) + UnitRatioY(target, owner, 20.0));
        Effect("SMOKE_BLAST", GetWaypointX(1), GetWaypointY(1), 0.0, 0.0);
        AudioEvent("HarpoonInvoke", 1);
        AudioEvent("PowderBarrelExplode", 1);
        unit = CreateObject("InvisibleLightBlueHigh", 1);
        SetOwner(owner, unit);
        Raise(unit, ToFloat(target));
        FrameTimerWithArg(1, unit, FlyingSword);
    }
}

void FlyingSword(int ptr)
{
    int owner = GetOwner(ptr), target = ToInt(GetObjectZ(ptr)), count = GetDirection(ptr), unit;

    if (CurrentHealth(owner) && CurrentHealth(target) && count < 19)
    {
        while (1)
        {
            if (CheckSeeUnit(ptr, target))
            {
                MoveObject(ptr, GetObjectX(ptr) + UnitRatioX(target, ptr, 21.0), GetObjectY(ptr) + UnitRatioY(target, ptr, 21.0));
                if (DistanceUnitToUnit(ptr, target) > 50.0)
                {
                    unit = CreateObjectAt("HarpoonBolt", GetObjectX(ptr), GetObjectY(ptr));
                    LookAtObject(unit, target);
                    Frozen(unit, 1);
                    DeleteObjectTimer(unit, 9);
                    LookWithAngle(ptr, count + 1);
                    break;
                }
                else
                {
                    MoveWaypoint(1, GetObjectX(ptr), GetObjectY(ptr));
                    AudioEvent("HarpoonReel", 1);
                    AudioEvent("StoneHitMetal", 1);
                    GreenSparkFx(GetWaypointX(1), GetWaypointY(1));
                    WarPullEnemy(owner, target);
                }
            }
            LookWithAngle(ptr, 100);
            break;
        }
        FrameTimerWithArg(1, ptr, FlyingSword);
    }
    else
    {
        Delete(ptr);
    }
}

void WarPullEnemy(int owner, int target)
{
    int unit = CreateObjectAt("InvisibleLightBlueHigh", GetObjectX(target), GetObjectY(target));

    ObjectOff(CreateObjectAt("Maiden", GetObjectX(target), GetObjectY(target)));
    CreateObjectAt("InvisibleLightBlueHigh", GetObjectX(owner), GetObjectY(owner));
    Raise(CreateObjectAt("InvisibleLightBlueHigh", GetObjectX(target), GetObjectY(target)), CurrentHealth(owner));
    Damage(unit + 1, 0, MaxHealth(unit + 1) + 1, -1);
    Frozen(unit + 1, 1);
    SetCallback(unit + 1, 9, PullRiskUnit);
    SetOwner(owner, unit);
    Raise(unit, ToFloat(target));
    PullUp(unit);
}

void PullUp(int ptr)
{
    int owner = GetOwner(ptr), target = ToInt(GetObjectZ(ptr)), count = GetDirection(ptr);

    if (CurrentHealth(owner) && CurrentHealth(target) && count < 20 && IsObjectOn(owner))
    {
        if (IsVisibleTo(owner, target) && DistanceUnitToUnit(owner, target) > 60.0)
        {
            MoveObject(ptr + 1, GetObjectX(target) + UnitRatioX(target, owner, 12.0), GetObjectY(target) + UnitRatioY(target, owner, 12.0));
            Effect("SENTRY_RAY", GetObjectX(owner), GetObjectY(owner), GetObjectX(target), GetObjectY(target));
            count += CheckCutPulling(owner, ptr + 3);
            LookWithAngle(ptr, count + 1);
        }
        else
            LookWithAngle(ptr, 100);
        FrameTimerWithArg(1, ptr, PullUp);
    }
    else
    {
        Delete(ptr);
        Frozen(ptr + 1, 0);
        Delete(ptr + 1);
        Delete(ptr + 2);
        Delete(ptr + 3);
    }
}

int CheckCutPulling(int owner, int ptr)
{
    int tempHp = ToInt(GetObjectZ(ptr)), curHp = CurrentHealth(owner);

    if (tempHp ^ curHp)
    {
        if (curHp < tempHp)
            return 100;
        Raise(ptr, ToFloat(curHp));
    }
    return 0;
}

void PullRiskUnit()
{
    int owner = GetOwner(GetTrigger() - 1), target = ToInt(GetObjectZ(GetTrigger() - 1));
    int count = GetDirection(GetTrigger() + 1);

    if (IsCaller(target))
    {
        if (!count)
        {
            if (CurrentHealth(owner) && CurrentHealth(target))
            {
                MoveWaypoint(1, GetObjectX(target), GetObjectY(target));
                AudioEvent("SentryRayHit", 1);
                Effect("VIOLET_SPARKS", GetObjectX(target), GetObjectY(target), 0.0, 0.0);
                Damage(target, owner, 15, 14);
            }
        }
        LookWithAngle(GetTrigger() + 1, (count + 1) % 7);
    }
}

int IsConjurer(int unit)
{
    return HasEnchant(unit, "ENCHANT_SNEAK");
}

void SplashHandler(int owner, int func, float x, float y, float range)
{
    int ptr = CreateObjectAt("InvisibleLightBlueHigh", range, y) + 1, k;

    SetOwner(owner, ptr - 1);
    Raise(ptr - 1, ToFloat(func));
    for (k = 0 ; k < 8 ; k ++)
    {
        DeleteObjectTimer(CreateObjectAt("WeirdlingBeast", x, y), 1);
        UnitNoCollide(ptr + k);
        LookWithAngle(ptr + k, k * 32);
        SetOwner(ptr - 1, ptr + k);
        SetCallback(ptr + k, 3, UnitVisibleSplash);
    }
    DeleteObjectTimer(ptr - 1, 2);
}

void UnitVisibleSplash()
{
    int parent;

    if (!HasEnchant(other, "ENCHANT_VILLAIN"))
    {
        parent = GetOwner(self);
        if (CurrentHealth(GetOwner(parent)))
        {
            if (Distance(GetObjectX(self), GetObjectY(self), GetObjectX(other), GetObjectY(other)) <= GetObjectX(parent))
            {
                Enchant(other, "ENCHANT_VILLAIN", 0.1);
                CallFunction(ToInt(GetObjectZ(parent)));
            }
        }
    }
}

void CallFunction(int func)
{
    int link, ptr;

    if (!link)
    {
        ptr = CreateObject("RedPotion", 1);
        Raise(ptr, Callee);
        link = GetMemory(GetMemory(0x75ae28) + (0x30 * ToInt(GetObjectZ(ptr)) + 0x20));
        Delete(ptr);
    }
    else
    {
        SetMemory(link + 4, func);
        Callee();
    }
}

void Callee()
{
    Callee();
}

void SetUnitScanRange(int unit, float range)
{
    int ptr = UnitToPtr(unit);

    if (ptr)
    {
        SetMemory(GetMemory(ptr + 0x2ec) + 0x520, ToInt(range));
    }
}

void SetUnitFlags(int unit, int flag)
{
	int ptr = UnitToPtr(unit);

    if (ptr)
        SetMemory(ptr + 0x10, flag);
}

int GetUnitFlags(int unit)
{
	int ptr = UnitToPtr(unit);

    if (ptr)
        return GetMemory(ptr + 0x10);
    return 0;
}

void UnitNoCollide(int unit)
{
    SetUnitFlags(unit, GetUnitFlags(unit) ^ 0x40);
}

void MapInitialize()
{
    int t = EnableMemoryReadWriteFunction(0);

    MusicEvent();
    MathSine(1, 1.0 / 57.3);
    CallFunction(0);
    ImportUnitToPtrFunc();
    ImportCreateAtFunc();
    ImportPlayerAutoTeamSign();

    int ptr = DiePlayerHandlerCopiedCode();
    ChangePlayerDeathSound(ptr, 913);
    PlayerUpdate4f8100();
    SetMemory(ptr + 0x386, (GetMemory(ptr + 0x386) & 0xffff0000) | 0x9eb);

    RegistSignMessage(Object("VictoryPic"), "명예의 전당:: 고된 승부 끝에 값진 승리를 손에 거머쥔 자만이 이곳에 오게 되어있지");
    RegistSignMessage(Object("DefeatPic"), "패배자의 지옥:: 헤헤.. 뜨겁지? 그러니 어서 빨리 다시 도전해 보라구!");
    FrameTimer(30, PlayerClassOnLoop);
    FrameTimer(3, InitRTable);
    //FrameTimer(60, loopGuardianStat); --remove 25 nov 2019
    FrameTimer(60, loopGuardianAi);
    FrameTimer(190, startMent);
    FrameTimerWithArg(1, 0, initializeKnightHammers);
    FrameTimer(1, SetGameTypeCoopMode);
    //SetSpellRule();
}

int CheckUnitFrontSight(int unit, float dtX, float dtY)
{
    int temp = CreateObjectAt("InvisibleLightBlueHigh", GetObjectX(unit) + dtX, GetObjectY(unit) + dtY);
    int res = IsVisibleTo(unit, temp);

    Delete(temp);
    return res;
}

void GreenSparkFx(float x, float y)
{
    int ptr = CreateObjectAt("MonsterGenerator", x, y);

    Damage(ptr, 0, 10, 100);
    Delete(ptr);
}

float DistanceUnitToUnit(int unit1, int unit2)
{
    return Distance(GetObjectX(unit1), GetObjectY(unit1), GetObjectX(unit2), GetObjectY(unit2));
}

int CheckSeeUnit(int unit1, int unit2)
{
    return (IsVisibleTo(unit1, unit2) || IsVisibleTo(unit2, unit1));
}

int GetUnitThingID(int unit)
{
    int ptr = UnitToPtr(unit);
    if (ptr)
        return GetMemory(ptr + 0x04);
    return 0;
}

void CheckMagicElement(int cur)
{
    int ptr = UnitToPtr(cur);

    if (ptr)
    {
        if (GetMemory(GetMemory(ptr + 0x2ec) + 0x0c) == 33)
        {
            SetMemory(GetMemory(ptr + 0x2ec) + 0x0c, 0x4a);
            Enchant(cur, "ENCHANT_RUN", 0.0);
        }
    }
}

void SearchIndexLoop()
{
    int cur, last = CreateObject("InvisibleLightBlueHigh", 1), thingID;

    if (cur)
    {
        while (cur < last)
        {
            thingID = GetUnitThingID(cur);
            if (thingID == 531)
                AIBotShootBowHandler(GetOwner(cur), cur);
            else if (thingID == 955)
                CheckMagicElement(cur);
            else if (thingID == 618)
                Delete(cur);
            cur ++;
        }
    }
    else
        cur = last;
    Delete(last);
    FrameTimer(1, SearchIndexLoop);
}

void AIBotShootBowHandler(int owner, int cur)
{
    if (HasClass(owner, "MONSTER"))
    {
        if (!HasEnchant(cur, "ENCHANT_VILLAIN") && CurrentHealth(owner))
        {
            AIBotDetectEnemy(owner);
            Delete(cur);
        }
    }
}

void AIBotDetectEnemy(int owner)
{
    int unit = CreateObjectAt("WeirdlingBeast", GetObjectX(owner), GetObjectY(owner));
    SetOwner(owner, CreateObjectAt("InvisibleLightBlueHigh", GetObjectX(owner), GetObjectY(owner)));
    Raise(CreateObjectAt("InvisibleLightBlueHigh", GetObjectX(owner), GetObjectY(owner)), 5000.0);
    LookWithAngle(unit, GetDirection(owner));
    CreatureGuard(unit, GetObjectX(unit), GetObjectY(unit), GetObjectX(unit) + UnitAngleCos(unit, 200.0), GetObjectY(unit) + UnitAngleSin(unit, 200.0), 500.0);
    UnitNoCollide(unit);
    SetCallback(unit, 3, GetNealryEnemy);
    DeleteObjectTimer(unit, 1);
    FrameTimerWithArg(1, unit + 1, AIBotShootBow);
}

void GetNealryEnemy()
{
    int ptr = GetTrigger() + 1;
    int target = ToInt(GetObjectZ(ptr));
    float dist = DistanceUnitToUnit(self, other);

    if (dist < GetObjectZ(ptr + 1))
    {
        Raise(ptr + 1, dist);
        Raise(ptr, ToFloat(GetCaller()));
    }
}

void AIBotShootBow(int ptr)
{
    int owner = GetOwner(ptr), target = ToInt(GetObjectZ(ptr));

    if (CurrentHealth(owner) && CurrentHealth(target))
    {
        AbsoluteTargetStrike(owner, target, 85.0, GetShootXBowFunc());
    }
    Delete(ptr);
    Delete(ptr + 1);
}

string StringOverflow(int t)
{
	return ToStr((t - 0x97bb40) / 4);
}

string EnchantList(int sNumber)
{
	return StringOverflow(0x596f24 + (sNumber * 4));
}

int UnitCheckEnchant(int sUnit, int sMagicFlag)
{
    int ptr = UnitToPtr(sUnit);

    if (ptr)
        return GetMemory(ptr + 0x154) & sMagicFlag;
    return 0;
}

int GetLShift(int sCount)
{
    return (1 << sCount);
}

void SetUnitEnchantCopy(int sUnit, int sMagicFlag)
{
	int ptr = UnitToPtr(sUnit);

	if (ptr)
	{
		Enchant(sUnit, EnchantList(6), 0.0);
		SetMemory(ptr + 0x154, GetMemory(ptr + 0x154) | sMagicFlag);
	}
}

void UnitSetEnchantTime(int unit, int enchantNumber, int durateTime)
{
	int ptr = UnitToPtr(unit), temp, tempPtr;

	if (ptr)
	{
		SetUnitEnchantCopy(unit, GetLShift(enchantNumber));
		tempPtr = ptr + 0x158 + ((enchantNumber / 2) * 4);
		temp = GetMemory(tempPtr);
		if (enchantNumber % 2)
		{
			SetMemory(tempPtr, (GetMemory(tempPtr) & 0xffff) | (durateTime << 0x10));
		}
		else
			SetMemory(tempPtr, ((GetMemory(tempPtr) >> 0x10) << 0x10) | durateTime);
	}
}

int ImportPlayerAutoTeamSign()
{
    int arr[17], link;

    if (!link)
    {
        arr[0] = 0x4191D068; arr[1] = 0x50515600; arr[2] = 0x000020B9; arr[3] = 0xF9E0B800; arr[4] = 0xC9850062;
        arr[5] = 0x8B492774; arr[6] = 0x12DC0530; arr[7] = 0xF6850000; arr[8] = 0x5150F074; arr[9] = 0x8D24468B;
        arr[10] = 0x016A304E; arr[11] = 0x51016A50; arr[12] = 0x54FF016A; arr[13] = 0xC4832824; arr[14] = 0xEB585914;
        arr[15] = 0x5E5958D5; arr[16] = 0xC304C483;
        link = GetScrDataField(ImportPlayerAutoTeamSign);
    }
    return link;
}

void PlayerAutoTeamSign()
{
    int temp = GetMemory(0x5c31cc);

    SetMemory(0x5c31cc, ImportPlayerAutoTeamSign());
    Unused50();
    SetMemory(0x5c31cc, temp);
}

void MakeCoopTeam()
{
    int arr[3];
    int teamCount = GetMemory(0x654D5C), temp, link;

    if (!teamCount && !link)
    {
        arr[0] = 0x417E1068; arr[1] = 0x2414FF00; arr[2] = 0xC304C483;
        link = GetScrDataField(MakeCoopTeam);
        temp = GetMemory(0x5c31cc);
        SetMemory(0x5c31cc, link);
        Unused50();
        SetMemory(0x5c31cc, temp);
        SetMemory(0x5d53a4, 268640519);
    }
}

void RemoveCoopTeamMode()
{
    int arr[6], link, temp;

    if (!link && GetMemory(0x654d5c) == 1)
    {
        arr[0] = 0x4DB8BE56; arr[1] = 0x20680065; arr[2] = 0x6A00418F; arr[3] = 0x54FF5600; arr[4] = 0xC4830824; arr[5] = 0x90C35E0C;
        link = GetScrDataField(RemoveCoopTeamMode);
        temp = GetMemory(0x5c31cc);
        SetMemory(0x5c31cc, link);
        Unused50();
        SetMemory(0x5c31cc, temp);
    }
}

void SetGameTypeCoopMode()
{
    MakeCoopTeam();
    PlayerAutoTeamSign();
}

int GetWordValue(int num)
{
	return num & 0xffff;
}

void WriteAddressByteValue(int addr, int byt)
{
	int temp = GetMemory(addr) & 0xffffff00;
	SetMemory(addr, temp | byt);
}

int NoxUnicodeToUtf8(int src, int destPtr)
{
	int i, byt, dest = destPtr;

	for (i = 0 ; i < 20 ; i ++)
	{
		byt = GetWordValue(GetMemory(src));
        if (!byt) break;
		if (byt < 0x80)
		{
			WriteAddressByteValue(dest, byt);
			dest ++;
		}
		else if (byt < 0x800)
		{
			WriteAddressByteValue(dest, ((byt >> 6) & 0x1f) | 0xc0);
			WriteAddressByteValue(dest + 1, (byt & 0x3f) | 0x80);
			dest += 2;
		}
		else
		{
			WriteAddressByteValue(dest, ((byt >> 12) & 0x0f) | 0xe0);
			WriteAddressByteValue(dest + 1, ((byt >> 6) & 0x3f) | 0x80);
			WriteAddressByteValue(dest + 2, (byt & 0x3f) | 0x80);
			dest += 3;
		}
        src += 2;
	}
    WriteAddressByteValue(dest, 0);
	return dest - destPtr;
}

string PlayerIngameNick(int sUnit)
{
    string emptyName = {
        "00:01234567890123456789abcd0123456789abxyz", "01:01234567890123456789abcd0123456789abxyz",
        "02:01234567890123456789abcd0123456789abxyz", "03:01234567890123456789abcd0123456789abxyz",
        "04:01234567890123456789abcd0123456789abxyz", "05:01234567890123456789abcd0123456789abxyz",
        "06:01234567890123456789abcd0123456789abxyz", "07:01234567890123456789abcd0123456789abxyz",
        "08:01234567890123456789abcd0123456789abxyz", "09:01234567890123456789abcd0123456789abxyz",
        "10:01234567890123456789abcd0123456789abxyz", "11:01234567890123456789abcd0123456789abxyz",
        "12:01234567890123456789abcd0123456789abxyz", "13:01234567890123456789abcd0123456789abxyz",
        "14:01234567890123456789abcd0123456789abxyz", "15:01234567890123456789abcd0123456789abxyz",
        "16:01234567890123456789abcd0123456789abxyz", "17:01234567890123456789abcd0123456789abxyz",
        "18:01234567890123456789abcd0123456789abxyz", "19:01234567890123456789abcd0123456789abxyz",
        "20:01234567890123456789abcd0123456789abxyz", "21:01234567890123456789abcd0123456789abxyz",
        "22:01234567890123456789abcd0123456789abxyz", "23:01234567890123456789abcd0123456789abxyz",
        "24:01234567890123456789abcd0123456789abxyz", "25:01234567890123456789abcd0123456789abxyz",
        "26:01234567890123456789abcd0123456789abxyz", "27:01234567890123456789abcd0123456789abxyz",
        "28:01234567890123456789abcd0123456789abxyz", "29:01234567890123456789abcd0123456789abxyz",
        "30:01234567890123456789abcd0123456789abxyz", "31:01234567890123456789abcd0123456789abxyz"};
    int ptr = UnitToPtr(sUnit), plrIndex, destPtr, srcPtr;
    
    if (ptr)
    {
        if (GetMemory(ptr + 0x08) & 4)
        {
            plrIndex = GetMemory(GetMemory(GetMemory(ptr + 0x2ec) + 0x114) + 0x810);
            destPtr = GetMemory(0x97bb40 + ((SToInt(emptyName) + plrIndex) * 4));
            srcPtr = GetMemory(GetMemory(ptr + 0x2ec) + 0x114) + 0x889;
            NoxUnicodeToUtf8(srcPtr, destPtr);
            return ToStr(SToInt(emptyName) + plrIndex);
        }
    }
    return "NULL";
}

int ImportUniChatCore()
{
    int arr[10], link;

    if (!link)
    {
        arr[0] = 0xC0685657; arr[1] = 0x6800528A; arr[2] = 0x00507250; arr[3] = 0x8B2414FF; arr[4] = 0x2414FFF8;
        arr[5] = 0x14FFF08B; arr[6] = 0x56505724; arr[7] = 0x102454FF; arr[8] = 0x5E14C483; arr[9] = 0x9090C35F;
        CancelTimer(FrameTimerWithArg(10, ImportUniChatCore, ImportUniChatCore));
        link = GetMemory(GetMemory(0x75ae28) + (0x30 * GetMemory(GetMemory(0x83395c) + 8) + 0x1c));
    }
    return link;
}

void UniChatCore(int plrPtr, int sPtr, int sTime)
{
    int temp = GetMemory(0x5c3320);

    SetMemory(0x5c3320, ImportUniChatCore());
    GroupRunAway(sPtr, plrPtr, sTime);
    SetMemory(0x5c3320, temp);
}

int ImportUniPrintCore()
{
    int arr[8], link;

    if (!link)
    {
        arr[0] = 0x9EB06856; arr[1] = 0x5068004D; arr[2] = 0xFF005072; arr[3] = 0xF08B2414; arr[4] = 0x502414FF;
        arr[5] = 0x2454FF56; arr[6] = 0x10C4830C; arr[7] = 0x9090C35E; 
        CancelTimer(FrameTimerWithArg(10, ImportUniPrintCore, ImportUniPrintCore));
        link = GetMemory(GetMemory(0x75ae28) + (0x30 * GetMemory(GetMemory(0x83395c) + 8) + 0x1c));
    }
    return link;
}

void UniPrintCore(int plrPtr, int sPtr)
{
    int temp = GetMemory(0x5c31f4);

    SetMemory(0x5c31f4, ImportUniPrintCore());
    Unused5a(sPtr, plrPtr);
    SetMemory(0x5c31f4, temp);
}

int GetByteValue(int ptr)
{
    return GetMemory(ptr) & 0xff;
}

void WriteAddressWordValue(int addr, int word)
{
    int temp = GetMemory(addr) & 0xffff0000;
    SetMemory(addr, temp | word);
}

void NoxUtf8ToUnicode(int src, int dest)
{
    int i = 0, byt;

    while (1)
    {
        byt = GetByteValue(src + i);
        if (!byt) break;
        if (!(byt & 0x80))
        {
            WriteAddressWordValue(dest, byt);
            i ++;
        }
        else if ((byt & 0xe0) == 0xc0)
        {
            WriteAddressWordValue(dest, ((byt & 0x1f) <<6) | (GetByteValue(src + i + 1) & 0x3f));
            i += 2;
        }
        else if ((byt & 0xf0) == 0xe0)
        {
            WriteAddressWordValue(dest, ((byt & 0xf) << 12) | ((GetByteValue(src + i + 1) & 0x3f) << 6) | (GetByteValue(src + i + 2) & 0x3f));
            i += 3;
        }
        dest += 2;
    }
    WriteAddressWordValue(dest, 0);
}

void UniPrint(int sUnit, string sMsg)
{
    int wDest[300];
    int ptr = UnitToPtr(sUnit), str = SToInt(sMsg), link;

    if (ptr)
    {
        str = GetMemory(0x97bb40 + (str * 4));
        if (!link)
        {
            CancelTimer(FrameTimerWithArg(10, UniPrint, UniPrint));
            link = GetMemory(GetMemory(0x75ae28) + (0x30 * GetMemory(GetMemory(0x83395c) + 8) + 0x1c));
        }
        NoxUtf8ToUnicode(str, link + 8);
        UniPrintCore(ptr, link + 8);
    }
}

void UniChatMessage(int sUnit, string sMsg, int duration)
{
    int wDest[300];
    int ptr = UnitToPtr(sUnit), str = SToInt(sMsg), link;

    if (ptr)
    {
        str = GetMemory(0x97bb40 + (str * 4));
        if (!link)
        {
            CancelTimer(FrameTimerWithArg(10, UniChatMessage, UniChatMessage));
            link = GetMemory(GetMemory(0x75ae28) + (0x30 * GetMemory(GetMemory(0x83395c) + 8) + 0x1c));
        }
        NoxUtf8ToUnicode(str, link + 12);
        UniChatCore(ptr, link + 12, duration);
    }
}

void UniPrintToAll(string sMsg)
{
    int wDest[300];
    int plrPtr = 0x62f9e0, link, str = SToInt(sMsg), i;

    if (!link)
    {
        CancelTimer(FrameTimerWithArg(10, UniPrint, UniPrint));
        link = GetMemory(GetMemory(0x75ae28) + (0x30 * GetMemory(GetMemory(0x83395c) + 8) + 0x1c)) + 4;
    }
    str = GetMemory(0x97bb40 + (str * 4));
    NoxUtf8ToUnicode(str, link);
    for (i = 0 ; i < 32 ; i ++)
    {
        if (GetMemory(plrPtr))
            UniPrintCore(GetMemory(plrPtr), link);
        plrPtr += 0x12dc;
    }
}

int ImportUnitCollideFunc()
{
    int arr[10], link;

    if (!link)
    {
        arr[0] = 0x50731068; arr[1] = 0x50565500; arr[2] = 0x14246C8B; arr[3] = 0x1824748B;
        arr[4] = 0x02FC858B; arr[5] = 0x56550000; arr[6] = 0x2454FF50; arr[7] = 0x0CC48318;
        arr[8] = 0x835D5E58; arr[9] = 0x90C304C4;
        CancelTimer(FrameTimerWithArg(10, ImportUnitCollideFunc, ImportUnitCollideFunc));
        link = GetMemory(GetMemory(0x75ae28) + (0x30 * GetMemory(GetMemory(0x83395c) + 8) + 0x1c));
    }
    return link;
}

int ImportUseItemFunc()
{
    int arr[10], link;
    if (!link)
    {
        arr[0] = 0x50731068; arr[1] = 0x50565500; arr[2] = 0x1424748B; arr[3] = 0x18246C8B;
        arr[4] = 0x02FC858B; arr[5] = 0x56550000; arr[6] = 0x2454FF50; arr[7] = 0x0CC48318;
        arr[8] = 0x835D5E58; arr[9] = 0x90C304C4;
        CancelTimer(FrameTimerWithArg(10, ImportUseItemFunc, ImportUseItemFunc));
        link = GetMemory(GetMemory(0x75ae28) + (0x30 * GetMemory(GetMemory(0x83395c) + 8) + 0x1c));
    }
    return link;
}

int MathAbs(int num)
{
    if (num < 0)
        num = -num;
    return num;
}

int CheckSignDelay(int sPtr, int gap)
{
    int cFps = GetMemory(0x84ea04);

    if (MathAbs(cFps - GetMemory(sPtr)) > gap)
    {
        SetMemory(sPtr, cFps);
        return 1;
    }
    return 0;
}

void SignNotification()
{
    int wDest[300];
    int otPtr = GetMemory(0x979720), sePtr = GetMemory(0x979724);
    int link;

    if (otPtr && sePtr)
    {
        if (CheckSignDelay(GetMemory(sePtr + 0x2e0) + 100, 60))
        {
            CancelTimer(FrameTimerWithArg(10, SignNotification, SignNotification));
            if (!link)
                link = GetMemory(GetMemory(0x75ae28) + (0x30 * GetMemory(GetMemory(0x83395c) + 8) + 0x1c));
            NoxUtf8ToUnicode(GetMemory(GetMemory(sePtr + 0x2e0)), link);
            UniPrintCore(otPtr, link);
        }
    }
}

void RegistSignMessage(int sUnit, string sMsg)
{
    int ptr = UnitToPtr(sUnit), str = SToInt(sMsg);

    if (ptr)
    {
        str = GetMemory(0x97bb40 + (str * 4));
        //NoxUtf8ToUnicode(str, GetMemory(ptr + 0x2e0));
        SetMemory(ptr + 0x2dc, ImportUseItemFunc());
        CancelTimer(FrameTimerWithArg(10, SignNotification, SignNotification));
        SetMemory(ptr + 0x2fc, GetMemory(GetMemory(0x83395c) + 8));
        SetMemory(GetMemory(ptr + 0x2e0), str);
    }
}

int ImportUniBroadcast()
{
    int arr[6], link;

    if (!link)
    {
        arr[0] = 0x4D9FD068; arr[1] = 0x72506800; arr[2] = 0x14FF0050; arr[3] = 0x106A5024;
        arr[4] = 0x0C2454FF; arr[5] = 0xC310C483;
        CancelTimer(FrameTimerWithArg(10, ImportUniBroadcast, ImportUniBroadcast));
        link = GetMemory(GetMemory(0x75ae28) + (0x30 * GetMemory(GetMemory(0x83395c) + 8) + 0x1c));
    }
    return link;
}

void UniBroadcast(string sMsg)
{
    int wDest[300];
    int temp = GetMemory(0x5c3108), link, str = GetMemory(0x97bb40 + (SToInt(sMsg) * 4));

    if (!link)
    {
        CancelTimer(FrameTimerWithArg(10, UniBroadcast, UniBroadcast));
        link = GetMemory(GetMemory(0x75ae28) + (0x30 * GetMemory(GetMemory(0x83395c) + 8) + 0x1c));
    }
    NoxUtf8ToUnicode(str, link + 4);
    SetMemory(0x5c3108, ImportUniBroadcast());
    Unused1f(link + 4);
    SetMemory(0x5c3108, temp);
}

int ImportRemoveSneakDelay()
{
    int arr[7], link;

    if (!link)
    {
        arr[0] = 0x72506850; arr[1] = 0x14FF0050; arr[2] = 0xC3006824; arr[3] = 0x046A004F; arr[4] = 0x2454FF50; arr[5] = 0x10C48308; arr[6] = 0x9090C358;
        link = GetScrDataField(ImportRemoveSneakDelay);
    }
    return link;
}

void RemoveTreadLightly(int plrUnit)
{
    int ptr = UnitToPtr(plrUnit), temp = GetMemory(0x5c336c);

    if (ptr)
    {
        if (GetMemory(ptr + 0x08) & 0x04)
        {
            SetMemory(0x5c336c, ImportRemoveSneakDelay());
            Unknownb8(ptr);
            SetMemory(0x5c336c, temp);
        }
    }
}

int FloatToInt(float x)
{
    int i, result = 0;
    float pos = x;

    if (pos < 0.0) pos = -pos;
    pos = pos / 2147483648.0;
    if (pos < 2.0)
    { 
        for (i = 0 ; i < 32 ; i ++)
        {
            if (pos >= 1.0)
            {
                result ++;
                pos -= 1.0;
            }
            if (i != 31) result = result << 1;
            pos *= 2.0;
        }
    }
    else result = 0x7fffffff;
    if (x < 0.0) return -result;
    else return result;
}

int CheckWallByCoor(int xPos, int yPos)
{
    int spX, spY, tx, ty, rx;

    if (xPos > yPos) xPos += 23;
    else             yPos += 23;
    spX = (xPos + yPos - 22) / 46;
    spY = (xPos - yPos) / 46;
    tx = spX * 46;
    ty = spY * 46;
    rx = (tx + ty) / 2;
    return Wall(rx / 23, (rx - ty) / 23);
}

void AroundWallDestroy(int sUnit)
{
    int xProfile = FloatToInt(GetObjectX(sUnit)), yProfile = FloatToInt(GetObjectY(sUnit));

    WallBreak(CheckWallByCoor(xProfile, yProfile));
    WallBreak(CheckWallByCoor(xProfile - 23, yProfile - 23));
    WallBreak(CheckWallByCoor(xProfile + 23, yProfile - 23));
    WallBreak(CheckWallByCoor(xProfile - 23, yProfile + 23));
    WallBreak(CheckWallByCoor(xProfile + 23, yProfile + 23));
    WallBreak(CheckWallByCoor(xProfile - 23, yProfile));
    WallBreak(CheckWallByCoor(xProfile + 23, yProfile));
    WallBreak(CheckWallByCoor(xProfile, yProfile + 23));
    WallBreak(CheckWallByCoor(xProfile, yProfile - 23));
}

void ChangePlayerDeathSound(int handle, int soundNumber) //@brief. 유저가 죽었을 때 효과음을 변경합니다
{
    SetMemory(handle + 0x258, soundNumber);  //@brief. SoundList.txt 파일을 참고하세요
}

int CallNode54d2b0()
{
    int arr[40];

    if (!arr[0])
    {
        arr[0] = 0x54d2d1;
        arr[1] = 0x54d2e3;
        arr[2] = 0x54d2f3;
        arr[3] = 0x54d30a;
        arr[4] = 0x54d348;
        arr[5] = 0x54d375;
        arr[6] = 0x54d3aa;
        arr[7] = 0x54d45c;
        arr[8] = 0x54d47b;
        arr[9] = 0x54d513;
        arr[10] = 0x54d527;
        arr[11] = 0x54d566;
        arr[12] = 0x54d574;
        arr[13] = 0x54d588;
        arr[14] = 0x54d594;
        arr[15] = 0x54d5a6;
        arr[16] = 0x54d5b2;
        arr[17] = 0x54d5c4;
        arr[18] = 0x54d5d1;
        arr[19] = 0x54d5e2;
        arr[20] = 0x54d5f4;
        arr[21] = 0x54d610;
        arr[22] = 0x54d622;
        arr[23] = 0x54d62c;
        arr[24] = 0x54d639;
        arr[25] = 0x54d642;
        arr[26] = 0x54d65b;
        arr[27] = 0x54d662;
        arr[28] = 0x54d668;
        arr[29] = 0x54d67a;
        arr[30] = 0x54d680;
        arr[31] = 0x54d693;
        arr[32] = 0x54d6a6;
        arr[33] = 0x54d727;
        arr[34] = 0x54d72d;
        arr[35] = 0x54d733;
        arr[36] = 0x54d73d;
        arr[37] = 0x54d749;
        arr[38] = 0x54d782;
    }
    return GetScrDataField(CallNode54d2b0);
}

int DiePlayerHandlerCopiedCode()
{
    int arr[314], link;

    if (!link)
    {
        link = GetScrDataField(DiePlayerHandlerCopiedCode);
        OpcodeCopiesAdvance(link, CallNode54d2b0(), 0x54d2b0, 0x54d794);
    }
    return link;
}

void DiePlayerHandlerEntry(int plrUnit)  //@brief. 해당 유저를 재정의된 시스템에 등록합니다
{
    int ptr = UnitToPtr(plrUnit);

    if (ptr)
    {
        SetMemory(ptr + 0x2d4, DiePlayerHandlerCopiedCode());  //@brief. 플레이어 데스 재정의 핸들러 등록!
        SetMemory(ptr + 0x2e8, PlayerUpdate4f8100());       //@brief. 플레이어 업데이트 재정의 핸들러 등록!
    }
}

int Callnode4f8100()
{
    int node[20], link;

    if (!link)
    {
        node[0] = 0x4f8145;
        node[1] = 0x4f816e;
        node[2] = 0x4f81ad;
        node[3] = 0x4f820b;
        node[4] = 0x4f8218;
        node[5] = 0x4f8221;
        node[6] = 0x4f826b;
        node[7] = 0x4f8326;
        node[8] = 0x4f836e;
        node[9] = 0x4f8381;
        node[10] = 0x4f8387;
        node[11] = 0x4f838f;
        node[12] = 0x4f83a3;
        node[13] = 0x4f83ac;
        node[14] = 0x4f83c3;
        node[15] = 0x4f83dc;
        node[16] = 0x4f83eb;
        node[17] = 0x4f8407;
        node[18] = 0; //nullptr
        link = GetScrDataField(Callnode4f8100);
    }
    return link;
}

int PlayerUpdate4f8100()    //@brief. 유저 업데이트 복사본
{
    int codes[200], link;

    if (!link)
    {
        link = GetScrDataField(PlayerUpdate4f8100);
        OpcodeCopiesAdvance(link, Callnode4f8100(), 0x4f8100, 0x4f8414);
        FixCallOpcode(link + 0x287, PlayerUpdate4f8460());  //@brief. 4f8460으로 링크
    }
    return link;
}

int PlayerUpdate4f8460()
{
    int arr[75], link;

    if (!link)
    {
        arr[0] = 0x530CEC83; arr[1] = 0x748B5655; arr[2] = 0x31571C24; arr[3] = 0xECBE8BC0; arr[4] = 0x89000002; arr[5] = 0x89202444; arr[6] = 0x8A142444;
        arr[7] = 0xF8835847; arr[8] = 0x83427721; arr[9] = 0x077404F8; arr[10] = 0x8C8524FF; arr[11] = 0x8B004F99; arr[12] = 0x84EA0415; arr[13] = 0x88AE8B00;
        arr[14] = 0xA1000000; arr[15] = 0x0085B3FC; arr[16] = 0xE8D1EA29; arr[17] = 0x1776C239; arr[18] = 0x00040068; arr[19] = 0x4CDEE800; arr[20] = 0xC483F28D;
        arr[21] = 0x74C08504; arr[22] = 0x90806812; arr[23] = 0x68C3004F; arr[24] = 0x004F9983; arr[25] = 0x850B68C3; arr[26] = 0x68C3004F; arr[27] = 0x00002000;
        arr[28] = 0x8D4CBBE8; arr[29] = 0x04C483F2; arr[30] = 0x4A74C085; arr[31] = 0x0114878B; arr[32] = 0x80F60000; arr[33] = 0x00000E60; arr[34] = 0x313B7501;
        arr[35] = 0x10888AC9; arr[36] = 0x51000008; arr[37] = 0x9E5227E8; arr[38] = 0x04C483F2; arr[39] = 0x2674C085; arr[40] = 0x000006BB; arr[41] = 0x08583900;
        arr[42] = 0x978B3A74; arr[43] = 0x00000114; arr[44] = 0x8AC03150; arr[45] = 0x00081082; arr[46] = 0x71E85000; arr[47] = 0x83F29E52; arr[48] = 0xC08508C4;
        arr[49] = 0x95E8DF74; arr[50] = 0x85F28D4C; arr[51] = 0x560F74C0; arr[52] = 0x00011BE8; arr[53] = 0x04C48300; arr[54] = 0x4F850B68; arr[55] = 0x8368C300;
        arr[56] = 0xC3004F99; arr[57] = 0x01148F8B; arr[58] = 0xD2310000; arr[59] = 0x0810918A; arr[60] = 0xE8520000; arr[61] = 0xF29E52A8; arr[62] = 0x5604C483;
        arr[63] = 0x9C255FE8; arr[64] = 0x04C483F2; arr[65] = 0x4F850B68; arr[66] = 0x9090C300;
        link = GetScrDataField(PlayerUpdate4f8460);
        FixCallOpcode(link + 0x4d, 0x40a5c0);
        FixCallOpcode(link + 0x70, 0x40a5c0);
        FixCallOpcode(link + 0x94, 0x51ab50);
        FixCallOpcode(link + 0xba, 0x51abc0);
        FixCallOpcode(link + 0xc6, 0x40a5f0);
        // FixCallOpcode(link + 0xd0, 0x4f7ef0);       //@todo. 여기를 서브클래싱 해줘야 한다!
        FixCallOpcode(link + 0xd0, PlayerRespawn004f7ef0());       //@brief. 서브클래싱 링크
        FixCallOpcode(link + 0xf3, 0x51ac30);
        // FixCallOpcode(link + 0xfc, 0x4f7ef0);           //@brief. todo
        FixCallOpcode(link + 0xfc, PlayerRespawn004f7ef0());           //@brief. todo
    }
    return link;
}

int Callnode004f7ef0()
{
    int node[21], link;

    if (!link)
    {
        node[0] = 0x4f7ef7;
        node[1] = 0x4f7f1b;
        node[2] = 0x4f7f48;
        node[3] = 0x4f7f59;
        node[4] = 0x4f7f7c;
        node[5] = 0x4f7f8b;
        node[6] = 0x4f7f98;
        node[7] = 0x4f7fb5;
        node[8] = 0x4f7fd6;
        node[9] = 0x4f7ff1;
        node[10] = 0x4f800d;
        node[11] = 0x4f801a;
        node[12] = 0x4f8028;
        node[13] = 0x4f802f;
        node[14] = 0x4f803d;
        node[15] = 0x4f8055;
        node[16] = 0x4f807a;
        node[17] = 0x4f8087;
        node[18] = 0x4f80a1;
        node[19] = 0; //nullptr
        link = GetScrDataField(Callnode004f7ef0);
    }
    return link;
}

int PlayerRespawn004f7ef0()     //@brief. 유저 리스폰 복사본
{
    int codes[115], link;

    if (!link)
    {
        link = GetScrDataField(PlayerRespawn004f7ef0);
        OpcodeCopiesAdvance(link, Callnode004f7ef0(), 0x4f7ef0, 0x4f80b4);
        SetMemory(link + 0x62, 0x16a9090);
        SetMemory(link + 0x94, (GetMemory(link + 0x94) & (~0xffff)) ^ 0x9090);  //here  //원래 코멘트 처리
        FixCallOpcode(link + 0x9b, RedrawOnRespawn());      //here //원래 코멘트 처리
    }
    return link;
}

int RedrawOnRespawn()
{
    int arr[16], link;

    if (!link)
    {
        arr[0] = 0x50EC8B55; arr[1] = 0x758B5651; arr[2] = 0xF88E8B08; arr[3] = 0x85000001; arr[4] = 0x8B2674C9; arr[5] = 0x00251041; arr[6] = 0x85000001; arr[7] = 0x511274C0;
        arr[8] = 0x1F8AE856; arr[9] = 0x595EFFDA; arr[10] = 0x41E85651; arr[11] = 0x5EFFDA1F; arr[12] = 0xF0898B59; arr[13] = 0xEB000001; arr[14] = 0x58595ED6; arr[15] = 0x9090C35D;
        link = GetScrDataField(RedrawOnRespawn);
        FixCallOpcode(link + 0x21, 0x4f2fb0);
        FixCallOpcode(link + 0x2a, 0x4f2f70);
    }
    return link;
}

void CancelPlayerDialogWithPTR(int plrPtr)  //@brief. 재정의 된 TellStory 함수를 사용하지 않았다면 필요하지 않습니다
{
    if (GetMemory(GetMemory(plrPtr + 0x2ec) + 0x11c))
    {
        SetMemory(GetMemory(plrPtr + 0x2ec) + 0x11c, 0);
        SetMemory(GetMemory(GetMemory(plrPtr + 0x2ec) + 0x114) + 0xe60, 0x10);
    }
}

void SelfDamageClassMapExit()
{
    int i, pTable = 0x62f9e0, ptr;
    int link = GetScrDataField(SelfDamageClassMapExit);

    for (i = 31 ; i >= 0 ; Unused59(link, Unknownb9(link) - 1))
    {
        SetMemory(link + 8, GetMemory(pTable));
        if (ptr)
        {
            // SetMemory(ptr + 0x2cc, 0x4e17b0);
            SetMemory(ptr + 0x2d4, 0x54d2b0);
            if (GetMemory(ptr + 0x2e8) ^ 0x4E62F0)      //@brief. 관객모드가 아닐 경우에만 되돌립니다//
                SetMemory(GetMemory(pTable) + 0x2e8, 0x4f8100);     //@brief. 업데이트 되돌리기//
            CancelPlayerDialogWithPTR(GetMemory(pTable));
        }
        Unused59(link + 4, Unknownb9(link + 4) + 0x12dc);
    }
}

