//@ignore_object_type

int player[20];
int g_dropItemFunctions[8];
object g_userLastSavedLocation;

object g_blockLeftUp;
object g_blockLeftDown;
object g_blockRightLeft;
object g_blockRightRight;

int g_mixGenPuzzle[10];
object g_genPuzzleBeacon[9];
int g_puzzleGens = 0;

object g_ternnelSwitch;

int EnableMemoryReadWriteFunction(int t) { }
float ToFloat(int arg) { StopScript(arg); }
int ToInt(float arg) { StopScript(arg); }
string ToStr(int arg) { StopScript(arg); }
int SToInt(string arg) { StopScript(arg); }
int GetMemory(int addr) { return Unknownb9(addr); }
float GetMemoryFloat(int addr) { StopScript(Unknownb9(addr)); }
void SetMemory(int addr, int value) { Unused59(addr, value); }

int FixCallOpcode(int curAddr, int targetAddr)
{
    SetMemory(curAddr + 1, targetAddr - curAddr - 5);
}

int OpcodeGetTargetAddr(int curAddr)
{
    return GetMemory(curAddr + 1) + curAddr + 5;
}

void OpcodeLoadEffectiveAddr(int loadAddr, int codeAddr, int offset)
{
    int targetAddr = OpcodeGetTargetAddr(codeAddr + offset);

    SetMemory(loadAddr + offset + 1, targetAddr - (loadAddr + offset) - 5);
}

void OpcodeCopiesAdvance(int destPtr, int callNodePtr, int startAddr, int endAddr)
{
    int destBase = destPtr, curAddr = startAddr;
    int vptr = GetScrDataField(OpcodeCopiesAdvance);

    while (curAddr <= endAddr)
    {
        Unused59(destPtr, Unknownb9(curAddr));
        if (Unknownb9(callNodePtr))
        {
            if (Unknownb9(callNodePtr) + 1 <= curAddr)
            {
                OpcodeLoadEffectiveAddr(destBase, startAddr, Unknownb9(callNodePtr) - startAddr);
                Unused59(vptr + 4, Unknownb9(vptr + 4) + 4);
            }
        }
        Unused59(vptr + 0x14, Unknownb9(vptr + 0x14) + 4);
        Unused59(vptr, Unknownb9(vptr) + 4);
    }
}

int GetScrDataField(int functionName)
{
    return GetMemory(GetMemory(0x75ae28) + (0x30 * functionName + 0x1c));
}

int GetScrCodeField(int functionName)
{
    return GetMemory(GetMemory(0x75ae28) + (0x30 * functionName + 0x20));
}

void SetUnitFlags(int unit, int flag)
{
	int ptr = UnitToPtr(unit);

    if (ptr)
        SetMemory(ptr + 0x10, flag);
}

int GetUnitFlags(int unit)
{
	int ptr = UnitToPtr(unit);

    if (ptr)
        return GetMemory(ptr + 0x10);
    return 0;
}

void UnitNoCollide(int unit)
{
    SetUnitFlags(unit, GetUnitFlags(unit) ^ 0x40);
}

int GetUnitThingID(int unit)
{
    int ptr = UnitToPtr(unit);
    if (ptr)
        return GetMemory(ptr + 0x04);
    return 0;
}

void SetUnitSpeed(int unit, float amount)
{
    int ptr = UnitToPtr(unit);

    if (ptr)
        SetMemory(ptr + 0x224, ToInt(amount));
}

void SetUnitMass(int unit, float ms)
{
    int ptr = UnitToPtr(unit);

    if (ptr)
        SetMemory(ptr + 0x78, ToInt(ms));
}

int GetUnitStatus(int unit)
{
    int temp, ptr = UnitToPtr(unit);

    if (ptr)
    {
        temp = GetMemory(ptr + 0x2ec);
        if (temp)
            return GetMemory(temp + 0x5a0);
    }
    return 0;
}

void SetUnitStatus(int unit, int stat)
{
    int temp, ptr = UnitToPtr(unit);

    if (ptr)
    {
        temp = GetMemory(ptr + 0x2ec);
        if (temp)
            SetMemory(temp + 0x5a0, stat);
    }
}

void SetUnitMaxHealth(int unit, int amount)
{
    int ptr = UnitToPtr(unit);
    if (ptr)
    {
        SetMemory(GetMemory(ptr + 0x22c), amount);
        SetMemory(GetMemory(ptr + 0x22c) + 0x4, amount);
    }
}

void UnitZeroFleeRange(int unit)
{
    int ptr = UnitToPtr(unit);

    if (ptr)
        SetMemory(GetMemory(ptr + 0x2ec) + 0x54c, 0); //Flee Range set to 0
}

void SetUnitVoice(int unit, int voiceIndex)
{
    int ptr = UnitToPtr(unit);

    if (ptr)
        SetMemory(GetMemory(ptr + 0x2ec) + 0x1e8, VoiceList(voiceIndex));
}

void UnitLinkBinScript(int unit, int binScrAddr)
{
    int ptr = UnitToPtr(unit);

    if (ptr)
        SetMemory(GetMemory(ptr + 0x2ec) + 0x1e4, binScrAddr);
}

int VoiceList(int num)
{
    int list[75], addr, k;

    if (!list[0])
    {
        addr = GetMemory(0x663eec);
        for (k = 0 ; k < 75 ; k ++)
        {
            list[k] = addr;
            addr = GetMemory(addr + 0x4c);
        }
    }
    return list[num];
}

int ImportGetSpellNumber()
{
	int arr[11], link;

	if (!link)
	{
		arr[0] = 0x50725068; arr[1] = 0x2414FF00; arr[2] = 0x4085048B; arr[3] = 0x680097BB; arr[4] = 0x004243F0; arr[5] = 0x2454FF50;
		arr[6] = 0x08C48304; arr[7] = 0x50723068; arr[8] = 0x54FF5000; arr[9] = 0xC4830424; arr[10] = 0xC3C0310C;
        link = GetScrDataField(ImportGetSpellNumber);
	}
	return link;
}

int GetSpellNumber(string spell)
{
	int temp = GetMemory(0x5c3204), res;

	SetMemory(0x5c3204, ImportGetSpellNumber());
	res = Unused5e(spell);
	SetMemory(0x5c3204, temp);
	return res * 4;
}

int GetUnit1C(int sUnit)
{
    int ptr = UnitToPtr(sUnit);

    if (ptr)
        return GetMemory(ptr + 0x1c);
    return 0;
}

void SetUnit1C(int sUnit, int sData)
{
    int ptr = UnitToPtr(sUnit);

    if (ptr)
        SetMemory(ptr + 0x1c, sData);
}

int IsPlayerUnit(int checkUnit)
{
    int ptr = UnitToPtr(checkUnit);

    if (ptr)
        return GetMemory(ptr + 0x08) & 4;
    return false;
}

int IsMonsterUnit(int checkUnit)
{
    int ptr = UnitToPtr(checkUnit);

    if (ptr)
        return GetMemory(ptr + 0x08) & 2;
    return false;
}

float DistanceUnitToUnit(int unit1, int unit2)
{
    int ptr1 = UnitToPtr(unit1);
    int ptr2 = UnitToPtr(unit2);

    if (ptr1 && ptr2)
        return Distance(GetMemoryFloat(ptr1 + 0x38), GetMemoryFloat(ptr1 + 0x3c), GetMemoryFloat(ptr2 + 0x38), GetMemoryFloat(ptr2 + 0x3c));
    return 0.0;
}

int GetOwner(int unit)
{
    int ptr = UnitToPtr(unit), res;

    if (ptr)
    {
        res = GetMemory(ptr + 0x1fc);
        if (res)
            return GetMemory(res + 0x2c);
    }
    return 0;
}

void InitializeDungeonDropItemFunctions()
{
    g_dropItemFunctions[1] = RewardClassDropPotion;
    g_dropItemFunctions[2] = MoneyDrop;
    g_dropItemFunctions[3] = NormalWeaponItemDrop;
    g_dropItemFunctions[4] = NormalArmorItemDrop;
    g_dropItemFunctions[5] = WeaponItemDrop;
    g_dropItemFunctions[6] = ArmorItemDrop;
    g_dropItemFunctions[7] = RewardClassDropHotPotion;
    g_dropItemFunctions[0] = 7;
}

void MapInitialize()
{
    int v0 = EnableMemoryReadWriteFunction(0);

    MusicEvent();
    ImportUnitToPtrFunc();
    ImportPlaySoundAround();
    ImportCheckSelfDamage();
    // ImportUniBroadcast();
    ImportUniChatCore();
    ImportUniPrintCore();
    ImportUnitCollideFunc();
    CallFunctionWithArgInt(0, 0);
    MapWaypointInit();

    int ptr = DiePlayerHandlerCopiedCode();
    ChangePlayerDeathSound(ptr, 913);
    PlayerUpdate4f8100();
    SetMemory(ptr + 0x386, (GetMemory(ptr + 0x386) & 0xffff0000) | 0x9eb);
    MathSine(1, 1.0 / 57.3);

    ImportCreateAtFunc();
    ImportAllowAllDrop();
    InitInvPropertiesSet();
    VoiceList(0);
    FrameTimer(3, InitializeDungeonDropItemFunctions);
    FrameTimer(3, MakeCoopTeam);
    FrameTimer(10, PlayerClassOnLoop);
    FrameTimer(30, DelayMapInit);
}

void MapExit()
{
    MusicEvent();
    RemoveCoopTeamMode();
    SelfDamageClassMapExit();
    ResetHostileCritter();
}

int ImportUnitToPtrFunc()
{
    int arr[10], link;
    if (!link)
    {
        arr[0] = 0x50725068; arr[1] = 0x2414FF00; arr[2] = 0x511B6068; arr[3] = 0x54FF5000; arr[4] = 0xC4830424;
        arr[5] = 0x7230680C; arr[6] = 0xFF500050; arr[7] = 0x83042454; arr[8] = 0xC03108C4; arr[9] = 0x909090C3; 
        link = GetScrDataField(ImportUnitToPtrFunc);
    }
    return link;
}

int UnitToPtr(int unit)
{
    int temp = GetMemory(0x5c336c), res;
    SetMemory(0x5c336c, ImportUnitToPtrFunc());
    res = Unknownb8(unit);
    SetMemory(0x5c336c, temp);
	return res;
}

int ImportCreateAtFunc()
{
    int arr[20], link;

    if (!link)
    {
        arr[0] = 0xAA506856; arr[1] = 0x5068004D; arr[2] = 0xFF005072; arr[3] = 0xFF502414; arr[4] = 0x50042454;
        arr[5] = 0x082454FF; arr[6] = 0x4085048B; arr[7] = 0x680097BB; arr[8] = 0x004E3810; arr[9] = 0x2454FF50;
        arr[10] = 0x08C48304; arr[11] = 0xF685F08B; arr[12] = 0x006A0A74; arr[13] = 0x2454FF56; arr[14] = 0x08C48314;
        arr[15] = 0x50723068; arr[16] = 0x54FF5600; arr[17] = 0xC4830424; arr[18] = 0x5EC03118; arr[19] = 0x909090C3;
        link = GetScrDataField(ImportCreateAtFunc);
    }
    return link;
}

int CreateObjectAt(string name, float x, float y)
{
    int temp = GetMemory(0x5c3160), res;

    SetMemory(0x5c3160, ImportCreateAtFunc());
    res = CreateMover(SToInt(name), ToInt(x), y);
    SetMemory(0x5c3160, temp);
    if (res) return GetMemory(res + 0x2c);
    else return 0;
}

int CreateObjectAtUnit(string name, int sUnit)
{
    int temp = GetMemory(0x5c3320), ptr = UnitToPtr(sUnit);
    
    if (!ptr)
        return 0;

    SetMemory(0x5c3320, ImportCreateAtFunc());
    GroupRunAway(SToInt(name), GetMemory(ptr + 0x38), GetMemory(ptr + 0x3c));
    SetMemory(0x5c3320, temp);
    if (GetMemory(0x750710)) return GetMemory(GetMemory(0x750710) + 0x2c);
    return 0;
}

int ImportTellStoryUniNamePartB()
{
    int arr[84], link;

    if (!link)
    {
        arr[0] = 0x0424448B; arr[1] = 0x0824548B; arr[2] = 0x008CEC81; arr[3] = 0xC0850000; arr[4] = 0xEC9A8B53; arr[5] = 0x55000002; arr[6] = 0x02ECA88B;
        arr[7] = 0x0F570000; arr[8] = 0x00012184; arr[9] = 0x0840F600; arr[10] = 0x17840F04; arr[11] = 0x8B000001; arr[12] = 0x00A824BC; arr[13] = 0xFF850000;
        arr[14] = 0x0108840F; arr[15] = 0xC9830000; arr[16] = 0x89C033FF; arr[17] = 0x00011C95; arr[18] = 0xAEF25600; arr[19] = 0x748DD1F7; arr[20] = 0xF92B1624;
        arr[21] = 0x7489C18B; arr[22] = 0xF78B1024; arr[23] = 0x10247C8B; arr[24] = 0xC602E9C1; arr[25] = 0xD0142444; arr[26] = 0x152444C6; arr[27] = 0x8BA5F303;
        arr[28] = 0x5CC868C8; arr[29] = 0x1F6A0056; arr[30] = 0xF303E183; arr[31] = 0xC9C8B8A4; arr[32] = 0x4C8D0069; arr[33] = 0x51503E24; arr[34] = 0x0C2454FF;
        arr[35] = 0xB824848B; arr[36] = 0x66000000; arr[37] = 0x842484C7; arr[38] = 0x00000000; arr[39] = 0x38938A00; arr[40] = 0x8D000008; arr[41] = 0x00083ABB;
        arr[42] = 0x24948800; arr[43] = 0x000000AA; arr[44] = 0x86248489; arr[45] = 0x8A000000; arr[46] = 0x10C48307; arr[47] = 0x2374C084; arr[48] = 0x31FFC983;
        arr[49] = 0xF7AEF2C0; arr[50] = 0x8DCF29D1; arr[51] = 0x8B7A2454; arr[52] = 0x8BF78BC1; arr[53] = 0x02E9C1FA; arr[54] = 0xC88BA5F3; arr[55] = 0xF303E183;
        arr[56] = 0x8B2FEBA4; arr[57] = 0x5CD1640D; arr[58] = 0x68158B00; arr[59] = 0xA1005CD1; arr[60] = 0x005CD16C; arr[61] = 0x7A244C89; arr[62] = 0x700D8B66;
        arr[63] = 0x89005CD1; arr[64] = 0x897E2454; arr[65] = 0x00822484; arr[66] = 0x89660000; arr[67] = 0x0086248C; arr[68] = 0x858B0000; arr[69] = 0x00000114;
        arr[70] = 0x4E542068; arr[71] = 0x31016A00; arr[72] = 0x8A006AC9; arr[73] = 0x00081088; arr[74] = 0x24548D00; arr[75] = 0x00876820; arr[76] = 0x51520000;
        arr[77] = 0x142454FF; arr[78] = 0xB424948B; arr[79] = 0x6A000000; arr[80] = 0xC4835200; arr[81] = 0x5D5F5E20; arr[82] = 0x8CC4815B; arr[83] = 0xC3000000;
		link = GetScrDataField(ImportTellStoryUniNamePartB);
    }
    return link;
}

int ImportTellStoryUniNamePartA()
{
    int arr[19], link;

    if (!link)
    {
        arr[0] = 0x8DE06856; arr[1] = 0x50680054; arr[2] = 0xFF005072; arr[3] = 0xF08B2414; arr[4] = 0x8B2414FF; 
        arr[5] = 0xBB40B50C; arr[6] = 0x148B0097; arr[7] = 0x97BB4085; arr[8] = 0x50685100; arr[9] = 0x520040AF; 
        arr[10] = 0x042454FF; arr[11] = 0x97200D8B; arr[12] = 0xC4830097; arr[13] = 0x24A15008; arr[14] = 0x50009797; 
        arr[15] = 0x2454FF51; arr[16] = 0x10C48314; arr[17] = 0xC483C031; arr[18] = 0x90C35E08;
		link = GetScrDataField(ImportTellStoryUniNamePartA);
        SetMemory(link + 2, ImportTellStoryUniNamePartB());
    }
    return link;
}

void TellStoryUnitName(string sAudio, string sDesc, string sUnitName)
{
    int temp = GetMemory(0x5c3290), src = GetMemory(0x97bb40 + (SToInt(sUnitName) * 4));

    SetMemory(0x5c3290, ImportTellStoryUniNamePartA());
    NoxUtf8ToUnicode(src, 0x69C9C8);
    TellStory(sAudio, sDesc);
    SetMemory(0x5c3290, temp);
}

int CheckPlayer()
{
    int i;

    for (i = 9 ; i >= 0 ; i--)
    {
        if (IsCaller(player[i]))
            return i;
    }
    return -1;
}

void PlayerAllEnchantment(int plrUnit)
{
    if (CurrentHealth(plrUnit))
    {
        Enchant(plrUnit, EnchantList(13), 0.0);
        Enchant(plrUnit, EnchantList(17), 0.0);
        Enchant(plrUnit, EnchantList(18), 0.0);
        Enchant(plrUnit, EnchantList(20), 0.0);
        Enchant(plrUnit, EnchantList(27), 0.0);
    }
}

int PlayerClassOnInit(int plr, int plrUnit)
{
    int pResult = plr;

    player[plr] = plrUnit;
    player[plr + 10] = 1;
    ChangeGold(plrUnit, -GetGold(plrUnit));
    SelfDamageClassEntry(plrUnit);
    DiePlayerHandlerEntry(plrUnit);

    return pResult;
}

void PlayerClassOnJoin(int plr, int plrUnit)
{
    if (PlayerClassCheckAllEnchant(plr))
        PlayerAllEnchantment(plrUnit);
    MoveObject(plrUnit, LocationX(12), LocationY(12));
    PlaySoundAround(plrUnit, 1008);
}

void PlayerClassFailToJoin()
{
    MoveObject(other, LocationX(11), LocationY(11));
}

void RegistNewPlayer()
{
    int i, plr;

    while (true)
    {
        if (CurrentHealth(other))
        {
            plr = CheckPlayer();
            for (i = 9 ; i >= 0 && plr < 0 ; i --)
            {
                if (!MaxHealth(player[i]))
                {
                    plr = PlayerClassOnInit(i, GetCaller());
                    break;
                }
            }
            if (plr >= 0)
            {
                PlayerClassOnJoin(plr, other);
                break;
            }
        }
        PlayerClassFailToJoin();
        break;
    }
}

void PlayerClassFastJoin()
{
    if (CurrentHealth(other))
    {
        int plr = CheckPlayer();
        if (plr < 0)
            MoveObject(other, LocationX(14), LocationY(14));
        else
        {
            MoveObject(other, LocationX(13), LocationY(13));
            UniPrint(other, "패스트 조인되었습니다");
        }
    }
}

void PlayerClassProc(int plr)
{
    int plrUnit = player[plr];

    if (UnitCheckEnchant(plrUnit, GetLShift(31)))
    {
        EnchantOff(plrUnit, EnchantList(31));
        WindBooster(plrUnit);
    }
}

int PlayerClassCheckDeathFlag(int plr)
{
    return player[plr + 10] & 0x80;
}

void PlayerClassSetDeathFlag(int plr)
{
    player[plr + 10] = player[plr + 10] ^ 0x80;
}

void PlayerClassSetAllEnchant(int plr)
{
    player[plr + 10] = player[plr + 10] ^ 2;
}

int PlayerClassCheckAllEnchant(int plr)
{
    return player[plr + 10] & 2;
}

void PlayerClassOnDeath(int plr)
{
    UniPrintToAll(PlayerIngameNick(player[plr]) + " 님께서 적에게 격추되었습니다");
}

void PlayerClassOnExit(int plr)
{
    player[plr] = 0;
    player[plr + 10] = 0;
}

void PlayerClassOnLoop()
{
    int i;

    for (i = 9 ; i >= 0 ; i --)
    {
        while (true)
        {
            if (MaxHealth(player[i]))
            {
                if (GetUnitFlags(player[i]) & 0x40)
                    1;
                else if (CurrentHealth(player[i]))
                {
                    PlayerClassProc(i);
                    break;
                }
                else
                {
                    if (PlayerClassCheckDeathFlag(i))
                        break;
                    else
                    {
                        PlayerClassSetDeathFlag(i);
                        PlayerClassOnDeath(i);
                    }
                    break;
                }
            }
            if (player[i + 10])
                PlayerClassOnExit(i);
            break;
        }
    }
    FrameTimer(1, PlayerClassOnLoop);
}

int ImportPlayerAutoTeamSign()
{
    int arr[17], link;

    if (!link)
    {
        arr[0] = 0x4191D068; arr[1] = 0x50515600; arr[2] = 0x000020B9; arr[3] = 0xF9E0B800; arr[4] = 0xC9850062;
        arr[5] = 0x8B492774; arr[6] = 0x12DC0530; arr[7] = 0xF6850000; arr[8] = 0x5150F074; arr[9] = 0x8D24468B;
        arr[10] = 0x016A304E; arr[11] = 0x51016A50; arr[12] = 0x54FF016A; arr[13] = 0xC4832824; arr[14] = 0xEB585914;
        arr[15] = 0x5E5958D5; arr[16] = 0xC304C483;
        link = GetScrDataField(ImportPlayerAutoTeamSign);
    }
    return link;
}

void PlayerAutoTeamSign()
{
    int temp = GetMemory(0x5c31cc);

    SetMemory(0x5c31cc, ImportPlayerAutoTeamSign());
    Unused50();
    SetMemory(0x5c31cc, temp);
}

void MakeCoopTeam()
{
    int arr[3];
    int teamCount = GetMemory(0x654D5C), temp, link;

    if (!teamCount && !link)
    {
        arr[0] = 0x417E1068; arr[1] = 0x2414FF00; arr[2] = 0xC304C483;
        link = GetScrDataField(MakeCoopTeam);
        temp = GetMemory(0x5c31cc);
        SetMemory(0x5c31cc, link);
        Unused50();
        SetMemory(0x5c31cc, temp);
        SetMemory(0x5d53a4, 268640519);
    }
}

void RemoveCoopTeamMode()
{
    int arr[6], link, temp;

    if (!link && GetMemory(0x654d5c) == 1)
    {
        arr[0] = 0x4DB8BE56; arr[1] = 0x20680065; arr[2] = 0x6A00418F; arr[3] = 0x54FF5600; arr[4] = 0xC4830824; arr[5] = 0x90C35E0C;
        link = GetScrDataField(RemoveCoopTeamMode);
        temp = GetMemory(0x5c31cc);
        SetMemory(0x5c31cc, link);
        Unused50();
        SetMemory(0x5c31cc, temp);
    }
}

void SetGameTypeCoopMode()
{
    MakeCoopTeam();
    PlayerAutoTeamSign();
}

void CancelPlayerDialogWithPTR(int plrPtr)
{
    if (GetMemory(GetMemory(plrPtr + 0x2ec) + 0x11c))
    {
        SetMemory(GetMemory(plrPtr + 0x2ec) + 0x11c, 0);
        SetMemory(GetMemory(GetMemory(plrPtr + 0x2ec) + 0x114) + 0xe60, 0x10);
    }
}

int ImportCheckSelfDamage()
{
    int arr[14], link;

    if (!link)
    {
        arr[0] = 0x4C8B5651; arr[1] = 0xC9850C24; arr[2] = 0x748B2374; arr[3] = 0xF6851024; arr[4] = 0xF1391B74; arr[5] = 0x8B501374; arr[6] = 0x0001FC86;
        arr[7] = 0x74C08500; arr[8] = 0x58F08B05; arr[9] = 0xEB58ECEB; arr[10] = 0xC3595E04; arr[11] = 0x68595E90; arr[12] = 0x004E17B0; arr[13] = 0x909090C3;
        link = GetScrDataField(ImportCheckSelfDamage);
    }
    return link;
}

void SelfDamageClassEntry(int plrUnit)
{
    int ptr = UnitToPtr(plrUnit);

    if (ptr)
        SetMemory(ptr + 0x2cc, ImportCheckSelfDamage());
}

void SelfDamageClassMapExit()
{
    int i, pTable = 0x62f9e0, ptr;
    int link = GetScrDataField(SelfDamageClassMapExit);

    for (i = 31 ; i >= 0 ; Unused59(link, Unknownb9(link) - 1))
    {
        SetMemory(link + 8, GetMemory(pTable));
        if (ptr)
        {
            SetMemory(ptr + 0x2cc, 0x4e17b0);
            SetMemory(ptr + 0x2d4, 0x54d2b0);
            if (GetMemory(ptr + 0x2e8) ^ 0x4E62F0)      //@brief. 관객모드가 아닐 경우에만 되돌립니다//
                SetMemory(GetMemory(pTable) + 0x2e8, 0x4f8100);     //@brief. 업데이트 되돌리기//
            CancelPlayerDialogWithPTR(GetMemory(pTable));
        }
        Unused59(link + 4, Unknownb9(link + 4) + 0x12dc);
    }
}

void ChangePlayerDeathSound(int handle, int soundNumber) //@brief. 유저가 죽었을 때 효과음을 변경합니다
{
    SetMemory(handle + 0x258, soundNumber);  //@brief. SoundList.txt 파일을 참고하세요
}

int CallNode54d2b0()
{
    int arr[40];

    if (!arr[0])
    {
        arr[0] = 0x54d2d1;
        arr[1] = 0x54d2e3;
        arr[2] = 0x54d2f3;
        arr[3] = 0x54d30a;
        arr[4] = 0x54d348;
        arr[5] = 0x54d375;
        arr[6] = 0x54d3aa;
        arr[7] = 0x54d45c;
        arr[8] = 0x54d47b;
        arr[9] = 0x54d513;
        arr[10] = 0x54d527;
        arr[11] = 0x54d566;
        arr[12] = 0x54d574;
        arr[13] = 0x54d588;
        arr[14] = 0x54d594;
        arr[15] = 0x54d5a6;
        arr[16] = 0x54d5b2;
        arr[17] = 0x54d5c4;
        arr[18] = 0x54d5d1;
        arr[19] = 0x54d5e2;
        arr[20] = 0x54d5f4;
        arr[21] = 0x54d610;
        arr[22] = 0x54d622;
        arr[23] = 0x54d62c;
        arr[24] = 0x54d639;
        arr[25] = 0x54d642;
        arr[26] = 0x54d65b;
        arr[27] = 0x54d662;
        arr[28] = 0x54d668;
        arr[29] = 0x54d67a;
        arr[30] = 0x54d680;
        arr[31] = 0x54d693;
        arr[32] = 0x54d6a6;
        arr[33] = 0x54d727;
        arr[34] = 0x54d72d;
        arr[35] = 0x54d733;
        arr[36] = 0x54d73d;
        arr[37] = 0x54d749;
        arr[38] = 0x54d782;
    }
    return GetScrDataField(CallNode54d2b0);
}

int DiePlayerHandlerCopiedCode()
{
    int arr[314], link;

    if (!link)
    {
        link = GetScrDataField(DiePlayerHandlerCopiedCode);
        OpcodeCopiesAdvance(link, CallNode54d2b0(), 0x54d2b0, 0x54d794);
    }
    return link;
}

void DiePlayerHandlerEntry(int plrUnit)  //@brief. 해당 유저를 재정의된 시스템에 등록합니다
{
    int ptr = UnitToPtr(plrUnit);

    if (ptr)
    {
        SetMemory(ptr + 0x2d4, DiePlayerHandlerCopiedCode());  //@brief. 플레이어 데스 재정의 핸들러 등록!
        SetMemory(ptr + 0x2e8, PlayerUpdate4f8100());       //@brief. 플레이어 업데이트 재정의 핸들러 등록!
    }
}

int Callnode4f8100()
{
    int node[20], link;

    if (!link)
    {
        node[0] = 0x4f8145;
        node[1] = 0x4f816e;
        node[2] = 0x4f81ad;
        node[3] = 0x4f820b;
        node[4] = 0x4f8218;
        node[5] = 0x4f8221;
        node[6] = 0x4f826b;
        node[7] = 0x4f8326;
        node[8] = 0x4f836e;
        node[9] = 0x4f8381;
        node[10] = 0x4f8387;
        node[11] = 0x4f838f;
        node[12] = 0x4f83a3;
        node[13] = 0x4f83ac;
        node[14] = 0x4f83c3;
        node[15] = 0x4f83dc;
        node[16] = 0x4f83eb;
        node[17] = 0x4f8407;
        node[18] = 0; //nullptr
        link = GetScrDataField(Callnode4f8100);
    }
    return link;
}

int PlayerUpdate4f8100()    //@brief. 유저 업데이트 복사본
{
    int codes[200], link;

    if (!link)
    {
        link = GetScrDataField(PlayerUpdate4f8100);
        OpcodeCopiesAdvance(link, Callnode4f8100(), 0x4f8100, 0x4f8414);
        FixCallOpcode(link + 0x287, PlayerUpdate4f8460());  //@brief. 4f8460으로 링크
    }
    return link;
}

int PlayerUpdate4f8460()
{
    int arr[75], link;

    if (!link)
    {
        arr[0] = 0x530CEC83; arr[1] = 0x748B5655; arr[2] = 0x31571C24; arr[3] = 0xECBE8BC0; arr[4] = 0x89000002; arr[5] = 0x89202444; arr[6] = 0x8A142444;
        arr[7] = 0xF8835847; arr[8] = 0x83427721; arr[9] = 0x077404F8; arr[10] = 0x8C8524FF; arr[11] = 0x8B004F99; arr[12] = 0x84EA0415; arr[13] = 0x88AE8B00;
        arr[14] = 0xA1000000; arr[15] = 0x0085B3FC; arr[16] = 0xE8D1EA29; arr[17] = 0x1776C239; arr[18] = 0x00040068; arr[19] = 0x4CDEE800; arr[20] = 0xC483F28D;
        arr[21] = 0x74C08504; arr[22] = 0x90806812; arr[23] = 0x68C3004F; arr[24] = 0x004F9983; arr[25] = 0x850B68C3; arr[26] = 0x68C3004F; arr[27] = 0x00002000;
        arr[28] = 0x8D4CBBE8; arr[29] = 0x04C483F2; arr[30] = 0x4A74C085; arr[31] = 0x0114878B; arr[32] = 0x80F60000; arr[33] = 0x00000E60; arr[34] = 0x313B7501;
        arr[35] = 0x10888AC9; arr[36] = 0x51000008; arr[37] = 0x9E5227E8; arr[38] = 0x04C483F2; arr[39] = 0x2674C085; arr[40] = 0x000006BB; arr[41] = 0x08583900;
        arr[42] = 0x978B3A74; arr[43] = 0x00000114; arr[44] = 0x8AC03150; arr[45] = 0x00081082; arr[46] = 0x71E85000; arr[47] = 0x83F29E52; arr[48] = 0xC08508C4;
        arr[49] = 0x95E8DF74; arr[50] = 0x85F28D4C; arr[51] = 0x560F74C0; arr[52] = 0x00011BE8; arr[53] = 0x04C48300; arr[54] = 0x4F850B68; arr[55] = 0x8368C300;
        arr[56] = 0xC3004F99; arr[57] = 0x01148F8B; arr[58] = 0xD2310000; arr[59] = 0x0810918A; arr[60] = 0xE8520000; arr[61] = 0xF29E52A8; arr[62] = 0x5604C483;
        arr[63] = 0x9C255FE8; arr[64] = 0x04C483F2; arr[65] = 0x4F850B68; arr[66] = 0x9090C300;
        link = GetScrDataField(PlayerUpdate4f8460);
        FixCallOpcode(link + 0x4d, 0x40a5c0);
        FixCallOpcode(link + 0x70, 0x40a5c0);
        FixCallOpcode(link + 0x94, 0x51ab50);
        FixCallOpcode(link + 0xba, 0x51abc0);
        FixCallOpcode(link + 0xc6, 0x40a5f0);
        // FixCallOpcode(link + 0xd0, 0x4f7ef0);       //@todo. 여기를 서브클래싱 해줘야 한다!
        FixCallOpcode(link + 0xd0, PlayerRespawn004f7ef0());       //@brief. 서브클래싱 링크
        FixCallOpcode(link + 0xf3, 0x51ac30);
        // FixCallOpcode(link + 0xfc, 0x4f7ef0);           //@brief. todo
        FixCallOpcode(link + 0xfc, PlayerRespawn004f7ef0());           //@brief. todo
    }
    return link;
}

int Callnode004f7ef0()
{
    int node[21], link;

    if (!link)
    {
        node[0] = 0x4f7ef7;
        node[1] = 0x4f7f1b;
        node[2] = 0x4f7f48;
        node[3] = 0x4f7f59;
        node[4] = 0x4f7f7c;
        node[5] = 0x4f7f8b;
        node[6] = 0x4f7f98;
        node[7] = 0x4f7fb5;
        node[8] = 0x4f7fd6;
        node[9] = 0x4f7ff1;
        node[10] = 0x4f800d;
        node[11] = 0x4f801a;
        node[12] = 0x4f8028;
        node[13] = 0x4f802f;
        node[14] = 0x4f803d;
        node[15] = 0x4f8055;
        node[16] = 0x4f807a;
        node[17] = 0x4f8087;
        node[18] = 0x4f80a1;
        node[19] = 0; //nullptr
        link = GetScrDataField(Callnode004f7ef0);
    }
    return link;
}

int PlayerRespawn004f7ef0()     //@brief. 유저 리스폰 복사본
{
    int codes[115], link;

    if (!link)
    {
        link = GetScrDataField(PlayerRespawn004f7ef0);
        OpcodeCopiesAdvance(link, Callnode004f7ef0(), 0x4f7ef0, 0x4f80b4);
        SetMemory(link + 0x62, 0x16a9090);
        SetMemory(link + 0x94, (GetMemory(link + 0x94) & (~0xffff)) ^ 0x9090);
        FixCallOpcode(link + 0x9b, RedrawOnRespawn());
    }
    return link;
}

int RedrawOnRespawn()
{
    int arr[16], link;

    if (!link)
    {
        arr[0] = 0x50EC8B55; arr[1] = 0x758B5651; arr[2] = 0xF88E8B08; arr[3] = 0x85000001; arr[4] = 0x8B2674C9; arr[5] = 0x00251041; arr[6] = 0x85000001; arr[7] = 0x511274C0;
        arr[8] = 0x1F8AE856; arr[9] = 0x595EFFDA; arr[10] = 0x41E85651; arr[11] = 0x5EFFDA1F; arr[12] = 0xF0898B59; arr[13] = 0xEB000001; arr[14] = 0x58595ED6; arr[15] = 0x9090C35D;
        link = GetScrDataField(RedrawOnRespawn);
        FixCallOpcode(link + 0x21, 0x4f2fb0);
        FixCallOpcode(link + 0x2a, 0x4f2f70);
    }
    return link;
}

int MapWaypointTable(int idx)
{
    int table[600];

    return table[idx - 1];
}

float LocationX(int location)
{
    StopScript(GetMemory(MapWaypointTable(location) + 8));
}

float LocationY(int location)
{
    StopScript(GetMemory(MapWaypointTable(location) + 12));
}

void TeleportLocation(int location, float xProfile, float yProfile)
{
    int wTable = MapWaypointTable(location);

    SetMemory(wTable + 8, ToInt(xProfile));
    SetMemory(wTable + 12, ToInt(yProfile));
}

void TeleportLocationVector(int location, float xVect, float yVect)
{
    int wTable = MapWaypointTable(location);

    SetMemory(wTable + 8, ToInt(ToFloat(GetMemory(wTable + 8)) + xVect));
    SetMemory(wTable + 12, ToInt(ToFloat(GetMemory(wTable + 12)) + yVect));
}

void MapWaypointFill(int wAddr, int tPtr)
{
    int num;

    if (wAddr)
    {
        num = GetMemory(wAddr);
        SetMemory(tPtr + (num * 4), wAddr);
        MapWaypointFill(GetMemory(wAddr + 484), tPtr);
    }
}

void MapWaypointInit()
{
    MapWaypointFill(GetMemory(0x83c7fc), GetScrDataField(MapWaypointTable));
}

void ClearWallAtWaypointPos(int sLocation)
{
    int xPos = FloatToInt(LocationX(sLocation)), yPos = FloatToInt(LocationY(sLocation));
    int spX, spY, tx, ty, rx;

    if (xPos > yPos) xPos += 23;
    else             yPos += 23;
    spX = (xPos + yPos - 22) / 46;
    spY = (xPos - yPos) / 46;
    tx = spX * 46;
    ty = spY * 46;
    rx = (tx + ty) / 2;
    WallOpen(Wall(rx / 23, (rx - ty) / 23));
}

int ImportPlaySoundAround()
{
	int arr[17], link;

	if (!link)
	{
		arr[0] = 0x50196068; arr[1] = 0x72506800; arr[2] = 0x50560050; arr[3] = 0x082454FF;
		arr[4] = 0x54FFF08B; arr[5] = 0x006A0824; arr[6] = 0x5650006A; arr[7] = 0x1C2454FF;
		arr[8] = 0x5810C483; arr[9] = 0x08C4835E; arr[10] = 0x909090C3;
        link = GetScrDataField(ImportPlaySoundAround);
	}
	return link;
}

void PlaySoundAround(int sUnit, int sNumber)
{
	int unitPtr = UnitToPtr(sUnit), temp = GetMemory(0x5c325c);

	if (unitPtr)
	{
		SetMemory(0x5c325c, ImportPlaySoundAround());
		Unused74(unitPtr, sNumber);
		SetMemory(0x5c325c, temp);
	}
}

int ImportUniChatCore()
{
    int arr[10], link;

    if (!link)
    {
        arr[0] = 0xC0685657; arr[1] = 0x6800528A; arr[2] = 0x00507250; arr[3] = 0x8B2414FF; arr[4] = 0x2414FFF8;
        arr[5] = 0x14FFF08B; arr[6] = 0x56505724; arr[7] = 0x102454FF; arr[8] = 0x5E14C483; arr[9] = 0x9090C35F;
        link = GetScrDataField(ImportUniChatCore);
    }
    return link;
}

void UniChatCore(int plrPtr, int sPtr, int sTime)
{
    int temp = GetMemory(0x5c3320);

    SetMemory(0x5c3320, ImportUniChatCore());
    GroupRunAway(sPtr, plrPtr, sTime);
    SetMemory(0x5c3320, temp);
}

int ImportUniPrintCore()
{
    int arr[8], link;

    if (!link)
    {
        arr[0] = 0x9EB06856; arr[1] = 0x5068004D; arr[2] = 0xFF005072; arr[3] = 0xF08B2414; arr[4] = 0x502414FF;
        arr[5] = 0x2454FF56; arr[6] = 0x10C4830C; arr[7] = 0x9090C35E; 
        link = GetScrDataField(ImportUniPrintCore);
    }
    return link;
}

void UniPrintCore(int plrPtr, int sPtr)
{
    int temp = GetMemory(0x5c31f4);

    SetMemory(0x5c31f4, ImportUniPrintCore());
    Unused5a(sPtr, plrPtr);
    SetMemory(0x5c31f4, temp);
}

int GetByteValue(int ptr)
{
    return GetMemory(ptr) & 0xff;
}

void WriteAddressWordValue(int addr, int word)
{
    int temp = GetMemory(addr) & 0xffff0000;
    SetMemory(addr, temp | word);
}

void NoxUtf8ToUnicode(int src, int dest)
{
    int i = 0, byt;

    while (1)
    {
        byt = GetByteValue(src + i);
        if (!byt) break;
        if (!(byt & 0x80))
        {
            WriteAddressWordValue(dest, byt);
            i ++;
        }
        else if ((byt & 0xe0) == 0xc0)
        {
            WriteAddressWordValue(dest, ((byt & 0x1f) <<6) | (GetByteValue(src + i + 1) & 0x3f));
            i += 2;
        }
        else if ((byt & 0xf0) == 0xe0)
        {
            WriteAddressWordValue(dest, ((byt & 0xf) << 12) | ((GetByteValue(src + i + 1) & 0x3f) << 6) | (GetByteValue(src + i + 2) & 0x3f));
            i += 3;
        }
        dest += 2;
    }
    WriteAddressWordValue(dest, 0);
}

void UniPrint(int sUnit, string sMsg)
{
    int wDest[200];
    int ptr = UnitToPtr(sUnit), str = SToInt(sMsg), link;

    if (ptr)
    {
        str = GetMemory(0x97bb40 + (str * 4));
        if (!link)
            link = GetScrDataField(UniPrint);
        NoxUtf8ToUnicode(str, link + 8);
        UniPrintCore(ptr, link + 8);
    }
}

void UniChatMessage(int sUnit, string sMsg, int duration)
{
    int wDest[200];
    int ptr = UnitToPtr(sUnit), str = SToInt(sMsg), link;

    if (ptr)
    {
        str = GetMemory(0x97bb40 + (str * 4));
        if (!link)
            link = GetScrDataField(UniChatMessage);
        NoxUtf8ToUnicode(str, link + 12);
        UniChatCore(ptr, link + 12, duration);
    }
}

void UniPrintToAll(string sMsg)
{
    int wDest[200];
    int plrPtr = 0x62f9e0, link, str = SToInt(sMsg), i;

    if (!link)
        link = GetScrDataField(UniPrint) + 4;
    str = GetMemory(0x97bb40 + (str * 4));
    NoxUtf8ToUnicode(str, link);
    for (i = 0 ; i < 32 ; i ++)
    {
        if (GetMemory(plrPtr))
            UniPrintCore(GetMemory(plrPtr), link);
        plrPtr += 0x12dc;
    }
}

int MathAbs(int num)
{
    if (num < 0)
        num = -num;
    return num;
}

int CheckSignDelay(int sPtr, int gap)
{
    int cFps = GetMemory(0x84ea04);

    if (MathAbs(cFps - GetMemory(sPtr)) > gap)
    {
        SetMemory(sPtr, cFps);
        return 1;
    }
    return 0;
}

void SignNotification()
{
    int otPtr = GetMemory(0x979720), sePtr = GetMemory(0x979724);

    if (otPtr && sePtr)
    {
        if (CheckSignDelay(GetMemory(sePtr + 0x2e0) + 100, 60))
        {
            UniPrint(other, ToStr(GetMemory(sePtr + 0x2f0)));
            //UniPrintCore(otPtr, GetMemory(sePtr + 0x2e0));
        }
    }
}

void RegistSignMessage(int sUnit, string sMsg)
{
    int ptr = UnitToPtr(sUnit), str = SToInt(sMsg);

    if (ptr)
    {
        SetMemory(ptr + 0x2f0, str);
        SetMemory(ptr + 0x2dc, ImportUseItemFunc());
        SetMemory(ptr + 0x2fc, SignNotification);
    }
}

int ImportUniBroadcast()
{
    int arr[6], link;

    if (!link)
    {
        arr[0] = 0x4D9FD068; arr[1] = 0x72506800; arr[2] = 0x14FF0050; arr[3] = 0x106A5024;
        arr[4] = 0x0C2454FF; arr[5] = 0xC310C483;
        link = GetScrDataField(ImportUniBroadcast);
    }
    return link;
}

void UniBroadcast(string sMsg)
{
    int wDest[100];
    int temp = GetMemory(0x5c3108), link, str = GetMemory(0x97bb40 + (SToInt(sMsg) * 4));

    if (!link)
        link = GetScrDataField(UniBroadcast);
    NoxUtf8ToUnicode(str, link + 4);
    SetMemory(0x5c3108, ImportUniBroadcast());
    Unused1f(link + 4);
    SetMemory(0x5c3108, temp);
}

int ImportUseItemFunc()
{
    int arr[10], link;
    if (!link)
    {
        arr[0] = 0x50731068; arr[1] = 0x50565500; arr[2] = 0x1424748B; arr[3] = 0x18246C8B;
        arr[4] = 0x02FC858B; arr[5] = 0x56550000; arr[6] = 0x2454FF50; arr[7] = 0x0CC48318;
        arr[8] = 0x835D5E58; arr[9] = 0x90C304C4;
        link = GetScrDataField(ImportUseItemFunc);
    }
    return link;
}

int ImportUnitCollideFunc()
{
    int arr[10], link;

    if (!link)
    {
        arr[0] = 0x50731068; arr[1] = 0x50565500; arr[2] = 0x14246C8B; arr[3] = 0x1824748B;
        arr[4] = 0x02FC858B; arr[5] = 0x56550000; arr[6] = 0x2454FF50; arr[7] = 0x0CC48318;
        arr[8] = 0x835D5E58; arr[9] = 0x90C304C4;
        link = GetScrDataField(ImportUnitCollideFunc);
    }
    return link;
}

int CalleeArgInt(int arg)
{
    return CalleeArgInt(arg);
}

int CallFunctionWithArgInt(int func, int arg)
{
    int link;

    if (!link)
    {
        link = GetMemory(GetMemory(0x75ae28) + ((0x30 * CalleeArgInt) + 0x20));
        return 0;
    }
    else
    {
        SetMemory(link + 0x10, func);
        return CalleeArgInt(arg);
    }
}

void SetDirectWeaponProperty(int unit, int propertyOffs1, int propertyOffs2, int propertyOffs3, int propertyOffs4)
{
    int i, ptr = UnitToPtr(unit);

    if (ptr)
    {
        SetMemory(GetMemory(ptr + 0x2b4), propertyOffs1);
        SetMemory(GetMemory(ptr + 0x2b4) + 4, propertyOffs2);
        SetMemory(GetMemory(ptr + 0x2b4) + 8, propertyOffs3);
        SetMemory(GetMemory(ptr + 0x2b4) + 12, propertyOffs4);
        for (i = 31 ; i >= 0 ; i --)
            SetMemory(ptr + 0x230 + (i * 4), 0x200);
    }
}

void SetWeaponProperties(int ptr, int power, int mt_lv, int wfx1, int wfx2)
{
    int k;

    if (ptr)
    {
        SetMemory(GetMemory(ptr + 0x2b4), WeaponPower(power));
        SetMemory(GetMemory(ptr + 0x2b4) + 4, MaterialList(mt_lv));
        SetMemory(GetMemory(ptr + 0x2b4) + 8, WeaponEffect(wfx1));
        SetMemory(GetMemory(ptr + 0x2b4) + 12, WeaponEffect(wfx2));
        for (k = 31 ; k >= 0 ; k --)
            SetMemory(ptr + 0x230 + (k * 4), 0x200);
    }
}

string PotionList()
{
    string list = {"RedPotion", "CurePoisonPotion", "YellowPotion", "BlackPotion",
        "VampirismPotion", "Mushroom", "PoisonProtectPotion", "ShockProtectPotion",
        "FireProtectPotion", "HastePotion", "ShieldPotion", "InfravisionPotion",
        "InvisibilityPotion", "AmuletofManipulation", "AmuletofManipulation", "AmuletofNature",
        "Fear", "WhitePotion", "BluePotion", "BottleCandle"};

    return list;
}

string WeaponList()
{
    string name = {
        "GreatSword", "Longsword", "Sword", "MorningStar",
        "OgreAxe", "StaffWooden", "BattleAxe", "FanChakram",
        "RoundChakram", "WarHammer", "OblivionHalberd", "OblivionWierdling",
        "OblivionHeart"
    };
    return name;
}

string ArmorList()
{
    string name = {
        "OrnateHelm", "Breastplate", "PlateArms", "PlateBoots",
        "PlateLeggings", "MedievalCloak", "ChainCoif", "ChainLeggings",
        "ChainTunic", "SteelHelm", "LeatherArmbands", "LeatherArmor",
        "LeatherArmoredBoots", "LeatherBoots", "LeatherHelm", "LeatherLeggings",
        "MedievalPants", "MedievalShirt"
    };
    return name;
}

int RewardClassDropHotPotion(int sUnit)
{
    return CreateObjectAt("RedPotion", GetObjectX(sUnit), GetObjectY(sUnit));
}

void ItemUseClassTeleportAmulet()
{
    if (CurrentHealth(other))
    {
        Delete(self);
        Effect("TELEPORT", GetObjectX(other), GetObjectY(other), 0.0, 0.0);

        MoveObject(other, LocationX(12), LocationY(12));
        PlaySoundAround(other, 6);
        Effect("TELEPORT", GetObjectX(other), GetObjectY(other), 0.0, 0.0);
        Effect("SMOKE_BLAST", GetObjectX(other), GetObjectY(other), 0.0, 0.0);
        UniPrint(other, "안전한 곳으로 공간이동 하였습니다");
    }
}

void ItemUseClassElectricAmulet()
{
    if (CurrentHealth(other))
    {
        if (CurrentHealth(other) ^ MaxHealth(other))
            RestoreHealth(other, 65);
        Enchant(other, EnchantList(27), 15.0);
        Enchant(other, EnchantList(22), 15.0);
        Delete(self);
    }
}

void ItemUseClassHealingPotion()
{
    if (CurrentHealth(other))
    {
        if (!UnitCheckEnchant(other, GetLShift(30)))
        {
            Enchant(other, EnchantList(30), 10.0);

            int healing = CreateObjectAtUnit("InvisibleLightBlueLow", other);
            SetOwner(other, healing);
            Enchant(healing, EnchantList(8), 0.0);
            FrameTimerWithArg(1, healing, UnitHealingHandler);

            PlaySoundAround(other, 1004);
            UniPrint(other, "자연의 힘이 잠시동안 당신을 지속적으로 치료해 줍니다");
        }
        else
            UniPrint(other, "당신은 이미 이 능력의 영향권에 있습니다");
        Delete(self);
    }
}

void ItemUseClassCandle()
{
    if (CurrentHealth(other))
    {
        Delete(self);
        CastSpellObjectObject("SPELL_FORCE_OF_NATURE", other, other);
        UniPrint(other, "광화문 1000만 촛불의 힘을 보여주겠다!");
    }
}

int CreateYellowPotion(int restoreAmount, float xProfile, float yProfile)
{
    int unit = CreateObjectAt("RedPotion", xProfile, yProfile);
    int ptr = GetMemory(0x750710);

    SetMemory(ptr + 4, 639); //YellowPotion
    SetMemory(GetMemory(ptr + 0x2e0), restoreAmount);

    return unit;
}

int CreateBlackPotion(int restoreAmount, float xProfile, float yProfile)
{
    int unit = CreateObjectAt("RedPotion", xProfile, yProfile);
    int ptr = GetMemory(0x750710);

    SetMemory(ptr + 4, 641); //BlackPotion
    SetMemory(GetMemory(ptr + 0x2e0), restoreAmount);

    return unit;
}

int CreateWhitePotion(int restoreAmount, float xProfile, float yProfile)
{
    int unit = CreateObjectAt("RedPotion", xProfile, yProfile);
    int ptr = GetMemory(0x750710);

    SetMemory(ptr + 4, 640); //WhitePotion
    SetMemory(ptr + 12, GetMemory(ptr + 12) ^ 0x20);
    SetMemory(GetMemory(ptr + 0x2e0), restoreAmount);

    return unit;
}

void TeleportAmulet(int amulet)
{
    int ptr = UnitToPtr(amulet);

    if (ptr)
    {
        SetMemory(ptr + 0x2dc, ImportUseItemFunc());
        SetMemory(ptr + 0x2fc, ItemUseClassTeleportAmulet);
    }
}

void ElectricAmulet(int amulet)
{
    int ptr = UnitToPtr(amulet);

    if (ptr)
    {
        SetMemory(ptr + 0x2dc, ImportUseItemFunc());
        SetMemory(ptr + 0x2fc, ItemUseClassElectricAmulet);
    }
}

void HealingPotion(int amulet)
{
    int ptr = UnitToPtr(amulet);

    if (ptr)
    {
        SetMemory(ptr + 0x2dc, ImportUseItemFunc());
        SetMemory(ptr + 0x2fc, ItemUseClassHealingPotion);
    }
}

void MagicCandle(int magicCandle)
{
    int ptr = UnitToPtr(magicCandle);

    if (ptr)
    {
        SetMemory(ptr + 0x2dc, ImportUseItemFunc());
        SetMemory(ptr + 0x2fc, ItemUseClassCandle);
    }
}

int CheckPotionThingID(int unit)
{
    int thingID = GetUnitThingID(unit), x = unit;

    if (thingID == 639)
        x = CreateYellowPotion(125, GetObjectX(unit), GetObjectY(unit));
    else if (thingID == 640)
        x = CreateWhitePotion(100, GetObjectX(unit), GetObjectY(unit));
    else if (thingID == 641)
        x = CreateBlackPotion(85, GetObjectX(unit), GetObjectY(unit));
    else if (thingID == 1184)
        TeleportAmulet(unit);
    else if (thingID == 239)
        ElectricAmulet(unit);
    else if (thingID == 1185)
        HealingPotion(unit);
    else if (thingID == 1197)
        MagicCandle(unit);

    if (x ^ unit) Delete(unit);
    return x;
}

int RewardClassDropPotion(int sUnit)
{
    return CheckPotionThingID(CreateObjectAtUnit(ToStr(SToInt(PotionList()) + Random(0, 19)), sUnit));
}

int MoneyDrop(int sUnit)
{
    int money = CreateObjectAt("Gold", GetObjectX(sUnit), GetObjectY(sUnit));
    SetMemory(GetMemory(GetMemory(0x750710) + 0x2b4), Random(200, 2000));
    return money;
}

int SomeGermDrop(int sUnit)
{
    string name = {"Ruby", "Ruby", "Ruby", "Emerald", "Diamond"};

    return CreateObjectAtUnit(ToStr(SToInt(name) + Random(0, 2)), sUnit);
}

int NormalWeaponItemDrop(int sUnit)
{
    int weapon = CreateObjectAtUnit(ToStr(SToInt(WeaponList()) + Random(0, 7)), sUnit);
    int ptr = GetMemory(0x750710);

    CheckSpecialItem(ptr);
    return weapon;
}

int NormalArmorItemDrop(int sUnit)
{
    return CreateObjectAtUnit(ToStr(SToInt(ArmorList()) + Random(0, 17)), sUnit);
}

int WeaponItemDrop(int sUnit)
{
    int unit = CreateObjectAtUnit(ToStr(SToInt(WeaponList()) + Random(0, 12)), sUnit);
    int ptr = GetMemory(0x750710);

    CheckSpecialItem(ptr);
    SetWeaponProperties(ptr, Random(0, 5), Random(0, 5), Random(0, 36), Random(0, 36));
    return unit;
}

void SetArmorProperties(int ptr, int qual, int mt_lv, int afx1, int afx2)
{
    int k;

    SetMemory(GetMemory(ptr + 0x2b4), ArmorQuality(qual));
    SetMemory(GetMemory(ptr + 0x2b4) + 4, MaterialList(mt_lv));
    SetMemory(GetMemory(ptr + 0x2b4) + 8, ArmorEffect(afx1));
    SetMemory(GetMemory(ptr + 0x2b4) + 12, ArmorEffect(afx2));
    for (k = 31 ; k >= 0 ; k --)
        SetMemory(ptr + 0x230 + (k * 4), 0x200);
}

int ArmorItemDrop(int sUnit)
{
    int unit = CreateObjectAtUnit(ToStr(SToInt(ArmorList()) + Random(0, 17)), sUnit);
    int ptr = GetMemory(0x750710);

    SetArmorProperties(ptr, Random(0, 5), Random(0, 5), Random(0, 20), Random(0, 20));
    return unit;
}

void DungeonMonsterDeath()
{
    int maxCount = g_dropItemFunctions[0];

    CallFunctionWithArgInt(g_dropItemFunctions[Random(1, maxCount)], self);
    DeleteObjectTimer(self, 150);
}

int ImportAllowAllDrop()
{
	int arr[19], link;

	if (!link)
	{
		arr[0] = 0x550CEC83; arr[1] = 0x14246C8B; arr[2] = 0x24748B56; arr[3] = 0xECAE391C; arr[4] = 0x74000001; arr[5] = 0xC0315E08; arr[6] = 0x0CC4835D;
		arr[7] = 0x0845F6C3; arr[8] = 0x68207404; arr[9] = 0x0053EBF0; arr[10] = 0x2454FF56; arr[11] = 0x08C48304; arr[12] = 0x0F74C085; arr[13] = 0x53EC8068;
		arr[14] = 0x56016A00; arr[15] = 0x082454FF; arr[16] = 0x680CC483; arr[17] = 0x004ED301; arr[18] = 0x909090C3;
        link = GetScrDataField(ImportAllowAllDrop);
	}
	return link;
}

void InitInvPropertiesSet()
{
    WeaponEffect(0);
    ArmorEffect(0);
    WeaponPower(0);
    ArmorQuality(0);
    MaterialList(0);
    ImportAllowAllDrop();
}

void CheckSpecialItem(int ptr)
{
    int id = GetMemory(ptr + 0x04);

    if (id >= 222 && id <= 225)
    {
        SetMemory(ptr + 0x2c4, 0x53a720);
        SetMemory(ptr + 0x2c8, ImportAllowAllDrop());
    }
    else if (id == 1178)
        SetMemory(GetMemory(ptr + 0x2e0), 0xffff);
    else if (id == 1168)
        SetMemory(GetMemory(ptr + 0x2e0), 0xffff);
}

int WeaponPower(int num)
{
    int addr[6];

    if (!addr[0])
    {
        addr[0] = 0x5a00a4; addr[1] = 0x5BA714; addr[2] = 0x5BA72C; addr[3] = 0x5BA744; addr[4] = 0x5BA75C; addr[5] = 0x5BA774;
        return 0;
    }
    return GetMemory(addr[num]);
}

int ArmorQuality(int num)
{
    int addr[6];

    if (!addr[0])
    {
        addr[0] = 0x5a00a4; addr[1] = 0x5BA7A4; addr[2] = 0x5BA7BC; addr[3] = 0x5BA7D4; addr[4] = 0x5BA7EC; addr[5] = 0x5BA804;
        return 0;
    }
    return GetMemory(addr[num]);
}

int MaterialList(int num)
{
    int addr[6];

    if (!addr[0])
    {
        //Lv.3 ~ 7, null
        addr[0] = 0x5a00a4; addr[1] = 0x5ba834; addr[2] = 0x5ba84c; addr[3] = 0x5ba864; addr[4] = 0x5ba87c; addr[5] = 0x5ba894;
        return 0;
    }
    return GetMemory(addr[num]);
}

int WeaponEffect(int num)
{
    int addr[37];

    if (!addr[0])
    {
        addr[0] = 0x5a00a4;
        addr[1] = 0x5BA1BC; addr[2] = 0x5BA1D4; addr[3] = 0x5BA1EC; addr[4] = 0x5BA204; addr[5] = 0x5BA21C; addr[6] = 0x5BA234; addr[7] = 0x5BA24C; addr[8] = 0x5BA264;
        addr[9] = 0x5BA27C; addr[10] = 0x5BA294; addr[11] = 0x5BA2AC; addr[12] = 0x5BA2C4; addr[13] = 0x5BA2DC; addr[14] = 0x5BA2F4; addr[15] = 0x5BA30C; addr[16] = 0x5BA324;
        addr[17] = 0x5BA33C; addr[18] = 0x5BA354; addr[19] = 0x5BA36C; addr[20] = 0x5BA384; addr[21] = 0x5BA39C; addr[22] = 0x5BA3B4; addr[23] = 0x5BA3CC; addr[24] = 0x5BA3E4;
        addr[25] = 0x5BA3FC; addr[26] = 0x5BA414; addr[27] = 0x5BA42C; addr[28] = 0x5BA444;
        addr[29] = 0x5BA63C; addr[30] = 0x5BA654; addr[31] = 0x5BA66C; addr[32] = 0x5BA684;
        addr[33] = 0x5BA69C; addr[34] = 0x5BA6B4; addr[35] = 0x5BA6CC; addr[36] = 0x5BA6E4;
        return 0;
    }
    return GetMemory(addr[num]);
}

int ArmorEffect(int num)
{
    int addr[21];

    if (!addr[0])
    {
        addr[0] = 0x5a00a4;
        addr[1] = 0x5BA45C; addr[2] = 0x5BA474; addr[3] = 0x5BA48C; addr[4] = 0x5BA4A4; addr[5] = 0x5BA4BC; addr[6] = 0x5BA4D4; addr[7] = 0x5BA4EC; addr[8] = 0x5BA504;
        addr[9] = 0x5BA51C; addr[10] = 0x5BA534; addr[11] = 0x5BA54C; addr[12] = 0x5BA564; addr[13] = 0x5BA57C; addr[14] = 0x5BA594; addr[15] = 0x5BA5AC; addr[16] = 0x5BA5C4;
        addr[17] = 0x5BA5DC; addr[18] = 0x5BA5F4; addr[19] = 0x5BA60C; addr[20] = 0x5BA624;
        return 0;
    }
    return GetMemory(addr[num]);
}

int GetWordValue(int num)
{
	return num & 0xffff;
}

void WriteAddressByteValue(int addr, int byt)
{
	int temp = GetMemory(addr) & 0xffffff00;
	SetMemory(addr, temp | byt);
}

int NoxUnicodeToUtf8(int src, int destPtr)
{
	int i, byt, dest = destPtr;

	for (i = 0 ; i < 20 ; i ++)
	{
		byt = GetWordValue(GetMemory(src));
        if (!byt) break;
		if (byt < 0x80)
		{
			WriteAddressByteValue(dest, byt);
			dest ++;
		}
		else if (byt < 0x800)
		{
			WriteAddressByteValue(dest, ((byt >> 6) & 0x1f) | 0xc0);
			WriteAddressByteValue(dest + 1, (byt & 0x3f) | 0x80);
			dest += 2;
		}
		else
		{
			WriteAddressByteValue(dest, ((byt >> 12) & 0x0f) | 0xe0);
			WriteAddressByteValue(dest + 1, ((byt >> 6) & 0x3f) | 0x80);
			WriteAddressByteValue(dest + 2, (byt & 0x3f) | 0x80);
			dest += 3;
		}
        src += 2;
	}
    WriteAddressByteValue(dest, 0);
	return dest - destPtr;
}

string PlayerIngameNick(int sUnit)
{
    string emptyName = {
        "00:01234567890123456789abcd0123456789abxyz", "01:01234567890123456789abcd0123456789abxyz",
        "02:01234567890123456789abcd0123456789abxyz", "03:01234567890123456789abcd0123456789abxyz",
        "04:01234567890123456789abcd0123456789abxyz", "05:01234567890123456789abcd0123456789abxyz",
        "06:01234567890123456789abcd0123456789abxyz", "07:01234567890123456789abcd0123456789abxyz",
        "08:01234567890123456789abcd0123456789abxyz", "09:01234567890123456789abcd0123456789abxyz",
        "10:01234567890123456789abcd0123456789abxyz", "11:01234567890123456789abcd0123456789abxyz",
        "12:01234567890123456789abcd0123456789abxyz", "13:01234567890123456789abcd0123456789abxyz",
        "14:01234567890123456789abcd0123456789abxyz", "15:01234567890123456789abcd0123456789abxyz",
        "16:01234567890123456789abcd0123456789abxyz", "17:01234567890123456789abcd0123456789abxyz",
        "18:01234567890123456789abcd0123456789abxyz", "19:01234567890123456789abcd0123456789abxyz",
        "20:01234567890123456789abcd0123456789abxyz", "21:01234567890123456789abcd0123456789abxyz",
        "22:01234567890123456789abcd0123456789abxyz", "23:01234567890123456789abcd0123456789abxyz",
        "24:01234567890123456789abcd0123456789abxyz", "25:01234567890123456789abcd0123456789abxyz",
        "26:01234567890123456789abcd0123456789abxyz", "27:01234567890123456789abcd0123456789abxyz",
        "28:01234567890123456789abcd0123456789abxyz", "29:01234567890123456789abcd0123456789abxyz",
        "30:01234567890123456789abcd0123456789abxyz", "31:01234567890123456789abcd0123456789abxyz"};
    int ptr = UnitToPtr(sUnit), plrIndex, destPtr, srcPtr;
    
    if (ptr)
    {
        if (GetMemory(ptr + 0x08) & 4)
        {
            plrIndex = GetMemory(GetMemory(GetMemory(ptr + 0x2ec) + 0x114) + 0x810);
            destPtr = GetMemory(0x97bb40 + ((SToInt(emptyName) + plrIndex) * 4));
            srcPtr = GetMemory(GetMemory(ptr + 0x2ec) + 0x114) + 0x889;
            NoxUnicodeToUtf8(srcPtr, destPtr);
            return ToStr(SToInt(emptyName) + plrIndex);
        }
    }
    return "NULL";
}

string StringOverflow(int t)
{
	return ToStr((t - 0x97bb40) / 4);
}

string EnchantList(int sNumber)
{
	return StringOverflow(0x596f24 + (sNumber * 4));
}

int UnitCheckEnchant(int sUnit, int sMagicFlag)
{
    int ptr = UnitToPtr(sUnit);

    if (ptr)
        return GetMemory(ptr + 0x154) & sMagicFlag;
    return 0;
}

int GetLShift(int sCount)
{
    return (1 << sCount);
}

void SetUnitEnchantCopy(int sUnit, int sMagicFlag)
{
	int ptr = UnitToPtr(sUnit);

	if (ptr)
	{
		Enchant(sUnit, EnchantList(6), 0.0);
		SetMemory(ptr + 0x154, GetMemory(ptr + 0x154) | sMagicFlag);
	}
}

void UnitSetEnchantTime(int unit, int enchantNumber, int durateTime)
{
	int ptr = UnitToPtr(unit), temp, tempPtr;

	if (ptr)
	{
		SetUnitEnchantCopy(unit, GetLShift(enchantNumber));
		tempPtr = ptr + 0x158 + ((enchantNumber / 2) * 4);
		temp = GetMemory(tempPtr);
		if (enchantNumber % 2)
		{
			SetMemory(tempPtr, (GetMemory(tempPtr) & 0xffff) | (durateTime << 0x10));
		}
		else
			SetMemory(tempPtr, ((GetMemory(tempPtr) >> 0x10) << 0x10) | durateTime);
	}
}

int ImportRemoveSneakDelay()
{
    int arr[7], link;

    if (!link)
    {
        arr[0] = 0x72506850; arr[1] = 0x14FF0050; arr[2] = 0xC3006824; arr[3] = 0x046A004F; arr[4] = 0x2454FF50; arr[5] = 0x10C48308; arr[6] = 0x9090C358;
        link = GetMemory(GetMemory(0x75ae28) + (0x30 * ImportRemoveSneakDelay) + 0x1c);
    }
    return link;
}

void RemoveTreadLightly(int plrUnit)
{
    int ptr = UnitToPtr(plrUnit), temp = GetMemory(0x5c336c);

    if (ptr)
    {
        if (GetMemory(ptr + 0x08) & 0x04)
        {
            SetMemory(0x5c336c, ImportRemoveSneakDelay());
            Unknownb8(ptr);
            SetMemory(0x5c336c, temp);
        }
    }
}

void WindBooster(int plrUnit)
{
    if (UnitCheckEnchant(plrUnit, GetLShift(31)))
    {
        EnchantOff(plrUnit, EnchantList(31));
        RemoveTreadLightly(plrUnit);
        Enchant(plrUnit, EnchantList(8), 0.3);
        PushObjectTo(plrUnit, UnitAngleCos(plrUnit, 70.0), UnitAngleSin(plrUnit, 70.0));
        Effect("RICOCHET", GetObjectX(plrUnit), GetObjectY(plrUnit), 0.0, 0.0);
    }
}

float UnitRatioX(int unit, int target, float size)
{
    return (GetObjectX(unit) - GetObjectX(target)) * size / Distance(GetObjectX(unit), GetObjectY(unit), GetObjectX(target), GetObjectY(target));
}

float UnitRatioY(int unit, int target, float size)
{
    return (GetObjectY(unit) - GetObjectY(target)) * size / Distance(GetObjectX(unit), GetObjectY(unit), GetObjectX(target), GetObjectY(target));
}

float UnitAngleCos(int unit, float size)
{
    return MathSine((GetDirection(unit) * 45 / 32) + 90, size);
}

float UnitAngleSin(int unit, float size)
{
    return MathSine(GetDirection(unit) * 45 / 32, size);
}

float MathSine(int angle, float size)
{
    float var_0[91];
    int i, k;
 
    if (!ToInt(var_0[90]))
    {
        MoveWaypoint(angle + 1, GetWaypointX(angle), GetWaypointY(angle) - 1.0);
        for (i = 0 ; i <= 90 ; i ++)
        {
            var_0[i] = GetSineValue(angle, size);
            Delete(k + i + 1);
        }
        return var_0[0];
    }
    k = angle / 90;
    i = angle - (k * 90);

    if (k % 2) i = 90 - i;
    if ((angle / 180) % 2) return -var_0[i] * size;
	else return var_0[i] * size;
}

float GetSineValue(int wp, float c)
{
    float x_ratio = WayRatioX(wp, wp + 1), y_ratio = WayRatioY(wp, wp + 1), res;

    res = GetWaypointX(wp) - GetWaypointX(wp + 1);
    MoveWaypoint(wp + 1, GetWaypointX(wp) - (c * y_ratio) - x_ratio, GetWaypointY(wp) + (c * x_ratio) - y_ratio);
    return res;
}

float WayRatioX(int wp1, int wp2)
{
    return (GetWaypointX(wp1) - GetWaypointX(wp2)) * 1.0 / Distance(GetWaypointX(wp1), GetWaypointY(wp1), GetWaypointX(wp2), GetWaypointY(wp2));
}

float WayRatioY(int wp1, int wp2)
{
    return (GetWaypointY(wp1) - GetWaypointY(wp2)) * 1.0 / Distance(GetWaypointX(wp1), GetWaypointY(wp1), GetWaypointX(wp2), GetWaypointY(wp2));
}

int PlaceMagicWeapon(int location)
{
    int weapon = CreateObjectAt("OblivionHeart", LocationX(location), LocationY(location));
    int ptr = GetMemory(0x750710);

    SetWeaponProperties(ptr, 5, 5, 8, 3);
    //Todo. 여기에서 마법 세팅을 한다

    return weapon;
}

int SummonMobSwordsman(int sUnit)
{
    int unit = CreateObjectAtUnit("Swordsman", sUnit);

    SetUnitMaxHealth(unit, 325);
    RetreatLevel(unit, 0.0);
    ResumeLevel(unit, 1.0);
    return unit;
}

int SummonMobArcher(int sUnit)
{
    int unit = CreateObjectAtUnit("Archer", sUnit);

    SetUnitMaxHealth(unit, 98);
    RetreatLevel(unit, 0.0);
    ResumeLevel(unit, 1.0);
    return unit;
}

int SummonMobMecaFlying(int sUnit)
{
    int unit = CreateObjectAtUnit("FlyingGolem", sUnit);

    SetUnitMaxHealth(unit, 64);
    return unit;
}

void MobMakerProc(int maker)
{
    int count = GetDirection(maker), mob;

    while (IsObjectOn(maker))
    {
        if (count)
        {
            FrameTimerWithArg(1, maker, MobMakerProc);
            LookWithAngle(maker, count - 1);
            mob = CallFunctionWithArgInt(ToInt(GetObjectZ(maker)), maker);
            if (CurrentHealth(mob))
                SetCallback(mob, 5, MobMakerMobDeath);
            break;
        }
        Delete(maker);
        break;
    }
}

int MobMakerCounter()
{
    int counter, nextFunction;

    return counter;
}

void SetNextFunction(int nextFunction)
{
    int ptr = GetScrDataField(MobMakerCounter);

    SetMemory(ptr + 4, nextFunction);
}

void MobMakerDecraseCounter()
{
    int counterPtr = GetScrDataField(MobMakerCounter);

    SetMemory(counterPtr, MobMakerCounter() - 1);
    if (!MobMakerCounter())
    {
        CallFunction(GetMemory(counterPtr + 4));
        SetNextFunction(EndAreaDefault);
    }
}

void MobMakerMobDeath()
{
    MobMakerDecraseCounter();
    DungeonMonsterDeath();
}

int PlaceMobMaker(int location, int count, int function)
{
    int maker = CreateObjectAt("ImaginaryCaster", LocationX(location), LocationY(location));
    int counter = MobMakerCounter();
    int counterPtr = GetScrDataField(MobMakerCounter);

    LookWithAngle(maker, count);
    Raise(maker, function);
    SetMemory(counterPtr, counter + count);
    return maker;
}

void MobMakerStartSummon(int delay, int maker)
{
    if (IsObjectOn(maker))
    {
        if (!delay)
            delay = 1;
        FrameTimerWithArg(delay, maker, MobMakerProc);
    }
}

void SaveLastLocation(int location)
{
    TeleportLocation(g_userLastSavedLocation, LocationX(location), LocationY(location));
}

void TeleportComplete(int point, int owner)
{
    Effect("SMOKE_BLAST", GetObjectX(point), GetObjectY(point), 0.0, 0.0);
    Effect("TELEPORT", GetObjectX(point), GetObjectY(point), 0.0, 0.0);
    MoveObject(owner, GetObjectX(point), GetObjectY(point));
    PlaySoundAround(owner, 6);
    Effect("TELEPORT", GetObjectX(owner), GetObjectY(owner), 0.0, 0.0);
}

void TeleportProgress(int point)
{
    int owner = GetOwner(point), durate = GetDirection(point);

    while (IsObjectOn(point))
    {
        if (CurrentHealth(owner))
        {
            if (durate)
            {
                if (DistanceUnitToUnit(point + 1, owner) < 23.0)
                {
                    FrameTimerWithArg(1, point, TeleportProgress);
                    LookWithAngle(point, durate - 1);
                    break;
                }
            }
            else
                TeleportComplete(point, owner);
            EnchantOff(owner, EnchantList(12));
        }
        Delete(point);
        Delete(point + 1);
        break;
    }
}

void TeleportStart(int target, int destLocation)
{
    if (CurrentHealth(target))
    {
        if (!UnitCheckEnchant(target, GetLShift(12)))
        {
            Enchant(target, EnchantList(12), 4.0);
            int point = CreateObjectAt("ImaginaryCaster", LocationX(destLocation), LocationY(destLocation));
            CreateObjectAt("VortexSource", GetObjectX(target), GetObjectY(target));
            FrameTimerWithArg(1, point, TeleportProgress);
            SetOwner(target, point);
            LookWithAngle(point, 48);
            GreenSparkFx(GetObjectX(target), GetObjectY(target));
            PlaySoundAround(point + 1, 772);    //SoundFX: LongBellsUp
            if (IsPlayerUnit(target))
                UniPrint(target, "공간이동을 준비중입니다. 캐릭터를 움직이면 취소됩니다");
        }
    }
}

void EntryTeleportPortal()
{
    TeleportStart(other, 51);
}

int PlaceLastSavedTeleport(object location)
{
    int telpo = CreateObjectAt("WeirdlingBeast", LocationX(location), LocationY(location));

    Enchant(CreateObjectAtUnit("InvisibleLightBlueLow", telpo), EnchantList(14), 0.0);
    Damage(telpo, 0, MaxHealth(telpo) + 1, -1);
    SetCallback(telpo, 9, EntryTeleportPortal);

    return telpo;
}

void TestingFunction()  //!RemoveMe!//
{
    SummonBigFish(Object("MapSign1"));
}

void MonStrikeBuffInit()
{
    MonsterStrikeHandlerCopiedCode(MonsterStrikeCallback);
    UniPrintToAll("!RemoveMe! void MonStrikeBuffInit()");
}

void DelayMapInit()
{
    g_userLastSavedLocation = 51;

    PlaceLastSavedTeleport(50);
    PlaceDefaultItems("RedPotion", 48);
    PlaceDefaultItems("RedPotion", 47);
    PlaceDefaultItems("GreatSword", 46);
    PlaceDefaultItems("RoundChakram", 45);
    ShopClassMagicalWeaponMarketCreate(49);
    ShopClassAllEnchantMarketCreate(67);
    RegistSignMessage(Object("MapSign1"), "안녕하시오! 여행자. 이곳은 당신같은 사람이면 위험한 곳이지..");
    RegistSignMessage(Object("MapSign2"), "-이곳은 이마트 편의점의 입구입니다- 거래를 하려면 문을열고 안으로 오세요");
    RegistSignMessage(Object("MapSign3"), "특수 무기를 판매하고 있어요");
    RegistSignMessage(Object("MapSign4"), "이 워프게이트는 사용자가 마지막으로 탐험한 위치로 이동합니다");

    g_ternnelSwitch = Object("TernnelSwitch");
    ObjectOff(g_ternnelSwitch);
    Enchant(g_ternnelSwitch, EnchantList(0), 0.0);
    FrameTimer(30, LoopSearchIndex);
    FrameTimer(60, InitBlocks);
    FrameTimer(20, InitWeaponContainer);
    FrameTimer(1, InitializeGenerators);
    FrameTimer(80, MonStrikeBuffInit);

    // FrameTimer(10, TestingFunction);        //!RemoveMe!// Test only//

    SetHostileCritter();
}

void EntryArea1()
{
    int once;

    ObjectOff(self);
    if (!once)
    {
        once = true;
        MobMakerStartSummon(0, PlaceMobMaker(15, 30, SummonMobSwordsman));
        MobMakerStartSummon(0, PlaceMobMaker(16, 30, SummonMobArcher));
        MobMakerStartSummon(0, PlaceMobMaker(17, 30, SummonMobMecaFlying));
        SetNextFunction(EndArea1);
    }
}

void EndAreaDefault()
{ }

void EndArea1()
{
    int i;

    for (i = 18 ; i <= 29 ; i ++)
        ClearWallAtWaypointPos(i);
    FrameTimer(30, EntryArea2);
    UniPrintToAll("비밀의 벽이 열립니다");
}

void EntryArea2()
{
    MobMakerStartSummon(0, PlaceMobMaker(30, 60, SummonMobMystic));
    SetNextFunction(EndArea2);
}

int SummonMobMystic(int sUnit)
{
    int unit = CreateObjectAtUnit("Wizard", sUnit);

    SetUnitMaxHealth(unit, 260);
    RetreatLevel(unit, 0.0);
    ResumeLevel(unit, 1.0);
    Enchant(unit, "ENCHANT_ANCHORED", 0.0);
    return unit;
}

void EndArea2()
{
    int i;

    for (i = 0 ; i < 4 ; i ++)
    {
        ClearWallAtWaypointPos(31);
        ClearWallAtWaypointPos(35);
        TeleportLocationVector(31, -23.0, 23.0);
        TeleportLocationVector(35, -23.0, 23.0);
    }
    FrameTimer(30, EntryArea3);
    UniPrintToAll("비밀의 벽이 열렸습니다!");
}

int SummonMobBlackSpider(int posUnit)
{
    int unit = CreateObjectAtUnit("BlackWidow", posUnit);

    BlackWidowSubProcess(unit);
    RetreatLevel(unit, 0.0);
    ResumeLevel(unit, 1.0);

    return unit;
}

int SummonMobGoon(int posUnit)
{
    int unit = CreateObjectAtUnit("Goon", posUnit);

    UnitLinkBinScript(unit, GoonBinTable());
    SetUnitVoice(unit, 63);
    SetUnitMaxHealth(unit, 275);

    return unit;
}

int SummonUrchin(int posUnit)
{
    int unit = CreateObjectAtUnit("Urchin", posUnit);

    UnitZeroFleeRange(unit);
    SetUnitMaxHealth(unit, 130);
    return unit;
}

void RemoveSingleWallWithFx(int location, float vectX, float vectY)
{
    ClearWallAtWaypointPos(location);
    Effect("JIGGLE", LocationX(location), LocationY(location), 11.0, 0.0);
    Effect("SMOKE_BLAST", LocationX(location), LocationY(location), 11.0, 0.0);
    if (ToInt(vectX) || ToInt(vectY))
        TeleportLocationVector(location, vectX, vectY);
}

void ClearMinesWalls()
{
    int i;

    for (i = 0 ; i < 18 ; i ++)
    {
        if (i < 8)
            RemoveSingleWallWithFx(53, -23.0, 23.0);
        RemoveSingleWallWithFx(54, 23.0, 23.0);
    }
}

void EndArea3()
{
    FrameTimer(10, ClearMinesWalls);
    FrameTimer(20, EntryArea4);
}

void EntryArea3()
{
    MobMakerStartSummon(3, PlaceMobMaker(39, 20, SummonMobBlackSpider));
    MobMakerStartSummon(3, PlaceMobMaker(40, 20, SummonMobGoon));
    MobMakerStartSummon(3, PlaceMobMaker(41, 20, SummonUrchin));
    SetNextFunction(EndArea3);
}

int SummonMobStoneGiant(int posUnit)
{
    int giant = CreateObjectAtUnit("StoneGolem", posUnit);

    SetUnitMaxHealth(giant, 750);
    Enchant(giant, EnchantList(9), 0.0);
    return giant;
}

int SummonMobImp(int posUnit)
{
    int fairy = CreateObjectAtUnit("Imp", posUnit);

    ImpSubProcess(fairy);
    return fairy;
}

int SummonMobShade(int posUnit)
{
    int shade = CreateObjectAtUnit("Shade", posUnit);

    SetUnitMaxHealth(shade, 225);
    return shade;
}

void EndArea4()
{
    ClearWallAtWaypointPos(68);
    ClearWallAtWaypointPos(69);
    ClearWallAtWaypointPos(70);
    FrameTimer(30, EntryArea5);
}

void EntryArea4()
{
    MobMakerStartSummon(1, PlaceMobMaker(42, 32, SummonMobStoneGiant));
    MobMakerStartSummon(1, PlaceMobMaker(43, 20, SummonMobImp));
    MobMakerStartSummon(1, PlaceMobMaker(44, 32, SummonMobShade));
    SetNextFunction(EndArea4);
}

int SummonMobWasp(int posUnit)
{
    int honey = CreateObjectAtUnit("Wasp", posUnit);

    WaspSubProcess(honey);
    return honey;
}

int SummonMobScorpion(int posUnit)
{
    int mob = CreateObjectAtUnit("Scorpion", posUnit);

    ScorpionSubProcess(mob);
    return mob;
}

int SummonMobHorrendous(int posUnit)
{
    int mob = CreateObjectAtUnit("Horrendous", posUnit);

    SetUnitMaxHealth(mob, 325);
    RegistUnitStrikeHook(mob);
    return mob;
}

int SummonBigFish(int posUnit)
{
    int mob = CreateObjectAtUnit("FishBig", posUnit);

    FishBigSubProcess(mob);
    RegistUnitStrikeHook(mob);
    return mob;
}

int SummonLichMaster(int posUnit)
{
    int master = CreateObjectAtUnit("LichLord", posUnit);

    LichLordSubProcess(master);
    return master;
}

void EndArea5()
{
    UnlockDoor(Object("ExitLocker1"));
    UnlockDoor(Object("ExitLocker2"));
    UniPrintToAll("출입문이 열렸습니다");
    FrameTimer(30, EntryArea6);
}

void EntryArea5()
{
    MobMakerStartSummon(1, PlaceMobMaker(75, 6, SummonMobWasp));
    MobMakerStartSummon(1, PlaceMobMaker(76, 6, SummonMobWasp));

    MobMakerStartSummon(3, PlaceMobMaker(72, 15, SummonMobScorpion));
    MobMakerStartSummon(3, PlaceMobMaker(73, 15, SummonMobScorpion));
    MobMakerStartSummon(3, PlaceMobMaker(74, 23, SummonMobHorrendous));
    SetNextFunction(EndArea5);
}

int SummonMobStrongWizard(int sUnit)
{
    int unit = CreateObjectAtUnit("StrongWizardWhite", sUnit);

    UnitLinkBinScript(unit, StrongWizardWhiteBinTable());
    SetUnitMaxHealth(unit, 320);
    RetreatLevel(unit, 0.0);
    ResumeLevel(unit, 1.0);
    return unit;
}

void WizRunAway()
{
	if (UnitCheckEnchant(self, GetLShift(29)))
		EnchantOff(self, EnchantList(29));
}

int SummonMobRedWizard(int sUnit)
{
    int redWiz = CreateObjectAtUnit("WizardRed", sUnit);
    int uec = GetMemory(GetMemory(0x750710) + 0x2ec);

    UnitLinkBinScript(redWiz, WizardRedBinTable());
    SetUnitMaxHealth(redWiz, 411);
    SetCallback(redWiz, 8, WizRunAway);
    SetUnitStatus(redWiz, GetUnitStatus(redWiz) ^ 0x20);
    if (uec)
    {
        SetMemory(uec + 0x528, ToInt(1.0));
        SetMemory(uec + 0x520, ToInt(400.0));
        uec += 0x5d0;
        SetMemory(uec + GetSpellNumber("SPELL_LIGHTNING"), 0x40000000);
		SetMemory(uec + GetSpellNumber("SPELL_SHIELD"), 0x10000000);
        SetMemory(uec + GetSpellNumber("SPELL_SLOW"), 0x20000000);
		SetMemory(uec + GetSpellNumber("SPELL_INVISIBILITY"), 0x10000000);
		SetMemory(uec + GetSpellNumber("SPELL_FIREBALL"), 0x40000000);
        SetMemory(uec + GetSpellNumber("SPELL_INVERSION"), 0x8000000);
        SetMemory(uec + GetSpellNumber("SPELL_COUNTERSPELL"), 0x8000000);
    }
    return redWiz;
}

int SummonMobPlant(int sUnit)
{
    int mob = CreateObjectAtUnit("CarnivorousPlant", sUnit);

    UnitZeroFleeRange(mob);
    SetUnitSpeed(mob, 2.5);
    SetUnitMaxHealth(mob, 325);
    AggressionLevel(mob, 1.0);
    RetreatLevel(mob, 0.0);
    ResumeLevel(mob, 1.0);
    return mob;
}

void EndArea6()
{
    ClearWallAtWaypointPos(103);
    ClearWallAtWaypointPos(104);
    ClearWallAtWaypointPos(105);
    UniPrintToAll("좌측상단의 비밀벽 하나가 열렸습니다");
}

void EntryArea6()
{
    //100, 101// (98, 99)
    MobMakerStartSummon(1, PlaceMobMaker(100, 20, SummonMobStrongWizard));
    MobMakerStartSummon(1, PlaceMobMaker(101, 20, SummonBigFish));
    MobMakerStartSummon(10, PlaceMobMaker(98, 20, SummonLichMaster));
    MobMakerStartSummon(11, PlaceMobMaker(99, 20, SummonMobRedWizard));
    // MobMakerStartSummon(1, PlaceMobMaker(101, 20, Summon))
    SetNextFunction(EndArea6);
}

int SummonMobLich(int sUnit)
{
    int lich = CreateObjectAtUnit("Lich", sUnit);

    SetUnitMaxHealth(lich, 325);
    return lich;
}

void EndArea7()
{ }

void EntryArea7()
{
    MobMakerStartSummon(1, PlaceMobMaker(106, 20, SummonBigFish));
    MobMakerStartSummon(3, PlaceMobMaker(107, 20, SummonMobPlant));
    MobMakerStartSummon(5, PlaceMobMaker(108, 30, SummonMobGoon));
    MobMakerStartSummon(9, PlaceMobMaker(109, 30, SummonMobLich));

    SetNextFunction(EndArea7);
}

void Callee()
{
    Callee();
}

void CallFunction(int func)
{
    int link;

    if (!link)
        link = GetScrCodeField(Callee);
    SetMemory(link + 4, func);
    Callee();
}

int FloatToInt(float x)
{
    int i, result = 0;
    float pos = x;

    if (pos < 0.0) pos = -pos;
    pos = pos / 2147483648.0;
    if (pos < 2.0)
    {
        for (i = 0 ; i < 32 ; i ++)
        {
            if (pos >= 1.0)
            {
                result ++;
                pos -= 1.0;
            }
            if (i != 31) result = result << 1;
            pos *= 2.0;
        }
    }
    else result = 0x7fffffff;
    if (x < 0.0) return -result;
    else return result;
}

void WeaponClassCProperty1Entry(int wUnit, int slot, int execFunctionNumber, int tablePtr)
{
    int ptr = UnitToPtr(wUnit);

    if (ptr)
    {
        SetMemory(ptr + 0x2fc, execFunctionNumber);
        SetMemory(GetMemory(ptr + 0x2b4) + (slot * 4), tablePtr);
    }
}

int WeaponClassCProperty2Table()
{
    int dat[36], link;

    if (!link)
    {
        dat[0] = GetMemory(0x97bb40 + (SToInt("Fire4") * 4));
        dat[1] = 0x61; dat[6] = 0xb40000; dat[5] = 0x4b0; dat[7] = 0x1b2ff2; dat[9] = 1;
        //dat[13] = 0x4e04d0;
        dat[13] = WeaponClassCProperty1Code();
        dat[14] = ToInt(100.0); //dat[13] = 0x4e06f0; dat[13] = 0x4e0550;
        link = GetMemory(GetMemory(0x75ae28) + (0x30 * WeaponClassCProperty2Table) + 0x1c);
    }
    return link;
}

void WeaponClassCProperty2Entry(int ptr)
{
    int i;

    if (ptr)
    {
        SetMemory(GetMemory(ptr + 0x2b4) + 0, WeaponPower(5));
        SetMemory(GetMemory(ptr + 0x2b4) + 4, MaterialList(4));
        SetMemory(GetMemory(ptr + 0x2b4) + 8, WeaponClassCProperty2Table());
        SetMemory(GetMemory(ptr + 0x2b4) + 12, WeaponEffect(22));
        for (i = 31 ; i >= 0 ; i --)
            SetMemory(ptr + 0x230 + (i * 4), 0x200);
    }
}

int WeaponClassPropertyExecScript()
{
    int arr[13], link;

    if (!link)
    {
        arr[0] = 0x24448D50; arr[1] = 0xEC83520C; arr[2] = 0x85108B0C; arr[3] = 0x501C74D2; arr[4] = 0x02FC828B; arr[5] = 0x44890000;
        arr[6] = 0x89580424; arr[7] = 0x8B082454; arr[8] = 0x44890440; arr[9] = 0xE5E80424; arr[10] = 0x83FFDB62; arr[11] = 0x585A0CC4;
        arr[12] = 0x000090C3;
        link = GetScrDataField(WeaponClassPropertyExecScript);
        FixCallOpcode(link + 0x26, 0x507310);
    }
    return link;
}

int WeaponClassCProperty1Code()
{
    int code[21], call1 = 0x4e0702, call2 = 0x4e0722, call3 = 0x4e0731, nop;
    int link;

    if (!link)
    {
        link = GetScrDataField(WeaponClassCProperty1Code);
        OpcodeCopiesAdvance(link, link + (21 * 4), 0x4e06f0, 0x4e073c);

        SetMemory(link + 46, 0x83);
        SetMemory(link + 61, 97);
    }
    return link;
}

int WeaponClassCProperty3Table()
{
    int dat[36], link;

    if (!link)
    {
        dat[0] = GetMemory(0x97bb40 + (SToInt("Fire4") * 4));
        dat[1] = 0x61; dat[6] = 0xb40000; dat[5] = 0x4b0; dat[7] = 0x1b2ff2; dat[9] = 1;
        dat[10] = WeaponClassPropertyExecScript();
        dat[13] = WeaponClassCProperty1Code();
        dat[14] = ToInt(4.0);
        link = GetScrDataField(WeaponClassCProperty3Table);
    }
    return link;
}

int DummyUnitCreate(string name, float locX, float locY)
{
    int unit = CreateObjectAt(name, locX, locY);

    Damage(unit, 0, MaxHealth(unit) + 1, -1);
    ObjectOff(unit);
    Frozen(unit, 1);
    return unit;
}

void WispDestroyFx(float posX, float posY)
{
    int wispFx = CreateObjectAt("WillOWisp", posX, posY);

    UnitNoCollide(wispFx);
    ObjectOff(wispFx);
    Damage(wispFx, 0, 255, -1);
    DeleteObjectTimer(wispFx, 9);
}

void GreenSparkFx(float posX, float posY)
{
    int genHurt = CreateObjectAt("MonsterGenerator", posX, posY);

    Damage(genHurt, 0, 1, -1);
    Delete(genHurt);
}

void UnitVisibleSplashA()
{
    int parent = GetOwner(self);
    int spIdx = ToInt(GetObjectZ(parent + 1));

    if (CurrentHealth(GetOwner(parent)))
    {
        if (GetUnit1C(other) ^ spIdx)
        {
            if (Distance(GetObjectX(self), GetObjectY(self), GetObjectX(other), GetObjectY(other)) <= GetObjectX(parent))
            {
                Damage(other, GetOwner(parent), ToInt(GetObjectZ(parent)), 14);
                SetUnit1C(other, spIdx);
            }
        }
    }
}

void SplashDamageAt(int owner, int dam, float x, float y, float range)
{
    int ptr = CreateObjectAt("InvisibleLightBlueHigh", range, y) + 2, k, SplashIdx;

    SplashIdx ++;
    Raise(CreateObjectAt("InvisibleLightBlueHigh", GetObjectX(ptr), GetObjectY(ptr)), SplashIdx);
    SetOwner(owner, ptr - 2);
    Raise(ptr - 2, ToFloat(dam));
    for (k = 0 ; k < 4 ; k ++)
    {
        DeleteObjectTimer(CreateObjectAt("WeirdlingBeast", x, y), 1);
        UnitNoCollide(ptr + k);
        LookWithAngle(ptr + k, k * 64);
        SetOwner(ptr - 2, ptr + k);
        SetCallback(ptr + k, 3, UnitVisibleSplashA);
    }
    DeleteObjectTimer(ptr - 1, 2);
    DeleteObjectTimer(ptr - 2, 2);
}

/**
* @brief. strike a weapon handler
* @brief. self - the weapon
* @brief. other - the holder
*/
void XBowShot()     //@brief. WeaponProperty -3-
{
    int xbow = CreateObjectAt("ArcherArrow", GetObjectX(other) + UnitAngleCos(other, 8.0), GetObjectY(other) + UnitAngleSin(other, 8.0));

    SetOwner(other, xbow);
    LookWithAngle(xbow, GetDirection(other));
    Enchant(xbow, "ENCHANT_SHOCK", 0.0);
    PushObject(xbow, 34.0, GetObjectX(other), GetObjectY(other));
}

int PlaceArrowSword(int location)
{
    int arrow = CreateObjectAt("Sword", LocationX(location), LocationY(location));
    int ptr = GetMemory(0x750710);

    SetWeaponProperties(ptr, 5, 5, 8, 3);
    WeaponClassCProperty1Entry(arrow, 2, XBowShot, WeaponClassCProperty3Table());
    return arrow;
}

void EnergyparTouched()
{
    int owner = GetOwner(self);

    if (CurrentHealth(other) && IsAttackedBy(other, owner))
        Damage(other, owner, 100, 14);
}

void EnergyparFx(int helper)
{
    int owner = GetOwner(helper);

    Effect("EXPLOSION", GetObjectX(helper), GetObjectY(helper), 0.0, 0.0);

    int dmHelper = DummyUnitCreate("Demon", GetObjectX(helper), GetObjectY(helper));
    SetUnitFlags(dmHelper, GetUnitFlags(dmHelper) ^ 0x2000);    //NO_PUSH_CHARACTERS
    SetOwner(owner, dmHelper);
    SetCallback(dmHelper, 9, EnergyparTouched);
    DeleteObjectTimer(dmHelper, 1);
}

void EnergyparGoForward(int helper)
{
    int owner, durate;

    while (IsObjectOn(helper))
    {
        owner = GetOwner(helper);
        if (CurrentHealth(owner))
        {
            durate = GetDirection(helper);
            if (durate)
            {
                FrameTimerWithArg(1, helper, EnergyparGoForward);
                MoveObject(helper, GetObjectX(helper) + GetObjectZ(helper), GetObjectY(helper) + GetObjectZ(helper + 1));
                LookWithAngle(helper, durate - 1);
                EnergyparFx(helper);
                break;
            }
        }
        Delete(helper);
        Delete(helper + 1);
        break;
    }
}

void EnergyparShot()    //@brief. WeaponProperty -2-
{
    float vectX = UnitAngleCos(other, 13.0), vectY = UnitAngleSin(other, 13.0);
    int helper = CreateObjectAt("ImaginaryCaster", GetObjectX(other) + vectX, GetObjectY(other) + vectY);

    Raise(helper, vectY);
    Raise(CreateObjectAtUnit("ImaginaryCaster", other), vectX);
    LookWithAngle(helper, 15);
    SetOwner(other, helper);
    FrameTimerWithArg(1, helper, EnergyparGoForward);
}

int PlaceEnergyparAxe(int location)
{
    int par = CreateObjectAt("OgreAxe", LocationX(location), LocationY(location));
    int ptr = GetMemory(0x750710);

    SetWeaponProperties(ptr, 5, 5, 8, 3);
    WeaponClassCProperty1Entry(par, 2, EnergyparShot, WeaponClassCProperty3Table());
    return par;
}

void AngelCrystalCollide()
{
    int owner = GetOwner(GetTrigger() + 1);

    if (GetTrigger())
    {
        if (CurrentHealth(other) && IsAttackedBy(other, owner))
        {
            WispDestroyFx(GetObjectX(self), GetObjectY(self));
            SplashDamageAt(owner, 40, GetObjectX(self), GetObjectY(self), 50.0);
            Delete(self);
        }
    }
}

int AngelCrystal(int owner, float vectSize)
{
    int crystal = CreateObjectAt("GameBall", GetObjectX(owner) + UnitAngleCos(owner, vectSize), GetObjectY(owner) + UnitAngleSin(owner, vectSize));
    int ptr = GetMemory(0x750710);

    SetOwner(owner, CreateObjectAtUnit("InvisibleLightBlueLow", owner));
    SetMemory(ptr + 0x2b8, ImportUnitCollideFunc());
    SetMemory(ptr + 0x2fc, AngelCrystalCollide);
    DeleteObjectTimer(crystal, 90);
    DeleteObjectTimer(crystal + 1, 100);
    return crystal;
}

void ShotAngelCrystal() //@brief. WeaponProperty -1-
{
    PushObject(AngelCrystal(other, 19.0), 24.0, GetObjectX(other), GetObjectY(other));
    PlaySoundAround(other, 204);
    Effect("CYAN_SPARKS", GetObjectX(other), GetObjectY(other), 0.0, 0.0);
}

int PlaceAngelCrystalSword(int location)
{
    int angel = CreateObjectAt("GreatSword", LocationX(location), LocationY(location));
    int ptr = GetMemory(0x750710);

    SetWeaponProperties(ptr, 5, 5, 8, 3);
    WeaponClassCProperty1Entry(angel, 2, ShotAngelCrystal, WeaponClassCProperty3Table());
    return angel;
}

void PlaceDefaultItems(string itemname, object location)
{
    int i;
    
    for (i = 0 ; i < 8 ; i ++)
    {
        CreateObjectAt(itemname, LocationX(location), LocationY(location));
        TeleportLocationVector(location, 23.0, 23.0);
    }
}

int SingleShuriken(int owner, float posX, float posY)
{
    int mis = CreateObjectAt("OgreShuriken", posX, posY);
    int ptr = GetMemory(0x750710);

    SetMemory(GetMemory(ptr + 0x2bc) + 4, 60);
    PushObject(mis, -38.0, GetObjectX(owner), GetObjectY(owner));
    SetOwner(owner, mis);
    return mis;
}

void TripleShurikens(int dirUnit)
{
    int owner = GetOwner(dirUnit);

    if (CurrentHealth(dirUnit) && IsObjectOn(dirUnit))
    {
        int i;

        for (i = 0 ; i < 13 ; i ++)
        {
            SingleShuriken(owner, GetObjectX(dirUnit) + UnitAngleCos(dirUnit, 18.0), GetObjectY(dirUnit) + UnitAngleSin(dirUnit, 18.0));
            LookWithAngle(dirUnit, GetDirection(dirUnit) + 5);
        }
    }
    Delete(dirUnit);
}

void CastTripleShurikens()
{
    int dirUnit = CreateObjectAt("ImaginaryCaster", GetObjectX(other), GetObjectY(other));

    SetOwner(other, dirUnit);
    LookWithAngle(dirUnit, GetDirection(other) - 30);
    FrameTimerWithArg(1, dirUnit, TripleShurikens);
}

int PlaceTripleShurikenSword(int location)
{
    int triple = CreateObjectAt("GreatSword", LocationX(location), LocationY(location));
    int ptr = GetMemory(0x750710);

    SetWeaponProperties(ptr, 5, 5, 8, 3);
    WeaponClassCProperty1Entry(triple, 2, CastTripleShurikens, WeaponClassCProperty3Table());
    Enchant(triple, EnchantList(4), 0.0);
    return triple;
}

int PlaceSuperPowerSword(int location)
{
    int super = CreateObjectAt("GreatSword", LocationX(location), LocationY(location));
    int ptr = GetMemory(0x750710);

    WeaponClassCProperty2Entry(ptr);
    Enchant(super, EnchantList(4), 0.0);
    return super;
}

int MagicWeaponContainer()
{
    int count;
    int array[20];

    return GetScrDataField(MagicWeaponContainer);
}

//@brief. 컨테이너가 포함한 노드 수를 반환합니다
int WeaponContainerCount()
{
    return GetMemory(MagicWeaponContainer());
}

//@brief. 인덱스에 해당하는 노드를 컨테이너로 부터 얻습니다
object WeaponContainerNode(int index)
{
    if (index < 20)
    {
        int ptr = MagicWeaponContainer() + 4;
        object functionId = GetMemory(ptr + (index * 4));

        if (functionId)
            return functionId;
    }
    return 0;   //@brief. nullptr;
}

//@brief. 입력된 인덱스에 해당하는 설명 데이터를 가져옵니다
string WeaponContainerDesc(int index)
{
    object nodeId = WeaponContainerNode(index);

    if (nodeId > 0)
    {
        int ptr = GetScrDataField(nodeId);

        return ToStr(GetMemory(ptr));
    }
    return "null";
}

//@brief. 입력된 인덱스에 해당하는 가격 데이터를 가져옵니다
int WeaponContainerPay(int index)
{
    object nodeId = WeaponContainerNode(index);

    if (nodeId > 0)
    {
        int ptr = GetScrDataField(nodeId);

        return GetMemory(ptr + 4);
    }
    return -1;
}

//@brief. 입력된 인덱스에 해당하는 생성함수 객체를 가져옵니다
object WeaponContainerFunction(int index)
{
    object nodeId = WeaponContainerNode(index);

    if (nodeId > 0)
    {
        int ptr = GetScrDataField(nodeId);

        return GetMemory(ptr + 8);
    }
    return -1;
}

void WeaponContainerPushback(object function)
{
    int ptr = MagicWeaponContainer();
    int count = GetMemory(ptr);

    if (count < 20)
    {
        CallFunction(function);
        SetMemory(ptr, count + 1);
        SetMemory(ptr + 4 + (count * 4), function);
    }
}

int MagicWeaponClassArrowSword()
{
    string name = "에로우 서드";
    int pay = 20000;
    object createFunction = PlaceArrowSword;

    return GetScrDataField(MagicWeaponClassArrowSword);
}

int MagicWeaponClassTripleHammer()
{
    string name = "트리플 슈리켄 해머";
    int pay = 25500;
    object createFunction = PlaceTripleShurikenSword;

    return GetScrDataField(MagicWeaponClassTripleHammer);
}

int MagicWeaponClassEnergyparSword()
{
    string name = "에너지파 엑스칼리버";
    int pay = 28350;
    object createFunction = PlaceEnergyparAxe;

    return GetScrDataField(MagicWeaponClassEnergyparSword);
}

int MagicWeaponClassCrystalSword()
{
    string name = "지랄발광 수정구 서드";
    int pay = 26533;
    object createFunction = PlaceAngelCrystalSword;

    return GetScrDataField(MagicWeaponClassCrystalSword);
}

int MagicWeaponClassPowerfulSword()
{
    string name = "데미지 존나 쎈 서드";
    int pay = 24000;
    object createFunction = PlaceSuperPowerSword;

    return GetScrDataField(MagicWeaponClassPowerfulSword);
}

void InitWeaponContainer()
{
    WeaponContainerPushback(MagicWeaponClassArrowSword);
    WeaponContainerPushback(MagicWeaponClassCrystalSword);
    WeaponContainerPushback(MagicWeaponClassEnergyparSword);
    WeaponContainerPushback(MagicWeaponClassPowerfulSword);
    WeaponContainerPushback(MagicWeaponClassTripleHammer);
}

void ShopClassMagicWeaponDesc()
{
    int curIndex = GetDirection(self);
    string desc = WeaponContainerDesc(curIndex);

    if (desc != "null")
    {
        UniPrint(other, desc + " 을 구입하시겠어요? 가격은 " + IntToString(WeaponContainerPay(curIndex)) + " 골드 입니다");
        UniPrint(other, "구입하시려면 '예' 를 누르시고, 다른 아이템을 보시려면 '아니오'를 누르세요. 거래를 취소하려면 '떠나기'를 누릅니다");
        TellStoryUnitName("AA", "thing.db:IdentifyDescription", desc);
    }
}

void ShopClassMagicWeaponTrade()
{
    int dlgResult = GetAnswer(self), curIndex = GetDirection(self);

    if (dlgResult == 1)     //@brief. YES
    {
        int pay = WeaponContainerPay(curIndex);

        if (pay < 0)
            return;
        if (GetGold(other) >= pay)
        {
            ChangeGold(other, -pay);
            object resultFunction = WeaponContainerFunction(curIndex);

            if (resultFunction >= 0)
            {
                TeleportLocation(110, GetObjectX(other), GetObjectY(other));
                CallFunctionWithArgInt(resultFunction, 110);
            }
            // FrameTimerWithArg(1, resultItem, DelayForcePickItemToOwner);
            PlaySoundAround(other, 308);
            UniPrint(other, WeaponContainerDesc(curIndex) + " 거래가 완료되었습니다");
        }
        else
            UniPrint(other, "거래가 취소되었습니다. 잔액이 부족합니다");
    }
    else if (dlgResult == 2)    //@brief. NO
    {
        UniPrint(other, "'아니오'를 누르셨습니다. 다음 판매 품목을 보여드립니다");
        LookWithAngle(self, (curIndex + 1) % WeaponContainerCount());
        ShopClassMagicWeaponDesc();
    }
}

void ShopClassAllEnchantmentDesc()
{
    UniPrint(other, "올 엔첸트 능력을 구입하시겠어요? 가격은 6만 골드 입니다");
    UniPrint(other, "올 엔첸트 능력은 각종 유용한 버프가 당신에게 항상 지속됩니다");
    UniPrint(other, "계속 거래하기를 원하시면 '예' 을 누르세요");
    TellStoryUnitName("AA", "thing.db:IdentifyDescription", "올엔첸6만원");
}

void ShopClassAllEnchantmentTrade()
{
    if (GetAnswer(self) ^ 1)
        return;

    while (true)
    {
        if (GetGold(other) >= 60000)
        {
            int plr = CheckPlayer();

            if (plr < 0)
                break;
            if (PlayerClassCheckAllEnchant(plr))
            {
                UniPrint(other, "당신은 이미 이 능력의 소유자 입니다");
                break;
            }
            ChangeGold(other, -60000);
            PlayerClassSetAllEnchant(plr);
            PlayerAllEnchantment(other);
            UniPrint(other, "거래가 완료되었습니다. 올 엔첸트 능력은 이제 당신의 소유입니다");
            break;
        }
        UniPrint(other, "거래가 취소되었습니다. 사유: 잔액이 부족합니다");
        break;
    }
}

int ShopClassMagicalWeaponMarketCreate(int location)
{
    int keeper = DummyUnitCreate("Horrendous", LocationX(location), LocationY(location));

    CreateObjectAtUnit("ImaginaryCaster", keeper);
    LookWithAngle(keeper, 0);
    SetDialog(keeper, "YESNO", ShopClassMagicWeaponDesc, ShopClassMagicWeaponTrade);

    return keeper;
}

int ShopClassAllEnchantMarketCreate(int location)
{
    int allEnchantMarket = DummyUnitCreate("WizardGreen", LocationX(location), LocationY(location));

    SetDialog(allEnchantMarket, "YESNO", ShopClassAllEnchantmentDesc, ShopClassAllEnchantmentTrade);
    return allEnchantMarket;
}

void LightningShotCollide()
{
    if (GetTrigger() && GetCaller())
    {
        Damage(other, 0, 50, 9);
        Enchant(other, EnchantList(25), 2.0);
        Delete(self);
    }
}

int LightningShotSingle(float posX, float posY)
{
    int mis = CreateObjectAt("LightningBolt", posX, posY);
    int ptr = GetMemory(0x750710);

    SetMemory(ptr + 0x2b8, ImportUnitCollideFunc());
    SetMemory(ptr + 0x2fc, LightningShotCollide);
    return mis;
}

int LightningShooter(object baseUnit, float shotVectX, float shotVectY, float xVect, float yVect)
{
    int mis = LightningShotSingle(GetObjectX(baseUnit) + xVect, GetObjectY(baseUnit) + yVect);

    PushObjectTo(mis, shotVectX, shotVectY);
    return mis;
}

void LightningShotGunTrapArea1()
{
    int i, trpBase = CreateObjectAt("ImaginaryCaster", LocationX(52), LocationY(52));

    for (i = 0 ; i < 10 ; i ++)
        LightningShooter(trpBase + i, -32.0, 32.0, 13.0, 13.0);
    Delete(trpBase);
}

void UnitHealingHandler(int healing)
{
    int owner = GetOwner(healing);

    while (IsObjectOn(healing))
    {
        if (CurrentHealth(owner) && UnitCheckEnchant(owner, GetLShift(30)))
        {
            RestoreHealth(owner, 1);
            if (ToInt(DistanceUnitToUnit(owner, healing)))
                MoveObject(healing, GetObjectX(owner), GetObjectY(owner));
            FrameTimerWithArg(1, healing, UnitHealingHandler);
            break;
        }
        Delete(healing);
        break;
    }
}

void WellRefreshing()
{
    if (!UnitCheckEnchant(other, GetLShift(30)))
    {
        Enchant(other, EnchantList(30), 10.0);

        int healing = CreateObjectAtUnit("InvisibleLightBlueLow", other);
        SetOwner(other, healing);
        Enchant(healing, EnchantList(8), 0.0);
        FrameTimerWithArg(1, healing, UnitHealingHandler);

        PlaySoundAround(self, 1004);
        UniPrint(other, "우물의 마법이 잠시동안 당신을 지속적으로 치료해 줍니다");
    }
}

/*********
* monsterbin script section
*********/

int WizardRedBinTable()
{
	int arr[62], link;
	if (!link)
	{
		arr[0] = 1635412311; arr[1] = 1699898482; arr[2] = 100; arr[16] = 80000; arr[17] = 300; 
		arr[18] = 100; arr[19] = 50; arr[21] = 1065353216; arr[24] = 1067869798; arr[26] = 4; 
		arr[27] = 4; arr[53] = 1128792064; arr[54] = 4;
		link = GetScrDataField(WizardRedBinTable);
	}
	return link;
}

int LichLordBinTable()
{
	int arr[62], link;
	if (!link)
	{
		arr[0] = 1751345484; arr[1] = 1685221196; arr[17] = 473; arr[19] = 100; arr[21] = 1065353216; 
		arr[23] = 2048; arr[24] = 1065353216; arr[25] = 1; arr[26] = 4; arr[27] = 7; 
		arr[28] = 1108082688; arr[29] = 50; arr[30] = 1092616192; arr[32] = 19; arr[33] = 27; 
		arr[57] = 5548288; arr[59] = 5542784;
		link = GetScrDataField(LichLordBinTable);
	}
	return link;
}

void LichLordSubProcess(int sUnit)
{
	int ptr = UnitToPtr(sUnit);

	if (ptr)
	{
		SetMemory(ptr + 0x220, 1077936128);
		SetMemory(ptr + 0x224, 1077936128);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x5a0, 2048);
		//SetMemory(GetMemory(ptr + 0x22c), 300);
		//SetMemory(GetMemory(ptr + 0x22c) + 0x4, 300);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x1e4, LichLordBinTable());
		SetMemory(GetMemory(ptr + 0x2ec) + 0x54c, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x538, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x540, 1065353216);
	}
}

int FishBigBinTable()
{
	int arr[62], link;
	if (!link)
	{
		arr[0] = 1752394054; arr[1] = 6777154; arr[17] = 237; arr[18] = 1; arr[19] = 55; 
		arr[21] = 1065353216; arr[23] = 34816; arr[24] = 1073741824; arr[27] = 1; arr[28] = 1112014848; 
		arr[29] = 30; arr[31] = 8; arr[32] = 3; arr[33] = 7; arr[59] = 5542784; 
		arr[60] = 1329; arr[61] = 46905600; 
		link = GetMemory(GetMemory(0x75ae28) + (0x30 * FishBigBinTable + 0x1c));
	}
	return link;
}

void FishBigSubProcess(int sUnit)
{
	int ptr = UnitToPtr(sUnit);

	if (ptr)
	{
		SetMemory(ptr + 0x220, 1070805811);
		SetMemory(ptr + 0x224, 1070805811);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x5a0, 34816);
		SetMemory(GetMemory(ptr + 0x22c), 237);
		SetMemory(GetMemory(ptr + 0x22c) + 0x4, 237);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x1e4, FishBigBinTable());
		SetMemory(GetMemory(ptr + 0x2ec) + 0x54c, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x538, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x540, 1065353216);
	}
}

int StrongWizardWhiteBinTable()
{
	int arr[62], link;
	if (!link)
	{
		arr[0] = 1869771859; arr[1] = 1767335790; arr[2] = 1685217658; arr[3] = 1953065047; arr[4] = 101; 
		arr[19] = 1; arr[24] = 1065772646; arr[37] = 1701996870; arr[38] = 1819042146; arr[53] = 1128792064; 
		arr[55] = 20; arr[56] = 30; arr[57] = 5547984;
        link = GetScrDataField(StrongWizardWhiteBinTable);
	}
	return link;
}

int ScorpionBinTable()
{
	int arr[62], link;
	if (!link)
	{
		arr[0] = 1919902547; arr[1] = 1852795248; arr[17] = 275; arr[18] = 75; arr[19] = 75; 
		arr[21] = 1065353216; arr[24] = 1067869798; arr[25] = 1; arr[26] = 5; arr[27] = 5; 
		arr[28] = 1112014848; arr[29] = 30; arr[30] = 1101004800; arr[31] = 3; arr[32] = 22; 
		arr[33] = 30; arr[34] = 3; arr[35] = 5; arr[36] = 30; arr[59] = 5543344; 
		arr[60] = 1373; arr[61] = 46895952; 
		CancelTimer(FrameTimerWithArg(10, ScorpionBinTable, ScorpionBinTable));
		link = GetMemory(GetMemory(0x75ae28) + (0x30 * GetMemory(GetMemory(0x83395c) + 8) + 0x1c));
	}
	return link;
}

void ScorpionSubProcess(int sUnit)
{
	int ptr = UnitToPtr(sUnit);

	if (ptr)
	{
		SetMemory(ptr + 0x220, 1074790400);
		SetMemory(ptr + 0x224, 1074790400);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x5a0, 0);
		SetMemory(GetMemory(ptr + 0x22c), 275);
		SetMemory(GetMemory(ptr + 0x22c) + 0x4, 275);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x1e4, ScorpionBinTable());
		SetMemory(GetMemory(ptr + 0x2ec) + 0x54c, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x538, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x540, 1065353216);
	}
}

int WaspBinTable()
{
	int arr[62], link;
	if (!link)
	{
		arr[0] = 1886609751; arr[17] = 98; arr[18] = 1; arr[19] = 120; arr[21] = 1065353216; 
		arr[23] = 1; arr[24] = 1067869798; arr[27] = 5; arr[28] = 1097859072; arr[29] = 20; 
		arr[31] = 3; arr[34] = 2; arr[35] = 3; arr[36] = 20; arr[59] = 5544320; 
		arr[60] = 1331; arr[61] = 46900736; 
		CancelTimer(FrameTimerWithArg(10, WaspBinTable, WaspBinTable));
		link = GetMemory(GetMemory(0x75ae28) + (0x30 * GetMemory(GetMemory(0x83395c) + 8) + 0x1c));
	}
	return link;
}

void WaspSubProcess(int sUnit)
{
	int ptr = UnitToPtr(sUnit);

	if (ptr)
	{
		SetMemory(ptr + 0x220, 1080452710);
		SetMemory(ptr + 0x224, 1080452710);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x5a0, 1);
		SetMemory(GetMemory(ptr + 0x22c), 98);
		SetMemory(GetMemory(ptr + 0x22c) + 0x4, 98);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x1e4, WaspBinTable());
		SetMemory(GetMemory(ptr + 0x2ec) + 0x54c, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x538, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x540, 1065353216);
	}
}

int ImpBinTable()
{
	int arr[62], link;
	if (!link)
	{
		arr[0] = 7368009; arr[17] = 180; arr[18] = 1; arr[19] = 110; arr[21] = 1065353216; 
		arr[24] = 1065353216; arr[25] = 1; arr[26] = 5; arr[37] = 1769236816; arr[38] = 1181513062; 
		arr[39] = 1650815593; arr[40] = 7105633; arr[53] = 1128792064; arr[54] = 1; arr[55] = 9; 
		arr[56] = 17; arr[60] = 1328; arr[61] = 46904064; 
		CancelTimer(FrameTimerWithArg(10, ImpBinTable, ImpBinTable));
		link = GetMemory(GetMemory(0x75ae28) + (0x30 * GetMemory(GetMemory(0x83395c) + 8) + 0x1c));
	}
	return link;
}

void ImpSubProcess(int sUnit)
{
	int ptr = UnitToPtr(sUnit);

	if (ptr)
	{
		SetMemory(ptr + 0x220, 1079194419);
		SetMemory(ptr + 0x224, 1079194419);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x5a0, 0);
		SetMemory(GetMemory(ptr + 0x22c), 180);
		SetMemory(GetMemory(ptr + 0x22c) + 0x4, 180);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x1e4, ImpBinTable());
		SetMemory(GetMemory(ptr + 0x2ec) + 0x54c, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x538, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x540, 1065353216);
	}
}

int GoonBinTable()
{
	int arr[62], link;
	if (!link)
	{
		arr[0] = 1852796743; arr[17] = 85; arr[19] = 80; 
		arr[21] = 1065353216; arr[22] = 0; arr[23] = 32776; arr[24] = 1066192077; 
		arr[26] = 4; arr[27] = 0; arr[28] = 1106247680; arr[29] = 25; 
		arr[30] = 1092616192; arr[31] = 4; arr[32] = 20; arr[33] = 28; arr[34] = 2; 
		arr[35] = 3; arr[36] = 20; arr[57] = 5548176; arr[58] = 5546608; arr[59] = 5543680;
        link = GetScrDataField(GoonBinTable);
	}
	return link;
}

int BlackWidowBinTable()
{
	int arr[62], link;
	if (!link)
	{
		arr[0] = 1667329090; arr[1] = 1684625259; arr[2] = 30575; arr[17] = 180; arr[19] = 85; 
		arr[21] = 1065353216; arr[23] = 32768; arr[24] = 1065353216; arr[26] = 4; arr[27] = 3; 
		arr[28] = 1097859072; arr[29] = 25; arr[31] = 8; arr[32] = 13; arr[33] = 21; 
		arr[34] = 4; arr[35] = 2; arr[36] = 9; arr[37] = 1684631635; arr[38] = 1884516965; 
		arr[39] = 29801; arr[53] = 1128792064; arr[55] = 20; arr[56] = 28; arr[59] = 5544896; 
		arr[61] = 45071360; 
		link = GetMemory(GetMemory(0x75ae28) + (0x30 * BlackWidowBinTable + 0x1c));
	}
	return link;
}

void BlackWidowSubProcess(int sUnit)
{
	int ptr = UnitToPtr(sUnit);

	if (ptr)
	{
		SetMemory(ptr + 0x220, 1076048691);
		SetMemory(ptr + 0x224, 1076048691);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x5a0, 32768);
		SetMemory(GetMemory(ptr + 0x22c), 260);
		SetMemory(GetMemory(ptr + 0x22c) + 0x4, 260);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x1e4, BlackWidowBinTable());
		SetMemory(GetMemory(ptr + 0x2ec) + 0x54c, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x538, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x540, 1065353216);
	}
}

//sectionEnd

int DisposeBlockGroup(int baseLocation)
{
    int blocks = CreateObjectAt("ImaginaryCaster", LocationX(baseLocation), LocationY(baseLocation));

    CreateObjectAtUnit("ImaginaryCaster", blocks);
    Frozen(CreateObjectAt("SpikeBlock", LocationX(baseLocation), LocationY(baseLocation)), true);
    Frozen(CreateObjectAt("SpikeBlock", LocationX(baseLocation + 1), LocationY(baseLocation + 1)), true);
    Frozen(CreateObjectAt("SpikeBlock", LocationX(baseLocation + 2), LocationY(baseLocation + 2)), true);

    return blocks;
}

void SetBlockParams(int blocks, float vectX, float vectY, int moveDist)
{
    if (IsObjectOn(blocks))
    {
        LookWithAngle(blocks + 1, moveDist);
        Raise(blocks, vectX);
        Raise(blocks + 1, vectY);
    }
}

void InitBlocks()
{
    g_blockLeftUp = DisposeBlockGroup(55);
    g_blockLeftDown = DisposeBlockGroup(58);
    g_blockRightLeft = DisposeBlockGroup(61);
    g_blockRightRight = DisposeBlockGroup(64);

    SetBlockParams(g_blockLeftUp, 2.0, 2.0, 57);
    SetBlockParams(g_blockLeftDown, 2.0, -2.0, 57);
    SetBlockParams(g_blockRightLeft, 2.0, -2.0, 57);
    SetBlockParams(g_blockRightRight, -2.0, -2.0, 57);
}

void MoveObjectVector(int unit, float vectX, float vectY)
{
    int ptr = UnitToPtr(unit);

    if (ptr)
        MoveObject(unit, GetMemoryFloat(ptr + 0x38) + vectX, GetMemoryFloat(ptr + 0x3c) + vectY);
}

void BlockReset(int blocks)
{
    ObjectOn(blocks);
}

void BlockMovingCommon(int blocks)
{
    int durate = GetDirection(blocks);
    int obstacle = blocks + 2;

    if (durate)
    {
        float vectX = GetObjectZ(blocks);
        float vectY = GetObjectZ(blocks + 1);

        MoveObjectVector(obstacle, vectX, vectY);
        MoveObjectVector(obstacle + 1, vectX, vectY);
        MoveObjectVector(obstacle + 2, vectX, vectY);
        LookWithAngle(blocks, durate - 1);
        FrameTimerWithArg(1, blocks, BlockMovingCommon);
    }
    else
    {
        Raise(blocks, -GetObjectZ(blocks)); //direction swapping
        Raise(blocks + 1, -GetObjectZ(blocks + 1)); //direction swapping
        // LookWithAngle(blocks, GetDirection(blocks) ^ true);
        ObjectToggle(blocks + 1);
        if (!IsObjectOn(blocks + 1))
        {
            FrameTimerWithArg(30, blocks, BlockMovingCommon);
            LookWithAngle(blocks, GetDirection(blocks + 1));
            PlaySoundAround(obstacle, 882);
            Effect("JIGGLE", GetObjectX(obstacle), GetObjectY(obstacle), 17.0, 0.0);
        }
        else
            FrameTimerWithArg(30, blocks, BlockReset);
    }
}

void StartBlockMoving(int blocks)
{
    if (IsObjectOn(blocks))
    {
        ObjectOff(blocks);  //Lock
        LookWithAngle(blocks, GetDirection(blocks + 1));    //setCounter
        FrameTimerWithArg(1, blocks, BlockMovingCommon);
    }
}

void BlockPressLeft()
{
    int upRow = g_blockLeftUp;
    int downRow = g_blockLeftDown;

    if (IsObjectOn(upRow) && IsObjectOn(downRow))
    {
        PlaySoundAround(self, 910);
        StartBlockMoving(upRow);
        StartBlockMoving(downRow);
    }
}

void BlockPressRight()
{
    int leftRow = g_blockRightLeft;
    int rightRow = g_blockRightRight;

    if (IsObjectOn(leftRow) && IsObjectOn(rightRow))
    {
        PlaySoundAround(self, 910);
        StartBlockMoving(leftRow);
        StartBlockMoving(rightRow);
    }
}

void HorrendousElectricStrike()
{
    Damage(other, self, 30, 9);
    Effect("LIGHTNING", GetObjectX(self), GetObjectY(self), GetObjectX(other), GetObjectY(other));
    Effect("RICOCHET", GetObjectX(other), GetObjectY(other), 0.0, 0.0);
}

void FishBiteStrike()
{
    LinearOrbMove(CreateObjectAt("CharmOrb", GetObjectX(self), GetObjectY(self)), UnitRatioX(self, other, -1.0), UnitRatioY(self, other, -1.0), 3.0, 3);
    Damage(other, self, 6, 10);
}

int CallNode00549380()
{
    int link, node[4];

    if (!link)
    {
        node[0] = 0x549394;
        node[1] = 0x5493d0;
        node[2] = 0x52df80;
        node[3] = 0;    //nullptr
        link = GetScrDataField(CallNode00549380) + 4;
    }
    return link;
}

int MonsterStrikeHookSub()
{
    int arr[8], link;

    if (!link)
    {
        arr[0] = 0x02CC96FF; arr[1] = 0x51500000; arr[2] = 0x0000FFB8; arr[3] = 0x50565700; arr[4] = 0xDB623BE8; arr[5] = 0x0CC483FF; arr[6] = 0xFB685859; arr[7] = 0xC3005493;

        link = GetScrDataField(MonsterStrikeHookSub);
    }
    return link;
}

int MonsterStrikeCodeSection()
{
    int code[48];
}

int MonsterStrikeHandlerCopiedCode(int callback)
{
    int link; //192Bytes 0xc0
    int subPart;

    if (!link)
    {
        link = GetScrDataField(MonsterStrikeCodeSection);
        OpcodeCopiesAdvance(link, CallNode00549380(), 0x549380, 0x549434);
        subPart = MonsterStrikeHookSub();
        SetMemory(subPart + 27, link + 0x7b);
        SetMemory(subPart + 9, callback);
        FixCallOpcode(subPart + 16, 0x507310);

        SetMemory(link + 0x75, (GetMemory(link + 0x75) & (~0xff)) ^ 0x68);  //e8 xx xx xx xx
        SetMemory(link + 0x7a, (GetMemory(link + 0x7a) & (~0xff)) ^ 0xc3);
        SetMemory(link + 0x76, subPart);
    }
    return link;
}

void RegistUnitStrikeHook(int sUnit)
{
    int ptr = UnitToPtr(sUnit), temp, binScrPtr;

    if (ptr)
    {
        temp = GetMemory(ptr + 0x2ec);
        if (temp)
        {
            binScrPtr = GetMemory(GetMemory(ptr + 0x2ec) + 0x1e4);
            if (binScrPtr)
                SetMemory(binScrPtr + 0xec, MonsterStrikeHandlerCopiedCode(0));
        }
    }
}

void MonsterStrikeCallback()
{
    int thingId = GetUnitThingID(self);

    if (CurrentHealth(other))
    {
        if (thingId == 1386)
            HorrendousElectricStrike();
        else if (thingId == 1329)
            FishBiteStrike();
    }
}

void UrchinStoneCollide()
{
    int owner = GetOwner(self);

    if (GetTrigger())
    {
        if (CurrentHealth(other) && IsAttackedBy(other, owner))
        {
            Damage(other, self, 30, 9);
            Effect("RICOCHET", GetObjectX(other), GetObjectY(other), 0.0, 0.0);
            Delete(self);
        }
    }
}

void SpiderWebMissileCollide()
{
    int owner = GetOwner(self);

    if (GetTrigger())
    {
        if (CurrentHealth(other) && IsAttackedBy(other, owner))
        {
            Damage(other, self, 55, 5);
            DeleteObjectTimer(CreateObjectAt("GreenSmoke", GetObjectX(other), GetObjectY(other)), 9);
            Delete(self);
        }
    }
}

void UrchinStone(int missile)
{
    int ptr = UnitToPtr(missile);

    if (ptr)
    {
        SetMemory(ptr + 0x2b8, ImportUnitCollideFunc());
        SetMemory(ptr + 0x2fc, UrchinStoneCollide);
    }
    Enchant(missile, EnchantList(21), 0.0);
}

void SpiderWebMissile(int missile)
{
    int ptr = UnitToPtr(missile);

    if (ptr)
    {
        SetMemory(ptr + 0x2b8, ImportUnitCollideFunc());
        SetMemory(ptr + 0x2fc, SpiderWebMissileCollide);
    }
}

void HarpoonEvent(int missile)
{
    int ptr = UnitToPtr(missile);

    Enchant(missile, EnchantList(21), 0.0);
}

void DetectedSpecificIndex(int curId)
{
    int thingId = GetUnitThingID(curId);

    if (thingId == 524)
        SpiderWebMissile(curId);
    else if (thingId == 525)     //@brief. ThrowingStone
        UrchinStone(curId);
    else if (thingId == 526)
        HarpoonEvent(curId);
}

void LoopSearchIndex()
{
    int curId, tempId;
    int link;

    if (!link)
        link = GetScrDataField(LoopSearchIndex);
    while (Unknownb9(0x750710))
    {
        Unused59(link + 4, Unknownb9(Unknownb9(0x750710) + 0x2c));
        if (curId)
        {
            while (curId < tempId)
            {
                Unused59(link, curId + 1);
                DetectedSpecificIndex(curId);
            }
            break;
        }
        curId = tempId;
        break;
    }
    FrameTimer(1, LoopSearchIndex);
}

void RemoveMinesExitWalls()
{
    ObjectOff(self);

    int i;

    for (i = 0 ; i < 6 ; i ++)
    {
        ClearWallAtWaypointPos(71);
        TeleportLocationVector(71, 23.0, 23.0);
    }
    UniPrint(other, "우측 울타리가 낮아졌습니다");
}

string GeneratorUnitList()
{
    string units = {
        "WizardGreen", "Bear", "Imp", "Horrendous",
        "Archer", "Wizard", "Mimic", "UrchinShaman", "Demon"
    };
    return units;
}

int CreateGenerator(int index, int location)
{
    string genName = ToStr(SToInt(GeneratorUnitList()) + (index % 9)) + "Generator";
    int gen = CreateObjectAt(genName, LocationX(location), LocationY(location));

    if (gen)
    {
        SetUnitMass(gen, 25.0);
        ObjectOff(gen);
        Enchant(gen, EnchantList(23), 0.0);
    }
    return gen;
}

string GetGeneratorUnitname(int index)
{
    return ToStr(SToInt(GeneratorUnitList()) + (index % 9));
}

void AfterInitPuzzle()
{
    int i;

    for (i = 0 ; i < 9 ; i ++)
    {
        int index = g_mixGenPuzzle[i + 1];

        DummyUnitCreate(GetGeneratorUnitname(index), LocationX(77 + i), LocationY(77 + i));
        g_genPuzzleBeacon[index] = Object("PuzBeacon" + IntToString(i + 1));
    }
}

void GenPuzzleMix()
{
    int i, pic, max = g_mixGenPuzzle[0], temp;

    for (i = 1 ; i <= max ; i ++)
    {
        pic = Random(1, max);
        if (i ^ pic)
        {
            temp = g_mixGenPuzzle[i];
            g_mixGenPuzzle[i] = g_mixGenPuzzle[pic];
            g_mixGenPuzzle[pic] = temp;
        }
    }
}

void InitializeGenerators()
{
    int gen = CreateObjectAt("ImaginaryCaster", LocationX(86), LocationY(86));
    int i;

    g_mixGenPuzzle[0] = 9;  //@brief. set pad count
    for (i = 0 ; i < 9 ; i ++)
    {
        CreateGenerator(i, i + 86);
        g_mixGenPuzzle[i + 1] = i;
    }
    GenPuzzleMix();
    GenPuzzleMix();
    GenPuzzleMix();

    g_puzzleGens = gen + 1;
    FrameTimer(1, AfterInitPuzzle);
}

int CheckPuzzleSolved()
{
    int i, result = 0;

    for (i = 0 ; i < 9 ; i ++)
    {
        if (DistanceUnitToUnit(g_puzzleGens + i, g_genPuzzleBeacon[i]) < 46.0)
            result ++;
    }
    return result;
}

void RemoveSouthWalls()
{
    int i;

    for (i = 21 ; i ; i --)
    {
        ClearWallAtWaypointPos(95);
        TeleportLocationVector(95, -23.0, 23.0);
    }
}

void PuzzleGenHolding(int i)
{
    ObjectOff(g_genPuzzleBeacon[i]);
    MoveObject(g_puzzleGens + i, GetObjectX(g_genPuzzleBeacon[i]), GetObjectY(g_genPuzzleBeacon[i]));
    Frozen(g_puzzleGens + i, true);
}

void PuzzleSolved() //21, 95
{
    int i;

    for (i = 0 ; i < 9 ; i ++)
        PuzzleGenHolding(i);
    FrameTimer(15, RemoveSouthWalls);
    Effect("WHITE_FLASH", GetObjectX(self), GetObjectY(self), 0.0, 0.0);
    PlaySoundAround(self, 795);
    UniPrintToAll("모든 비밀이 풀렸습니다. 남쪽 벽이 개방되었습니다");
    ObjectOn(g_ternnelSwitch);
    EnchantOff(g_ternnelSwitch, EnchantList(0));
}

void PressedGenPuzzleBeacon()
{
    if (HasClass(other, "MONSTERGENERATOR"))
    {
        if (CheckPuzzleSolved() ^ g_mixGenPuzzle[0])
            Effect("YELLOW_SPARKS", GetObjectX(self), GetObjectY(self), 0.0, 0.0);
        else
            PuzzleSolved();
    }
}

void ClearTernnelWalls()
{
    ObjectOff(self);

    int i;

    for (i = 11 ; i ; i --)
    {
        ClearWallAtWaypointPos(96);
        ClearWallAtWaypointPos(97);
        TeleportLocationVector(96, -23.0, 23.0);
        TeleportLocationVector(97, -23.0, 23.0);
    }
}

void ResetHostileCritter()
{
	SetMemory(0x833e64, 0x55b);		//CarnivorousPlant
	SetMemory(0x833e70, 1329);		//FishBig
	SetMemory(0x833e74, 1330);		//FishSmall
	SetMemory(0x833e78, 1359);		//Rat
	SetMemory(0x833e7c, 1313);		//GreenFrog
}

void SetHostileCritter()
{
	SetMemory(0x833e64, 0x540);		//CarnivorousPlant
	SetMemory(0x833e70, 0x540);		//FishBig
	SetMemory(0x833e74, 0x540);		//FishSmall
	SetMemory(0x833e78, 0x540);		//Rat
	SetMemory(0x833e7c, 0x540);		//GreenFrog
}

int ImportOrbMoveFunc()
{
	int arr[6], link;

	if (!link)
	{
		arr[0] = 0x52353068; arr[1] = 0x72506800; arr[2] = 0x14FF0050; arr[3] = 0x54FF5024; arr[4] = 0xC4830824; arr[5] = 0x9090C30C;
		link = GetScrDataField(ImportOrbMoveFunc);
	}
	return link;
}

void LinearOrbMove(int unit, float x_vect, float y_vect, float speed, int time)
{
	int ptr = UnitToPtr(unit), temp = GetMemory(0x5c336c);

	if (ptr)
	{
		SetMemory(ptr + 0x50, ToInt(x_vect));
		SetMemory(ptr + 0x54, ToInt(y_vect));
		SetMemory(ptr + 0x70, ToInt(speed));
		SetMemory(0x5c336c, ImportOrbMoveFunc());
		Unknownb8(ptr);
		SetMemory(0x5c336c, temp);
		DeleteObjectTimer(unit, time);
	}
}

void TestFunction()
{
    ObjectOff(self);
    // FrameTimer(30, EntryArea6);
}