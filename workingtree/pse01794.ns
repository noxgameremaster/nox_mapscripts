
int XMonStat = 0;
int XMainFlag = 0;
int player[20];
int XTelpo;
int XItemNode;
int XCreCount = 0;
int EnableMemoryReadWriteFunction(int t) {}

/****
def BitShow(num):
	bitArr=[]
	t=1<<31
	for i in range(32):
		if num&t:
			bitArr.append(1)
		else:
			bitArr.append(0)
		t=t>>1
	print(bitArr)
****/

int CreClassGetCurrentCount()
{
    return XCreCount & 0x1f;
}

void CreClassSetCurrentCount(int setTo)
{
    XCreCount = (XCreCount & (~0x1f)) ^ setTo;
}

void CreClassIncreaseCurrentCount()
{
    CreClassSetCurrentCount(CreClassGetCurrentCount() + 1);
}

void CreClassDecreaseCurrentCount()
{
    if (CreClassGetCurrentCount())
        CreClassSetCurrentCount(CreClassGetCurrentCount() - 1);
}

void MoveObjectVector(int target, float xVect, float yVect)
{
    int ptr = UnitToPtr(target);

    if (ptr)
        MoveObject(target, GetMemoryFloat(ptr + 0x38) + xVect, GetMemoryFloat(ptr + 0x3c) + yVect);
}

int LineStatClassMobCountCheck()
{
    return XMonStat & 0xffff;
}

int LineStatClassKillCountCheck()
{
    return XMonStat >> 0x10;
}

void LineStatClassMobCountSet(int amount)
{
    XMonStat = (XMonStat & (~0xffff)) ^ amount;
}

void LineStatClassKillCountSet(int amount)
{
    XMonStat = (XMonStat & 0xffff) ^ (amount << 0x10);
}

int GameClassMobAccessCheck()
{
    return XMainFlag & 0xf;
}

void GameClassMobAccessSet(int setTo)
{
    XMainFlag = (XMainFlag & (~0xf)) ^ (setTo & 0xf);
}

int GameClassLifeCheck()
{
    return XMainFlag >> 0x18;
}

void GameClassLifeSet(int setTo)
{
    XMainFlag = (XMainFlag & 0xffffff) ^ ((setTo & 0xff) << 0x18);
}

int GameClassWaveCheck()
{
    return (XMainFlag >> 0x10) & 0xff;
}

void GameClassWaveSet(int setTo)
{
    XMainFlag = (XMainFlag & 0xff00ffff) ^ ((setTo & 0xfff) << 0x10);
}

int GameClassMainIsShutdown()
{
    return XMainFlag & 0x10;
}

void GameClassMainSetShutdown()
{
    XMainFlag = XMainFlag ^ 0x10;
}

int GameClassLineIsStart()
{
    return XMainFlag & 0x20;
}

void GameClassLineStartSet()
{
    XMainFlag = XMainFlag ^ 0x20;
}

int ToInt(float arg)
{
    StopScript(arg);
}

float ToFloat(int x)
{
    StopScript(x);
}

string ToStr(int x)
{
    StopScript(x);
}

int SToInt(string x)
{
    StopScript(x);
}

int ImportUnitToPtrFunc()
{
    int arr[10], ptr, link;

    if (!link)
    {
        arr[0] = 0x50725068; arr[1] = 0x2414FF00; arr[2] = 0x511B6068; arr[3] = 0x54FF5000; arr[4] = 0xC4830424;
        arr[5] = 0x7230680C; arr[6] = 0xFF500050; arr[7] = 0x83042454; arr[8] = 0xC03108C4; arr[9] = 0x909090C3;
        link = GetScrDataField(ImportUnitToPtrFunc);
    }
    return link;
}

int UnitToPtr(int unit)
{
    int temp = GetMemory(0x5c336c), res;
    SetMemory(0x5c336c, ImportUnitToPtrFunc());
    res = Unknownb8(unit);
    SetMemory(0x5c336c, temp);
	return res;
}

int ImportCreateAtFunc()
{
    int arr[20], link;

    if (!link)
    {
        arr[0] = 0xAA506856; arr[1] = 0x5068004D; arr[2] = 0xFF005072; arr[3] = 0xFF502414; arr[4] = 0x50042454;
        arr[5] = 0x082454FF; arr[6] = 0x4085048B; arr[7] = 0x680097BB; arr[8] = 0x004E3810; arr[9] = 0x2454FF50;
        arr[10] = 0x08C48304; arr[11] = 0xF685F08B; arr[12] = 0x006A0A74; arr[13] = 0x2454FF56; arr[14] = 0x08C48314;
        arr[15] = 0x50723068; arr[16] = 0x54FF5600; arr[17] = 0xC4830424; arr[18] = 0x5EC03118; arr[19] = 0x909090C3;
        link = GetScrDataField(ImportCreateAtFunc);
    }
    return link;
}

int CreateObjectAt(string name, float x, float y)
{
    int temp = GetMemory(0x5c3160), res;

    SetMemory(0x5c3160, ImportCreateAtFunc());
    res = CreateMover(SToInt(name), ToInt(x), y);
    SetMemory(0x5c3160, temp);
    if (res) return GetMemory(res + 0x2c);
    else return 0;
}

int GetMemory(int addr)
{
    return Unknownb9(addr);
}

float GetMemoryFloat(int addr)
{
    StopScript(Unknownb9(addr));
}

void SetMemory(int addr, int value)
{
    Unused59(addr, value);
}

int GetOwner(int unit)
{
    int ptr = UnitToPtr(unit), res;

    if (ptr)
    {
        res = GetMemory(ptr + 0x1fc);
        if (res)
            return GetMemory(res + 0x2c);
    }
    return 0;
}

string StringOverflow(int t)
{
	return ToStr((t - 0x97bb40) / 4);
}

string EnchantList(int sNumber)
{
	return StringOverflow(0x596f24 + (sNumber * 4));
}

int UnitCheckEnchant(int sUnit, int sMagicFlag)
{
    int ptr = UnitToPtr(sUnit);

    if (ptr)
        return GetMemory(ptr + 0x154) & sMagicFlag;
    return 0;
}

int GetLShift(int sCount)
{
    return (1 << sCount);
}

void SetUnitEnchantCopy(int sUnit, int sMagicFlag)
{
	int ptr = UnitToPtr(sUnit);

	if (ptr)
	{
		Enchant(sUnit, EnchantList(6), 0.0);
		SetMemory(ptr + 0x154, GetMemory(ptr + 0x154) | sMagicFlag);
	}
}

void UnitSetEnchantTime(int unit, int enchantNumber, int durateTime)
{
	int ptr = UnitToPtr(unit), temp, tempPtr;

	if (ptr)
	{
		SetUnitEnchantCopy(unit, GetLShift(enchantNumber));
		tempPtr = ptr + 0x158 + ((enchantNumber / 2) * 4);
		temp = GetMemory(tempPtr);
		if (enchantNumber % 2)
		{
			SetMemory(tempPtr, (GetMemory(tempPtr) & 0xffff) | (durateTime << 0x10));
		}
		else
			SetMemory(tempPtr, ((GetMemory(tempPtr) >> 0x10) << 0x10) | durateTime);
	}
}

int MapWaypointTable(int idx)
{
    int table[600];

    return table[idx - 1];
}

float LocationX(int location)
{
    StopScript(GetMemory(MapWaypointTable(location) + 8));
}

float LocationY(int location)
{
    StopScript(GetMemory(MapWaypointTable(location) + 12));
}

void TeleportLocation(int location, float xProfile, float yProfile)
{
    int wTable = MapWaypointTable(location);

    SetMemory(wTable + 8, ToInt(xProfile));
    SetMemory(wTable + 12, ToInt(yProfile));
}

void TeleportLocationVector(int location, float xVect, float yVect)
{
    int wTable = MapWaypointTable(location);

    SetMemory(wTable + 8, ToInt(ToFloat(GetMemory(wTable + 8)) + xVect));
    SetMemory(wTable + 12, ToInt(ToFloat(GetMemory(wTable + 12)) + yVect));
}

void MapWaypointFill(int wAddr, int tPtr)
{
    int num;

    if (wAddr)
    {
        num = GetMemory(wAddr);
        SetMemory(tPtr + (num * 4), wAddr);
        MapWaypointFill(GetMemory(wAddr + 484), tPtr);
    }
}

void MapWaypointInit()
{
    MapWaypointFill(GetMemory(0x83c7fc), GetScrDataField(MapWaypointTable));
}

int ImportUseItemFunc()
{
    int arr[10], link;

    if (!link)
    {
        arr[0] = 0x50731068; arr[1] = 0x50565500; arr[2] = 0x1424748B; arr[3] = 0x18246C8B;
        arr[4] = 0x02FC858B; arr[5] = 0x56550000; arr[6] = 0x2454FF50; arr[7] = 0x0CC48318;
        arr[8] = 0x835D5E58; arr[9] = 0x90C304C4;
        link = GetScrDataField(ImportUseItemFunc);
    }
    return link;
}

void SetUnitStatus(int unit, int stat)
{
    int temp, ptr = UnitToPtr(unit);

    if (ptr)
    {
        temp = GetMemory(ptr + 0x2ec);
        if (temp)
            SetMemory(temp + 0x5a0, stat);
    }
}

int GetUnitStatus(int unit)
{
    int temp, ptr = UnitToPtr(unit);

    if (ptr)
    {
        temp = GetMemory(ptr + 0x2ec);
        if (temp)
            return GetMemory(temp + 0x5a0);
    }
    return 0;
}

int ImportUnitCollideFunc()
{
    int arr[10], link;

    if (!link)
    {
        arr[0] = 0x50731068; arr[1] = 0x50565500; arr[2] = 0x14246C8B; arr[3] = 0x1824748B;
        arr[4] = 0x02FC858B; arr[5] = 0x56550000; arr[6] = 0x2454FF50; arr[7] = 0x0CC48318;
        arr[8] = 0x835D5E58; arr[9] = 0x90C304C4;
        link = GetScrDataField(ImportUnitCollideFunc);
    }
    return link;
}

int ImportUniChatCore()
{
    int arr[10], link;

    if (!link)
    {
        arr[0] = 0xC0685657; arr[1] = 0x6800528A; arr[2] = 0x00507250; arr[3] = 0x8B2414FF; arr[4] = 0x2414FFF8;
        arr[5] = 0x14FFF08B; arr[6] = 0x56505724; arr[7] = 0x102454FF; arr[8] = 0x5E14C483; arr[9] = 0x9090C35F;
        link = GetScrDataField(ImportUniChatCore);
    }
    return link;
}

void UniChatCore(int plrPtr, int sPtr, int sTime)
{
    int temp = GetMemory(0x5c3320);

    SetMemory(0x5c3320, ImportUniChatCore());
    GroupRunAway(sPtr, plrPtr, sTime);
    SetMemory(0x5c3320, temp);
}

int ImportUniPrintCore()
{
    int arr[8], link;

    if (!link)
    {
        arr[0] = 0x9EB06856; arr[1] = 0x5068004D; arr[2] = 0xFF005072; arr[3] = 0xF08B2414; arr[4] = 0x502414FF;
        arr[5] = 0x2454FF56; arr[6] = 0x10C4830C; arr[7] = 0x9090C35E;
        link = GetScrDataField(ImportUniPrintCore);
    }
    return link;
}

void UniPrintCore(int plrPtr, int sPtr)
{
    int temp = GetMemory(0x5c31f4);

    SetMemory(0x5c31f4, ImportUniPrintCore());
    Unused5a(sPtr, plrPtr);
    SetMemory(0x5c31f4, temp);
}

int GetByteValue(int ptr)
{
    return GetMemory(ptr) & 0xff;
}

void WriteAddressWordValue(int addr, int word)
{
    int temp = GetMemory(addr) & 0xffff0000;
    SetMemory(addr, temp | word);
}

void NoxUtf8ToUnicode(int src, int dest)
{
    int i = 0, byt;

    while (1)
    {
        byt = GetByteValue(src + i);
        if (!byt) break;
        if (!(byt & 0x80))
        {
            WriteAddressWordValue(dest, byt);
            i ++;
        }
        else if ((byt & 0xe0) == 0xc0)
        {
            WriteAddressWordValue(dest, ((byt & 0x1f) <<6) | (GetByteValue(src + i + 1) & 0x3f));
            i += 2;
        }
        else if ((byt & 0xf0) == 0xe0)
        {
            WriteAddressWordValue(dest, ((byt & 0xf) << 12) | ((GetByteValue(src + i + 1) & 0x3f) << 6) | (GetByteValue(src + i + 2) & 0x3f));
            i += 3;
        }
        dest += 2;
    }
    WriteAddressWordValue(dest, 0);
}

void UniPrint(int sUnit, string sMsg)
{
    int wDest[200];
    int ptr = UnitToPtr(sUnit), str = SToInt(sMsg), link;

    if (ptr)
    {
        str = GetMemory(0x97bb40 + (str * 4));
        if (!link)
            link = GetScrDataField(UniPrint);
        NoxUtf8ToUnicode(str, link + 8);
        UniPrintCore(ptr, link + 8);
    }
}

void UniChatMessage(int sUnit, string sMsg, int duration)
{
    int wDest[200];
    int ptr = UnitToPtr(sUnit), str = SToInt(sMsg), link;

    if (ptr)
    {
        str = GetMemory(0x97bb40 + (str * 4));
        if (!link)
            link = GetScrDataField(UniChatMessage);
        NoxUtf8ToUnicode(str, link + 12);
        UniChatCore(ptr, link + 12, duration);
    }
}

void UniPrintToAll(string sMsg)
{
    int wDest[200];
    int plrPtr = 0x62f9e0, link, str = SToInt(sMsg), i;

    if (!link)
        link = GetScrDataField(UniPrint) + 4;
    str = GetMemory(0x97bb40 + (str * 4));
    NoxUtf8ToUnicode(str, link);
    for (i = 0 ; i < 32 ; i ++)
    {
        if (GetMemory(plrPtr))
            UniPrintCore(GetMemory(plrPtr), link);
        plrPtr += 0x12dc;
    }
}

int MathAbs(int num)
{
    return ((num >> 30) | 1) * num;
}

int CheckSignDelay(int sPtr, int gap)
{
    int cFps = GetMemory(0x84ea04);

    if (MathAbs(cFps - GetMemory(sPtr)) > gap)
    {
        SetMemory(sPtr, cFps);
        return 1;
    }
    return 0;
}

void SignNotification()
{
    int otPtr = GetMemory(0x979720), sePtr = GetMemory(0x979724);

    if (otPtr && sePtr)
    {
        if (IsPlayerUnit(other))
        {
            if (CheckSignDelay(GetMemory(sePtr + 0x2e0) + 100, 60))
                UniPrint(other, ToStr(GetMemory(sePtr + 0x2f0)));
        }
    }
}

void RegistSignMessage(int sUnit, string sMsg)
{
    int ptr = UnitToPtr(sUnit), str = SToInt(sMsg);

    if (ptr)
    {
        SetMemory(ptr + 0x2f0, str);
        SetMemory(ptr + 0x2dc, ImportUseItemFunc());
        SetMemory(ptr + 0x2fc, SignNotification);
    }
}

void SetUnitFlags(int unit, int flag)
{
	int ptr = UnitToPtr(unit);

    if (ptr)
        SetMemory(ptr + 0x10, flag);
}

int GetUnitFlags(int unit)
{
	int ptr = UnitToPtr(unit);

    if (ptr)
        return GetMemory(ptr + 0x10);
    return 0;
}

void UnitNoCollide(int unit)
{
    SetUnitFlags(unit, GetUnitFlags(unit) ^ 0x40);
}

int IsPlayerUnit(int sUnit)
{
    int ptr = UnitToPtr(sUnit);

    if (ptr)
        return GetMemory(ptr + 0x08) & 0x04;
    return 0;
}

int IsMonsterUnit(int sUnit)
{
    int ptr = UnitToPtr(sUnit);

    if (ptr)
        return GetMemory(ptr + 0x08) & 0x02;
    return 0;
}

int GetWordValue(int num)
{
	return num & 0xffff;
}

void WriteAddressByteValue(int addr, int byt)
{
	int temp = GetMemory(addr) & 0xffffff00;
	SetMemory(addr, temp | byt);
}

int NoxUnicodeToUtf8(int src, int destPtr)
{
	int i, byt, dest = destPtr;

	for (i = 0 ; i < 20 ; i ++)
	{
		byt = GetWordValue(GetMemory(src));
        if (!byt) break;
		if (byt < 0x80)
		{
			WriteAddressByteValue(dest, byt);
			dest ++;
		}
		else if (byt < 0x800)
		{
			WriteAddressByteValue(dest, ((byt >> 6) & 0x1f) | 0xc0);
			WriteAddressByteValue(dest + 1, (byt & 0x3f) | 0x80);
			dest += 2;
		}
		else
		{
			WriteAddressByteValue(dest, ((byt >> 12) & 0x0f) | 0xe0);
			WriteAddressByteValue(dest + 1, ((byt >> 6) & 0x3f) | 0x80);
			WriteAddressByteValue(dest + 2, (byt & 0x3f) | 0x80);
			dest += 3;
		}
        src += 2;
	}
    WriteAddressByteValue(dest, 0);
	return dest - destPtr;
}

string PlayerIngameNick(int sUnit)
{
    string emptyName = {
        "00:01234567890123456789abcd0123456789abxyz", "01:01234567890123456789abcd0123456789abxyz",
        "02:01234567890123456789abcd0123456789abxyz", "03:01234567890123456789abcd0123456789abxyz",
        "04:01234567890123456789abcd0123456789abxyz", "05:01234567890123456789abcd0123456789abxyz",
        "06:01234567890123456789abcd0123456789abxyz", "07:01234567890123456789abcd0123456789abxyz",
        "08:01234567890123456789abcd0123456789abxyz", "09:01234567890123456789abcd0123456789abxyz",
        "10:01234567890123456789abcd0123456789abxyz", "11:01234567890123456789abcd0123456789abxyz",
        "12:01234567890123456789abcd0123456789abxyz", "13:01234567890123456789abcd0123456789abxyz",
        "14:01234567890123456789abcd0123456789abxyz", "15:01234567890123456789abcd0123456789abxyz",
        "16:01234567890123456789abcd0123456789abxyz", "17:01234567890123456789abcd0123456789abxyz",
        "18:01234567890123456789abcd0123456789abxyz", "19:01234567890123456789abcd0123456789abxyz",
        "20:01234567890123456789abcd0123456789abxyz", "21:01234567890123456789abcd0123456789abxyz",
        "22:01234567890123456789abcd0123456789abxyz", "23:01234567890123456789abcd0123456789abxyz",
        "24:01234567890123456789abcd0123456789abxyz", "25:01234567890123456789abcd0123456789abxyz",
        "26:01234567890123456789abcd0123456789abxyz", "27:01234567890123456789abcd0123456789abxyz",
        "28:01234567890123456789abcd0123456789abxyz", "29:01234567890123456789abcd0123456789abxyz",
        "30:01234567890123456789abcd0123456789abxyz", "31:01234567890123456789abcd0123456789abxyz"};
    int ptr = UnitToPtr(sUnit), plrIndex, destPtr, srcPtr;
    
    if (ptr)
    {
        if (GetMemory(ptr + 0x08) & 4)
        {
            plrIndex = GetMemory(GetMemory(GetMemory(ptr + 0x2ec) + 0x114) + 0x810);
            destPtr = GetMemory(0x97bb40 + ((SToInt(emptyName) + plrIndex) * 4));
            srcPtr = GetMemory(GetMemory(ptr + 0x2ec) + 0x114) + 0x889;
            NoxUnicodeToUtf8(srcPtr, destPtr);
            return ToStr(SToInt(emptyName) + plrIndex);
        }
    }
    return "NULL";
}

int GetUnit1C(int sUnit)
{
    int ptr = UnitToPtr(sUnit);

    if (ptr)
        return GetMemory(ptr + 0x1c);
    return 0;
}

void SetUnit1C(int sUnit, int sData)
{
    int ptr = UnitToPtr(sUnit);

    if (ptr)
        SetMemory(ptr + 0x1c, sData);
}

int VoiceList(int num)
{
    int list[75], addr, k;

    if (!list[0])
    {
        addr = GetMemory(0x663eec);
        for (k = 0 ; k < 75 ; k ++)
        {
            list[k] = addr;
            addr = GetMemory(addr + 0x4c);
        }
    }
    return list[num];
}

void MapExit()
{
    MusicEvent();
    RemoveCoopTeamMode();
    SelfDamageClassMapExit();
    ResetHostileCritter();
}

float UnitRatioX(int unit, int target, float size)
{
    return (GetObjectX(unit) - GetObjectX(target)) * size / Distance(GetObjectX(unit), GetObjectY(unit), GetObjectX(target), GetObjectY(target));
}

float UnitRatioY(int unit, int target, float size)
{
    return (GetObjectY(unit) - GetObjectY(target)) * size / Distance(GetObjectX(unit), GetObjectY(unit), GetObjectX(target), GetObjectY(target));
}

float WayRatioX(int wp1, int wp2)
{
    return (GetWaypointX(wp1) - GetWaypointX(wp2)) * 1.0 / Distance(GetWaypointX(wp1), GetWaypointY(wp1), GetWaypointX(wp2), GetWaypointY(wp2));
}

float WayRatioY(int wp1, int wp2)
{
    return (GetWaypointY(wp1) - GetWaypointY(wp2)) * 1.0 / Distance(GetWaypointX(wp1), GetWaypointY(wp1), GetWaypointX(wp2), GetWaypointY(wp2));
}

float GetSineValue(int wp, float c)
{
    float x_ratio = WayRatioX(wp, wp + 1), y_ratio = WayRatioY(wp, wp + 1), res;

    res = GetWaypointX(wp) - GetWaypointX(wp + 1);
    MoveWaypoint(wp + 1, GetWaypointX(wp) - (c * y_ratio) - x_ratio, GetWaypointY(wp) + (c * x_ratio) - y_ratio);
    return res;
}

float MathSine(int angle, float size)
{
    float var_0[91];
    int i, k;
 
    if (!ToInt(var_0[90]))
    {
        TeleportLocation(angle + 1, LocationX(angle), LocationY(angle) - 1.0);
        for (i = 0 ; i <= 90 ; i ++)
        {
            var_0[i] = GetSineValue(angle, size);
            Delete(k + i + 1);
        }
        return var_0[0];
    }
    k = angle / 90;
    i = angle - (k * 90);

    if (k % 2) i = 90 - i;
    if ((angle / 180) % 2) return -var_0[i] * size;
	else return var_0[i] * size;
}

float UnitAngleCos(int unit, float size)
{
    return MathSine((GetDirection(unit) * 45 / 32) + 90, size);
}

float UnitAngleSin(int unit, float size)
{
    return MathSine(GetDirection(unit) * 45 / 32, size);
}

int ImportMemAlloc()
{
    int arr[7], link;

    if (!link)
    {
        arr[0] = 0x49E85055; arr[1] = 0x50FFDB62; arr[2] = 0xCB2553E8; arr[3] = 0x1DE850FF; arr[4] = 0x83FFDB62; arr[5] = 0x5D5808C4; arr[6] = 0x909090C3;
        link = GetScrDataField(ImportMemAlloc);
        FixCallOpcode(link + 2, 0x507250);
        FixCallOpcode(link + 8, 0x403560);
        FixCallOpcode(link + 0x0e, 0x507230);
    }
    return link;
}

int MemAlloc(int size)
{
    int temp = GetMemory(0x5c3208), ptr;

    SetMemory(0x5c3208, ImportMemAlloc());
    ptr = GetCharacterData(size);
    SetMemory(0x5c3208, temp);
    return ptr;
}

int ImportMemFree()
{
    int arr[5], link, fNumb;

    if (!link)
    {
        arr[0] = 0x624AE850; arr[1] = 0xE850FFDB; arr[2] = 0xFFCB3251; arr[3] = 0x5804C483; arr[4] = 0x909090C3;
        fNumb = GetMemory(0x979740 + ((GetMemory(0x75ae40) - 4) * 4));
        link = GetMemory(GetMemory(0x75ae28) + (0x30 * ImportMemFree + 0x1c));
        FixCallOpcode(link + 1, 0x507250);
        FixCallOpcode(link + 7, 0x40425d);
    }
    return link;
}

void MemFree(int ptr)
{
    int temp = GetMemory(0x5c3108);

    SetMemory(0x5c3108, ImportMemFree());
    Unused1f(ptr);
    SetMemory(0x5c3108, temp);
}

void MapInitialize()
{
    int var0 = EnableMemoryReadWriteFunction(0);

    FrameTimer(1, DelayInitRun);

    MusicEvent();
    RewardItemFunctionTable(-1);
    ImportCreateAtFunc();
    ImportUnitToPtrFunc();
    MapWaypointInit();
    ImportStreamCopy();
    MathSine(1, 1.0 / 57.3);
    ImportUniChatCore();
    ImportUniPrintCore();
    ImportUnitCollideFunc();
    ImportUseItemFunc();
    ImportCheckSelfDamage();
    ImportPlaySoundAround();
    ImportTellStoryUniNamePartA();
    ImportTellStoryUniNamePartB();
    ImportMonsterStrikeFunc();
    ImportMemAlloc();
    ImportMemFree();
    CallFunctionWithArg(0, 0);
    CallFunctionWithArgInt(0, 0);
    CallFunctionWithTwoArg(0, 0, 0);
    PlayerClassDieHandlerInit(913);
    PlayerUpdate4f8100();
    ImportRemoveSneakDelay();
    VoiceList(0);
    FrameTimer(2, SetGameTypeCoopMode);
}

int MakeMagicMissileScrPt(string misName, int owner)
{
    float xVect = UnitAngleCos(owner, 18.0), yVect = UnitAngleSin(owner, 18.0);
    int target = CreateObjectAt("ImaginaryCaster", GetObjectX(owner) + (xVect * 10.0), GetObjectY(owner) + (yVect * 10.0));
    int mis = CreateObjectAt(misName, GetObjectX(owner) + xVect, GetObjectY(owner) + yVect);
    int ptr = GetMemory(0x750710);
    int ecPtr;
    int casterPtr = UnitToPtr(target);

    DeleteObjectTimer(target, 3);
    if (ptr)
    {
        SetOwner(owner, mis);
        SetMemory(ptr + 0x220, ToInt(3.3)); //Speed
        SetMemory(ptr + 0x224, 0); //accel
        ecPtr = MemAlloc(20);
        SetMemory(ecPtr, UnitToPtr(owner));
        SetMemory(ecPtr + 4, casterPtr);
        SetMemory(ptr + 0x2ec, ecPtr);
        SetMemory(ptr + 0x2e8, 5488032);
    }
    return GetMemory(GetMemory(0x75ae28) + (0x30 * MakeMagicMissileScrPt + 0x1c)) + 0x14;
}

void ImpShotCollide()
{
    int owner = GetOwner(self);

    while (owner)
    {
        if (CurrentHealth(other) && IsAttackedBy(other, owner))
        {
            Damage(other, owner, 48, 1);
            Effect("EXPLOSION", GetObjectX(self), GetObjectY(self), 0.0, 0.0);
        }
        else if (!GetCaller())
            1;
        else
            break;
        Delete(self);
        break;
    }
}

void LoopCatchImpshot(int curId)
{
    int owner = GetOwner(curId);
    int scrPt = MakeMagicMissileScrPt("DeathBallFragment", owner);
    int mis = GetMemory(scrPt), ptr = GetMemory(scrPt + 4);

    SetMemory(ptr + 0x2b8, ImportUnitCollideFunc());
    SetMemory(ptr + 0x2fc, ImpShotCollide);
    Delete(curId);
}

void SpiderWebCollide()
{
    int owner = GetOwner(self);

    while (owner)
    {
        if (CurrentHealth(other) && IsAttackedBy(other, owner))
        {
            Damage(other, owner, 99, 0);
            Enchant(other, EnchantList(4), 3.0);
            if (IsPlayerUnit(other))
                UniPrint(other, "거미줄이 당신의 움직임을 둔화 시키고 있습니다");
        }
        else if (!GetCaller())
            1;
        else
            break;
        Delete(self);
        break;
    }
}

void LoopCatchSpiderWeb(int curId)
{
    int ptr = UnitToPtr(curId);

    if (ptr)
    {
        SetMemory(ptr + 0x2b8, ImportUnitCollideFunc());
        SetMemory(ptr + 0x2fc, ImpShotCollide);
    }
}

void DetectedSpecficIndex(int curId)
{
    int thingID = GetUnitThingID(curId);

    if (thingID == 708) //ImpShot
        LoopCatchImpshot(curId);
    else if (thingID == 524)
        LoopCatchSpiderWeb(curId);
    else if (thingID == 526)
        HarpoonEvent(GetOwner(curId), curId);
    else if (thingID == 1177)
        ChakramOnThrow(curId);
    else if (thingID == 706)
        ShotSmallDeathBall(GetOwner(curId), curId);
    else if (thingID == 709)
        ShotMagicMissile(GetOwner(curId), curId);
}

void IndexSearchBuffRepeat(int curId, int lessons)
{
    if (curId < lessons)
    {
        DetectedSpecficIndex(curId + 1);
        IndexSearchBuffRepeat(curId + 1, lessons);
    }
}

void LoopSearchIndex()
{
    int curId, tempId;

    while (GetMemory(0x750710))
    {
        tempId = GetMemory(GetMemory(0x750710) + 0x2c);
        if (curId)
        {
            if (curId < tempId)
                IndexSearchBuffRepeat(curId, tempId);
            else
                break;
        }
        curId = tempId;
        break;
    }
    FrameTimer(1, LoopSearchIndex);
}

int CheckPlayer()
{
    int i;

    for (i = 9 ; i >= 0 ; i --)
    {
        if (IsCaller(player[i]))
            return i;
    }
    return -1;
}

int CheckPlayerScrIndex(int pUnit)
{
    int i;

    for (i = 9 ; i >= 0 ; i --)
    {
        if (!(player[i] ^ pUnit))
            return i;
    }
    return -1;
}

int PlayerClassItemTable()
{
    int itemTable[8000];
}

int VaildPlayerCheck(int plrUnit)
{
    int plrArr[32], pIndex = GetPlayerIndex(plrUnit);

    if (pIndex >= 0)
    {
        if (plrUnit ^ plrArr[pIndex])
        {
            plrArr[pIndex] = plrUnit;
            return 1;
        }
    }
    return 0;
}

int PlayerClassOnInit(int pUnit, int plr)
{
    int res = plr;

    player[plr] = pUnit;
    player[plr + 10] = 1;
    EmptyAll(pUnit);
    if (VaildPlayerCheck(pUnit))
    {
        if (pUnit ^ GetHost())
            ClientEntry(pUnit);
        else
            PlayerClassCommonWhenEntry();
        FrameTimerWithArg(60, pUnit, NetPlayBgm);
        SelfDamageClassEntry(pUnit);
        DiePlayerHandlerEntry(pUnit);
        res |= (1 << 8);
    }
    ChangeGold(pUnit, -GetGold(pUnit));
    FrameTimerWithArg(90, pUnit, UserShowGameInfo);
    return res;
}

void RespawnPlayer(int location, int pUnit)
{
    MoveObject(pUnit, LocationX(location), LocationY(location));
    PlaySoundAround(pUnit, 6);
    DeleteObjectTimer(CreateObjectAt("BlueRain", LocationX(location), LocationY(location)), 21);
    Effect("TELEPORT", LocationX(location), LocationY(location), 0.0, 0.0);
}

void PlayerClassOnJoin(int pUnit, int plr)
{
    if (PlayerClassDeathFlagCheck(plr))
        PlayerClassDeathFlagSet(plr);
    Enchant(pUnit, EnchantList(25), 2.0);
    Enchant(pUnit, EnchantList(14), 0.0);
    RespawnPlayer(15, pUnit);
}

void PlayerClassOnFailedEntry(int pUnit)
{
    if (GameClassMainIsShutdown())
    {
        MoveObject(pUnit, LocationX(30), LocationY(30));
        UniPrint(pUnit, "게임 오버. ..");
    }
    else
    {
        MoveObject(pUnit, LocationX(13), LocationY(13));
        UniPrint(pUnit, "지도 입장에 실패하였습니다");
    }
}

void TeleportPlayer(int pArg)
{
    int location = pArg & 0x3ff, plr = (pArg >> 10) & 0x3ff;
    int pUnit = player[plr];

    if (CurrentHealth(pUnit))
        MoveObject(pUnit, LocationX(location), LocationY(location));
}

void PlayerClassFirstJoin(int pUnit, int plr)
{
    MoveObject(pUnit, LocationX(13), LocationY(13));
    FrameTimerWithArg(5, (plr << 10) | 11, TeleportPlayer);
    UniPrint(pUnit, "지도에 입장을 시도하고 있습니다... 잠시만 기다려 주세요");
}

void PlayerClassEntry()
{
    int i, plr;

    while (1)
    {
        if (CurrentHealth(other) && !GameClassMainIsShutdown())
        {
            plr = CheckPlayer();
            for (i = 9 ; i >= 0 && plr < 0 ; i --)
            {
                if (!MaxHealth(player[i]))
                {
                    plr = PlayerClassOnInit(GetCaller(), i);
                    break;
                }
            }
            if (plr + 1)
            {
                if (plr >> 8)
                    PlayerClassFirstJoin(other, plr & 0xff);
                else
                    PlayerClassOnJoin(other, plr);
                break;
            }
        }
        PlayerClassOnFailedEntry(other);
        break;
    }
}

void PlayerClassFastJoin()
{
    int pIndex;

    if (CurrentHealth(other))
    {
        pIndex = CheckPlayer();
        if (pIndex + 1)
            MoveObject(other, LocationX(11), LocationY(11));
        else
            MoveObject(other, LocationX(12), LocationY(12));
    }
}

void AbilityAwardFx(int sUnit)
{
    PlaySoundAround(sUnit, 226);
    GreenSparkFx(GetObjectX(sUnit), GetObjectY(sUnit));
    Effect("WHITE_FLASH", GetObjectX(sUnit), GetObjectY(sUnit), 0.0, 0.0);
}

void WarAbilityAwardWarcry(int owner, int plr)
{
    if (PlayerClassSkillFlagCheck2(plr))
        UniPrint(owner, "이미 이 능력을 배우셨습니다 -향상된 전쟁의 함성");
    else
    {
        PlayerClassSkillFlagSet2(plr);
        AbilityAwardFx(owner);
        UniPrint(owner, "향상된 전쟁의 함성을 배우셨습니다! 주변 유닛 데미지 85");
    }
}

void WarAbilityAwardHarpoon(int owner, int plr)
{
    if (PlayerClassSkillFlagCheck3(plr))
        UniPrint(owner, "이미 이 능력을 배우셨습니다 -향상된 작살");
    else
    {
        PlayerClassSkillFlagSet3(plr);
        AbilityAwardFx(owner);
        Enchant(owner, EnchantList(30), 0.0);
        UniPrint(owner, "향상된 작살을 배우셨습니다! 일직선 범위 데미지 100");
    }
}

void WarAbilityAwardThreadLigthly(int owner, int plr)
{
    if (PlayerClassSkillFlagCheck1(plr))
        UniPrint(owner, "이미 이 능력을 배우셨습니다 -윈드 부스터");
    else
    {
        PlayerClassSkillFlagSet1(plr);
        AbilityAwardFx(owner);
        UniPrint(owner, "윈드 부스터을 배우셨습니다! 짧은 거리를 빠르게 이동합니다");
    }
}

void BookOfAbilityCheck(int curId, int owner)
{
    int ptr = UnitToPtr(curId), type;
    int plr = CheckPlayerFromUnitId(owner);

    if (ptr && plr + 1)
    {
        while (1)
        {
            type = GetMemory(GetMemory(ptr + 0x2e0)) & 0xff;
            if (type == 2)
                WarAbilityAwardWarcry(owner, plr);
            else if (type == 3)
                WarAbilityAwardHarpoon(owner, plr);
            else if (type == 4)
                WarAbilityAwardThreadLigthly(owner, plr);
            else
                break;
            Delete(curId);
            break;
        }
    }
}

void InventoryChecking(int pUnit)
{
    int inv = GetLastItem(pUnit);

    if (GetUnitThingID(inv) == 2676)
        BookOfAbilityCheck(inv, pUnit);
}

void UserPoisonedHandler(int sPlr)
{
    int arr[10], plrUnit = player[sPlr];

    if (UnitCheckEnchant(plrUnit, GetLShift(18)))
    {
        if (IsPoisonedUnit(plrUnit))
        {
            CastSpellObjectObject("SPELL_CURE_POISON", plrUnit, plrUnit);
            Effect("VIOLET_SPARKS", GetObjectX(plrUnit), GetObjectY(plrUnit), 0.0, 0.0);
        }
    }
    else if (IsPoisonedUnit(plrUnit))
    {
        if (arr[sPlr] < 60)
            arr[sPlr] += IsPoisonedUnit(plrUnit);
        else
        {
            Damage(plrUnit, 0, IsPoisonedUnit(plrUnit), 5);
            arr[sPlr] = 0;
        }
    }
    else if (arr[sPlr])
        arr[sPlr] = 0;
}

void PlayerClassStatCheck(int plr)
{
    int pUnit = player[plr];

    InventoryChecking(pUnit);
    UserPoisonedHandler(plr);
    if (UnitCheckEnchant(pUnit, GetLShift(31)))
    {
        EnchantOff(pUnit, EnchantList(31));
        RemoveTreadLightly(pUnit);
        if (PlayerClassSkillFlagCheck1(plr))
            SkillSetWindBooster(pUnit);
    }
    if (PlayerClassSkillFlagCheck2(plr))
    {
        WarAbilityUse(pUnit, 2, SkillSetWarCry);
    }
}

void SkillSetWindBooster(int pUnit)
{
    PushObjectTo(pUnit, UnitAngleCos(pUnit, 80.0), UnitAngleSin(pUnit, 80.0));
    Effect("RICOCHET", GetObjectX(pUnit), GetObjectY(pUnit), 0.0, 0.0);
}

void ManaBombCancelFx(int sUnit)
{
    int caster = CreateObjectAt("ImaginaryCaster", GetObjectX(sUnit), GetObjectY(sUnit));

    CastSpellObjectObject("SPELL_MANA_BOMB", caster, caster);
    Delete(caster);
}

void UnitVisibleSplashA()
{
    int parent = GetOwner(self);
    int spIdx = ToInt(GetObjectZ(parent + 1));

    if (CurrentHealth(GetOwner(parent)))
    {
        if (GetUnit1C(other) ^ spIdx)
        {
            if (Distance(GetObjectX(self), GetObjectY(self), GetObjectX(other), GetObjectY(other)) <= GetObjectX(parent))
            {
                Damage(other, GetOwner(parent), ToInt(GetObjectZ(parent)), 14);
                SetUnit1C(other, spIdx);
            }
        }
    }
}

void SplashDamageAt(int owner, int dam, float x, float y, float range)
{
    int ptr = CreateObjectAt("InvisibleLightBlueHigh", range, y) + 2, k, SplashIdx;

    SplashIdx ++;
    Raise(CreateObjectAt("InvisibleLightBlueHigh", GetObjectX(ptr), GetObjectY(ptr)), SplashIdx);
    SetOwner(owner, ptr - 2);
    Raise(ptr - 2, ToFloat(dam));
    for (k = 0 ; k < 4 ; k ++)
    {
        DeleteObjectTimer(CreateObjectAt("WeirdlingBeast", x, y), 1);
        UnitNoCollide(ptr + k);
        LookWithAngle(ptr + k, k * 64);
        SetOwner(ptr - 2, ptr + k);
        SetCallback(ptr + k, 3, UnitVisibleSplashA);
    }
    DeleteObjectTimer(ptr - 1, 2);
    DeleteObjectTimer(ptr - 2, 2);
}

void SkillSetWarCry(int pUnit)
{
    SplashDamageAt(pUnit, 130, GetObjectX(pUnit), GetObjectY(pUnit), 200.0);
    ManaBombCancelFx(pUnit);
    UniChatMessage(pUnit, "프리 홍콩!! 타이완 넘버 원!!", 120);
}

int GetPlayerIndex(int plrUnit)
{
    int ptr = UnitToPtr(plrUnit);

    if (ptr)
        return GetMemory(GetMemory(GetMemory(ptr + 0x2ec) + 0x114) + 0x810);
    return -1;
}

int WarAbilityTable(int aSlot, int pIndex)
{
    return GetMemory(0x753600 + (pIndex * 24) + (aSlot * 4));
}

void WarAbilityUse(int pUnit, int aSlot, int actionFunction)
{
    int chk[160], pIndex = GetPlayerIndex(pUnit), cTime;
    int arrPic;

    if (!(pIndex >> 0x10))
    {
        arrPic = pIndex * 5 + aSlot; //EyeOf=5, harpoon=3, sneak=4, berserker=1
        cTime = WarAbilityTable(aSlot, pIndex);
        if (cTime ^ chk[arrPic])
        {
            if (!chk[arrPic])
            {
                CallFunctionWithArg(actionFunction, pUnit);
            }
            chk[arrPic] = cTime;
        }
    }
}

int PlayerClassDeathFlagCheck(int pIndex)
{
    return player[pIndex + 10] & 0x02;
}

void PlayerClassDeathFlagSet(int pIndex)
{
    player[pIndex + 10] = player[pIndex + 10] ^ 0x02;
}

int PlayerClassSkillFlagCheck1(int pIndex)
{
    return player[pIndex + 10] & 0x04;
}

void PlayerClassSkillFlagSet1(int pIndex)
{
    player[pIndex + 10] = player[pIndex + 10] ^ 4;
}

int PlayerClassSkillFlagCheck2(int pIndex)
{
    return player[pIndex + 10] & 0x08;
}

void PlayerClassSkillFlagSet2(int pIndex)
{
    player[pIndex + 10] = player[pIndex + 10] ^ 8;
}

int PlayerClassSkillFlagCheck3(int pIndex)
{
    return player[pIndex + 10] & 0x10;
}

void PlayerClassSkillFlagSet3(int pIndex)
{
    player[pIndex + 10] = player[pIndex + 10] ^ 0x10;
}

void ProtectItemTryPick()
{
    int cFps, ptr;

    if (IsPlayerUnit(other))
    {
        ptr = UnitToPtr(self);
        while (1)
        {
            if (GetOwner(self) ^ GetCaller())
            {
                cFps = GetMemory(0x84ea04);
                if (!GetMemory(ptr + 0x2f4))
                    SetMemory(ptr + 0x2f4, cFps);
                if (MathAbs(cFps - GetMemory(ptr + 0x2f4)) >= 90)
                    1;
                else
                {
                    UniPrint(other, "아직 이 아이템을 픽업하실 수 없습니다. 소유자가 있는 아이템 입니다");
                    break;
                }
            }
            SetMemory(ptr + 0x2c4, GetMemory(ptr + 0x1c));
            SetMemory(ptr + 0x1c, 0);
            SetMemory(ptr + 0x228, 0);
            SetMemory(ptr + 0x2f4, 0);
            Pickup(other, self);
            break;
        }
    }
}

void LaiserParTouch()
{
    int owner = ToInt(GetObjectZ(GetOwner(self)));

    if (IsAttackedBy(other, owner) && CurrentHealth(other))
    {
        Damage(other, owner, 100, 14);
        Enchant(other, EnchantList(28), 0.5);
    }
}

void HarpoonEvent(int owner, int curId)
{
    float xVect, yVect;
    int i, unit;

    if (UnitCheckEnchant(owner, GetLShift(30)))
    {
        xVect = UnitAngleCos(owner, 30.0);
        yVect = UnitAngleSin(owner, 30.0);

        Delete(curId);
        TeleportLocation(1, GetObjectX(owner) + xVect, GetObjectY(owner) + yVect);
        unit = CreateObjectAt("InvisibleLightBlueLow", LocationX(1), LocationY(1)) + 1;
        Raise(unit - 1, owner);
        for (i = 0 ; i < 15 ; i ++)
        {
            Frozen(CreateObjectAt("Maiden", LocationX(1), LocationY(1)), 1);
            SetCallback(unit + i, 9, LaiserParTouch);
            SetUnitFlags(unit + i, GetUnitFlags(unit + i) ^ 0x2000);
            SetOwner(unit - 1, unit + i);
            DeleteObjectTimer(unit + i, 1);
            PlaySoundAround(unit + i, 299);
            TeleportLocationVector(1, xVect, yVect);
        }
        DeleteObjectTimer(unit - 1, 30);
        Effect("SENTRY_RAY", GetObjectX(unit - 1), GetObjectY(unit - 1), LocationX(1), LocationY(1));
    }
}

void ChakramOnThrow(int curId)
{
    //
}

void ShotSmallDeathBall(int owner, int curId)
{
    //
}

void ShotMagicMissile(int owner, int curId)
{
    //
}

int ImportUnitPickupFunc()
{
    int arr[10], link;

    if (!link)
    {
        arr[0] = 0x50731068; arr[1] = 0x55565300; arr[2] = 0x14245C8B; arr[3] = 0x1824748B;
        arr[4] = 0x0228AE8B; arr[5] = 0x53560000; arr[6] = 0x2454FF55; arr[7] = 0x0CC48318;
        arr[8] = 0x835B5E5D; arr[9] = 0x90C304C4;
        link = GetMemory(GetMemory(0x75ae28) + (0x30 * ImportUnitPickupFunc + 0x1c));
    }
    return link;
}

void PlayerClassOnDeath(int pIndex)
{
    UniPrintToAll(PlayerIngameNick(player[pIndex]) + " 님께서 적에게 격추되었습니다");
}

void PlayerClassOnFree(int pIndex)
{
    player[pIndex] = 0;
    player[pIndex + 10] = 0;
}

void PlayerClassLoop()
{
    int i;

    for (i = 9 ; i >= 0 ; i --)
    {
        while (1)
        {
            if (MaxHealth(player[i]))
            {
                if (GetUnitFlags(player[i]) & 0x40)
                    1;
                else if (CurrentHealth(player[i]))
                {
                    PlayerClassStatCheck(i);
                    break;
                }
                else
                {
                    if (!PlayerClassDeathFlagCheck(i))
                    {
                        PlayerClassDeathFlagSet(i);
                        PlayerClassOnDeath(i);
                    }
                    break;
                }
            }
            if (player[i + 10])
                PlayerClassOnFree(i);
            break;
        }
    }
    FrameTimer(1, PlayerClassLoop);
}

void CalleeArg(int arg)
{
    CalleeArg(arg);
}

void CallFunctionWithArg(int func, int arg)
{
    int link;

    if (!link)
        link = GetMemory(GetMemory(0x75ae28) + (0x30 * CalleeArg + 0x20));
    else
    {
        SetMemory(link + 0x10, func);
        CalleeArg(arg);
    }
}

void CalleeTwoArg(int arg1, int arg2)
{
    CalleeTwoArg(arg1, arg2);
}

void CallFunctionWithTwoArg(int func, int arg1, int arg2)
{
    int link;

    if (!link)
        link = GetMemory(GetMemory(0x75ae28) + (0x30 * CalleeTwoArg + 0x20));
    else
    {
        SetMemory(link + 0x1c, func);
        CalleeTwoArg(arg1, arg2);
    }
}

int CalleeArgInt(int arg)
{
    return CalleeArgInt(arg);
}

int CallFunctionWithArgInt(int func, int arg)
{
    int link;

    if (!link)
    {
        link = GetMemory(GetMemory(0x75ae28) + (0x30 * CalleeArgInt + 0x20));
        return 0;
    }
    else
    {
        SetMemory(link + 0x10, func);
        return CalleeArgInt(arg);
    }
}

int ImportRemoveSneakDelay()
{
    int arr[7], link;

    if (!link)
    {
        arr[0] = 0x72506850; arr[1] = 0x14FF0050; arr[2] = 0xC3006824; arr[3] = 0x046A004F; arr[4] = 0x2454FF50; arr[5] = 0x10C48308; arr[6] = 0x9090C358;
        link = GetMemory(GetMemory(0x75ae28) + (0x30 * ImportRemoveSneakDelay + 0x1c));
    }
    return link;
}

void RemoveTreadLightly(int plrUnit)
{
    int ptr = UnitToPtr(plrUnit), temp = GetMemory(0x5c336c);

    if (ptr)
    {
        if (GetMemory(ptr + 0x08) & 0x04)
        {
            SetMemory(0x5c336c, ImportRemoveSneakDelay());
            Unknownb8(ptr);
            SetMemory(0x5c336c, temp);
        }
    }
}

int ImportPlayerAutoTeamSign()
{
    int arr[17], link;

    if (!link)
    {
        arr[0] = 0x4191D068; arr[1] = 0x50515600; arr[2] = 0x000020B9; arr[3] = 0xF9E0B800; arr[4] = 0xC9850062;
        arr[5] = 0x8B492774; arr[6] = 0x12DC0530; arr[7] = 0xF6850000; arr[8] = 0x5150F074; arr[9] = 0x8D24468B;
        arr[10] = 0x016A304E; arr[11] = 0x51016A50; arr[12] = 0x54FF016A; arr[13] = 0xC4832824; arr[14] = 0xEB585914;
        arr[15] = 0x5E5958D5; arr[16] = 0xC304C483;
        link = GetMemory(GetMemory(0x75ae28) + (0x30 * ImportPlayerAutoTeamSign + 0x1c));
    }
    return link;
}

void PlayerAutoTeamSign()
{
    int temp = GetMemory(0x5c31cc);

    SetMemory(0x5c31cc, ImportPlayerAutoTeamSign());
    Unused50();
    SetMemory(0x5c31cc, temp);
}

void MakeCoopTeam()
{
    int arr[3];
    int teamCount = GetMemory(0x654D5C), temp, link;

    if (!teamCount && !link)
    {
        arr[0] = 0x417E1068; arr[1] = 0x2414FF00; arr[2] = 0xC304C483;
        link = GetScrDataField(MakeCoopTeam);
        temp = GetMemory(0x5c31cc);
        SetMemory(0x5c31cc, link);
        Unused50();
        SetMemory(0x5c31cc, temp);
        SetMemory(0x5d53a4, 268640519);
    }
}

void RemoveCoopTeamMode()
{
    int arr[6], link, temp;

    if (!link && GetMemory(0x654d5c) == 1)
    {
        arr[0] = 0x4DB8BE56; arr[1] = 0x20680065; arr[2] = 0x6A00418F; arr[3] = 0x54FF5600; arr[4] = 0xC4830824; arr[5] = 0x90C35E0C;
        link = GetScrDataField(RemoveCoopTeamMode);
        temp = GetMemory(0x5c31cc);
        SetMemory(0x5c31cc, link);
        Unused50();
        SetMemory(0x5c31cc, temp);
    }
}

int ImportPlaySoundAround()
{
	int arr[17], link;

	if (!link)
	{
		arr[0] = 0x50196068; arr[1] = 0x72506800; arr[2] = 0x50560050; arr[3] = 0x082454FF;
		arr[4] = 0x54FFF08B; arr[5] = 0x006A0824; arr[6] = 0x5650006A; arr[7] = 0x1C2454FF;
		arr[8] = 0x5810C483; arr[9] = 0x08C4835E; arr[10] = 0x909090C3;
        link = GetMemory(GetMemory(0x75ae28) + (0x30 * ImportPlaySoundAround + 0x1c));
	}
	return link;
}

void PlaySoundAround(int sUnit, int sNumber)
{
	int unitPtr = UnitToPtr(sUnit), temp = GetMemory(0x5c325c);

	if (unitPtr)
	{
		SetMemory(0x5c325c, ImportPlaySoundAround());
		Unused74(unitPtr, sNumber);
		SetMemory(0x5c325c, temp);
	}
}

void EmptyAll(int sUnit)
{
    while (GetLastItem(sUnit))
        Delete(GetLastItem(sUnit));
}

void SetGameTypeCoopMode()
{
    MakeCoopTeam();
    PlayerAutoTeamSign();

    SetMemory(0x5d5330, 0x2000);
    SetMemory(0x5d5394, 1);
}

void CancelPlayerDialogWithPTR(int plrPtr)
{
    if (GetMemory(GetMemory(plrPtr + 0x2ec)) + 0x11c)
    {
        SetMemory(GetMemory(plrPtr + 0x2ec) + 0x11c, 0);
        SetMemory(GetMemory(GetMemory(plrPtr + 0x2ec) + 0x114) + 0xe60, 0x10);
    }
}

void CancelPlayerDialog(int plrUnit)
{
    int temp = UnitToPtr(plrUnit);

    if (temp)
        CancelPlayerDialogWithPTR(temp);
}

int ImportCheckSelfDamage()
{
    int arr[14], link;

    if (!link)
    {
        arr[0] = 0x4C8B5651; arr[1] = 0xC9850C24; arr[2] = 0x748B2374; arr[3] = 0xF6851024; arr[4] = 0xF1391B74; arr[5] = 0x8B501374; arr[6] = 0x0001FC86;
        arr[7] = 0x74C08500; arr[8] = 0x58F08B05; arr[9] = 0xEB58ECEB; arr[10] = 0xC3595E04; arr[11] = 0x68595E90; arr[12] = 0x004E17B0; arr[13] = 0x909090C3;
        link = GetMemory(GetMemory(0x75ae28) + (0x30 * ImportCheckSelfDamage + 0x1c));
    }
    return link;
}

void SelfDamageClassEntry(int plrUnit)
{
    int ptr = UnitToPtr(plrUnit);

    if (ptr)
        SetMemory(ptr + 0x2cc, ImportCheckSelfDamage());
}

void SelfDamageClassMapExit()
{
    int i, pTable = 0x62f9e0, ptr;
    int link = GetScrDataField(SelfDamageClassMapExit);

    for (i = 31 ; i >= 0 ; Unused59(link, Unknownb9(link) - 1))
    {
        SetMemory(link + 8, GetMemory(pTable));
        if (ptr)
        {
            SetMemory(ptr + 0x2cc, 0x4e17b0);
            SetMemory(ptr + 0x2d4, 0x54d2b0);
            if (GetMemory(ptr + 0x2e8) ^ 0x4E62F0)      //@brief. 관객모드가 아닐 경우에만 되돌립니다//
                SetMemory(GetMemory(pTable) + 0x2e8, 0x4f8100);     //@brief. 업데이트 되돌리기//
            CancelPlayerDialogWithPTR(GetMemory(pTable));
        }
        Unused59(link + 4, Unknownb9(link + 4) + 0x12dc);
    }
}

int CheckPlayerFromUnitId(int unit)
{
    int i;

    for (i = 9 ; i >= 0 ; i --)
    {
        if (!(player[i] ^ unit))
            return i;
    }
    return -1;
}

int GetUnitThingID(int unit)
{
    int ptr = UnitToPtr(unit);

    if (ptr)
        return GetMemory(ptr + 0x4);
    return 0;
}

void SetUnitMaxHealth(int unit, int amount)
{
    int ptr = UnitToPtr(unit);

    if (ptr)
    {
        SetMemory(GetMemory(ptr + 0x22c), amount);
        SetMemory(GetMemory(ptr + 0x22c) + 0x4, amount);
    }
}

void GreenSparkFx(float xProfile, float yProfile)
{
    int fxTarget = CreateObjectAt("MonsterGenerator", xProfile, yProfile);

    Damage(fxTarget, 0, 1, -1);
    Delete(fxTarget);
}

float DistanceUnitToUnit(int unit1, int unit2)
{
    return Distance(GetObjectX(unit1), GetObjectY(unit1), GetObjectX(unit2), GetObjectY(unit2));
}

void TeleportProgress(int sUnit)
{
    int owner = GetOwner(sUnit), dest = ToInt(GetObjectZ(sUnit)), count = GetDirection(sUnit);

    while (1)
    {
        if (CurrentHealth(owner))
        {
            if (count)
            {
                if (DistanceUnitToUnit(sUnit, owner) < 23.0)
                {
                    LookWithAngle(sUnit, count - 1);
                    FrameTimerWithArg(1, sUnit, TeleportProgress);
                    break;
                }
            }
            else
            {
                Effect("TELEPORT", GetObjectX(sUnit), GetObjectY(sUnit), 0.0, 0.0);
                Effect("SMOKE_BLAST", GetObjectX(sUnit), GetObjectY(sUnit), 0.0, 0.0);
                MoveObject(owner, GetObjectX(dest), GetObjectY(dest));
                PlaySoundAround(owner, 6);
                Effect("TELEPORT", GetObjectX(owner), GetObjectY(owner), 0.0, 0.0);
            }
            EnchantOff(owner, "ENCHANT_BURNING");
        }
        Delete(sUnit);
        Delete(sUnit + 1);
        break;
    }
}

void TeleportPortal()
{
    int unit;

    if (CurrentHealth(other) && IsObjectOn(other))
    {
        if (!UnitCheckEnchant(other, GetLShift(12)))
        {
            Enchant(other, EnchantList(12), 4.0);
            unit = CreateObjectAt("InvisibleLightBlueHigh", GetObjectX(other), GetObjectY(other));
            Raise(unit, GetTrigger() + 1);
            LookWithAngle(unit, 48); //TODO: 1.XX seconds...
            CreateObjectAt("VortexSource", GetObjectX(unit), GetObjectY(unit));
            Effect("YELLOW_SPARKS", GetObjectX(unit), GetObjectY(unit), 0.0, 0.0);
            SetOwner(other, unit);
            TeleportProgress(unit);
            PlaySoundAround(other, 772);
            UniPrint(other, "공간이동을 준비 중 입니다. 취소하려면 움직이세요");
        }
    }
}

int TeleportSetup(int srcWp, int dstWp)
{
    int unit = CreateObjectAt("WeirdlingBeast", LocationX(srcWp), LocationY(srcWp));

    SetUnitMaxHealth(CreateObjectAt("InvisibleLightBlueHigh", LocationX(dstWp), LocationY(dstWp)) - 1, 10);
    Enchant(CreateObjectAt("InvisibleLightBlueHigh", LocationX(srcWp), LocationY(srcWp)), "ENCHANT_ANCHORED", 0.0);
    Damage(unit, 0, MaxHealth(unit) + 1, -1);
    SetCallback(unit, 9, TeleportPortal);

    return unit;
}

void ModifySetupTeleportDestination(int sUnit, int modLocation)
{
    if (MaxHealth(sUnit))
    {
        if (IsObjectOn(sUnit + 1))
            MoveObject(sUnit + 1, LocationX(modLocation), LocationY(modLocation));
    }
}

int MasterMonster()
{
    int master;

    if (!master)
    {
        master = CreateObjectAt("Hecubah", LocationX(14), LocationY(14));
        Frozen(master, 1);
    }
    return master;
}

void PlaceImagePreProc()
{
    DrawImageAtLocation(55, 2507);
    DrawImageAtLocation(57, 2510);
    DrawImageAtLocation(56, 2509);
    DrawImageAtLocation(58, 2508);
    DrawImageAtLocation(59, 2508);
    DrawImageAtLocation(60, 2508);
    DrawImageAtLocation(61, 2508);

    DrawImageAtLocation(75, 2518);
    DrawImageAtLocation(76, 2558);
    DrawImageAtLocation(77, 2559);
    DrawImageAtLocation(78, 2560);
}

void Description()
{
    SellGermPlace(50);
    RepairItemPlaceKp(51);
    SellGermPlace(52);
    RepairItemPlaceKp(53);
    RegistSignMessage(Object("MPik4"), "중국인 입국 막기를 시작하려면 오른쪽 스위치를 누르세요");
    RegistSignMessage(Object("MPik3"), "이 선을 넘어가면 라이프가 하나 씩 깎임!!");
    RegistSignMessage(Object("MPik2"), "입국 심사장: 저 너머 문을 통해 중국인들이 입국을 시작한다. 우리는 그들을 막아야만 한다");
    RegistSignMessage(Object("MPik1"), "크리쳐 지우기 비콘: 지우려는 크리쳐를 이 비콘 위에 올리면 지울 수 있습니다. 3천골드를 되돌려 받게 돼요");
}

void DelayInitRun()
{
    ManaTileAll(18);
    FrameTimer(3, PlaceImagePreProc);
    FrameTimer(5, Description);
    MasterMonster();
    XTelpo = TeleportSetup(22, 16);
    XItemNode = CreateObjectAt("ImaginaryCaster", LocationX(1), LocationY(1));

    GameClassLifeSet(20);
    FrameTimerWithArg(1, 20 | (28 << 8), PlaceDefaultItems);
    FrameTimer(1, PlayerClassLoop);
    FrameTimer(1, SetHostileCritter);
    FrameTimer(1, ShopClassInitPlace);
    FrameTimer(1, CreClassMarketPlace);
    FrameTimer(3, LoopSearchIndex);
    FrameTimer(1, LineSetInit);
    //FrameTimer(3, PotionImgTest); //here: removeMe
}

void NoKeepZoneSystem(int sUnit, int backLocation)
{
    if (IsPlayerUnit(sUnit))
    {
        MoveObject(sUnit, LocationX(backLocation), LocationY(backLocation));
        UniPrint(sUnit, "이봐... 당신은 이곳에 접근할 수 없어!");
    }
}

void HumanNoKeepNorth()
{
    NoKeepZoneSystem(other, 16);
}

void HumanNoKeepSouth()
{
    NoKeepZoneSystem(other, 21);
}

int CheckMonsterSection(float xProfile, float yProfile)
{
    int location = 16, i;

    for (i = 0 ; i < 5 ; i ++)
    {
        if (Distance(xProfile, yProfile, LocationX(location + i), LocationY(location + i)) < 990.0)
            return i + 1;
    }
    return 0;
}

void MonsterEntrySection()
{
    int curSection;

    if (IsMonsterUnit(other))
    {
        curSection = CheckMonsterSection(GetObjectX(other), GetObjectY(other));
        if (curSection)
        {
            if (curSection > GameClassMobAccessCheck())
            {
                ModifySetupTeleportDestination(XTelpo, 16 + curSection);
                GameClassMobAccessSet(curSection);
            }
        }
    }
}

void RespawnLocationReset()
{
    ModifySetupTeleportDestination(XTelpo, 16);
}

void GetUnitXYProfile(int sUnit, int dest)
{
    int ptr = UnitToPtr(sUnit);

    if (ptr)
    {
        SetMemory(dest, GetMemory(ptr + 0x38));
        SetMemory(dest + 4, GetMemory(ptr + 0x3c));
    }
}

int AnyargUnitOrLocation(int anyArg)
{
    float xProfile, yProfile;
    int link;

    if (!link)
    {
        link = GetMemory(GetMemory(0x75ae28) + (0x30 * AnyargUnitOrLocation + 0x1c)) + 4;
    }
    if (anyArg >> 0x18)
        GetUnitXYProfile(anyArg, link);
    else
    {
        xProfile = LocationX(anyArg & 0xfff);
        yProfile = LocationY(anyArg & 0xfff);
    }
    return link;
}

void UnitZeroFleeRange(int unit)
{
    int ptr = UnitToPtr(unit);

    if (ptr)
        SetMemory(GetMemory(ptr + 0x2ec) + 0x54c, 0); //Flee Range set to 0
}

void SetUnitVoice(int unit, int voiceIndex)
{
    int ptr = UnitToPtr(unit);

    if (ptr)
        SetMemory(GetMemory(ptr + 0x2ec) + 0x1e8, VoiceList(voiceIndex));
}

int WillOWispBinTable()
{
	int arr[62], link;
	if (!link)
	{
		arr[0] = 1819044183; arr[1] = 1936283471; arr[2] = 112; arr[17] = 500; arr[19] = 50; 
		arr[21] = 1065353216; arr[23] = 32769; arr[24] = 1069547520; arr[25] = 1; arr[26] = 3; 
		arr[28] = 1120403456; arr[29] = 10; arr[31] = 9; arr[32] = 15; arr[33] = 31; 
		arr[53] = 1128792064; arr[54] = 4; arr[59] = 5542784; arr[60] = 1326; arr[61] = 46913280; 
		link = GetMemory(GetMemory(0x75ae28) + (0x30 * WillOWispBinTable + 0x1c));
	}
	return link;
}

void WillOWispSubProcess(int sUnit)
{
	int ptr = UnitToPtr(sUnit);

	if (ptr)
	{
		SetMemory(ptr + 0x220, 1069547520);
		SetMemory(ptr + 0x224, 1069547520);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x5a0, 32769);
		SetMemory(GetMemory(ptr + 0x22c), 500);
		SetMemory(GetMemory(ptr + 0x22c) + 0x4, 500);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x1e4, WillOWispBinTable());
		SetMemory(GetMemory(ptr + 0x2ec) + 0x54c, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x538, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x540, 1065353216);
	}
}

int ImportMonsterActionPush()
{
    int arr[12], link;

    if (!link)
    {
        arr[0] = 0x50685650; arr[1] = 0xFF005072; arr[2] = 0x708D2414; arr[3] = 0xA2606804; arr[4] = 0x36FF0050; arr[5] = 0x54FF30FF;
        arr[6] = 0xC4830824; arr[7] = 0x7230680C; arr[8] = 0xFF500050; arr[9] = 0x83042454; arr[10] = 0x585E0CC4; arr[11] = 0x909090C3;
		link = GetMemory(GetMemory(0x75ae28) + (0x30 * ImportMonsterActionPush + 0x1c));
    }
    return link;
}

int MonsterActionPush(int sUnit, int sActType)
{
    int link = GetMemory(GetMemory(0x75ae28) + (0x30 * MonsterActionPush + 0x1c));
    int ptr = UnitToPtr(sUnit), temp = GetMemory(0x5c31bc), res = 0;

    if (ptr)
    {
        sUnit = ptr;
        SetMemory(0x5c31bc, ImportMonsterActionPush());
        res = GetHolder(link);
        SetMemory(0x5c31bc, temp);
    }
    return res;
}

void ForceCastSpell(int sUnit, int sSpellNumber, float xProfile, float yProfile)
{
	int act = MonsterActionPush(sUnit, 19);

	if (act)
	{
		SetMemory(act + 4, sSpellNumber);
		SetMemory(act + 12, ToInt(xProfile));
		SetMemory(act + 16, ToInt(yProfile));
	}
}

void UnitActionGuard(int sUnit)
{
    //Need to delay at least 1 frame
    int ptr = UnitToPtr(sUnit);

    if (ptr)
    {
        SetMemory(GetMemory(ptr + 0x2ec) + 0x228, 4);
        SetMemory(GetMemory(ptr + 0x2ec) + 0x22c, GetMemory(ptr + 0x38));
        SetMemory(GetMemory(ptr + 0x2ec) + 0x230, GetMemory(ptr + 0x3c));
        SetMemory(GetMemory(ptr + 0x2ec) + 0x234, (GetMemory(ptr + 0x7c) >> 0x10) & 0xff); //Direction
        SetMemory(GetMemory(ptr + 0x2ec) + 0x238, 0);
        SetMemory(GetMemory(ptr + 0x2ec) + 0x23c, 1);
    }
}

int CreClassGetAction(int cre)
{
    int ptr = UnitToPtr(cre);

    if (ptr)
    {
        return GetMemory(GetMemory(ptr + 0x2ec) + 0x228);
    }
    return 0;
}

int ImportMonsterStrikeFunc()
{
	int arr[14], link;

	if (!link) //arr[5] = 0x0830B68B;
	{
		arr[0] = 0x448B5650; arr[1] = 0xC0850C24; arr[2] = 0xB08B2574; arr[3] = 0x000002EC; arr[4] = 0x1B74F685; arr[5] = 0x04C8B68B; arr[6] = 0xFE830000;
		arr[7] = 0x68107C00; arr[8] = 0x00507310; arr[9] = 0x56006A50; arr[10] = 0x0C2454FF; arr[11] = 0x5E10C483; arr[12] = 0x93806858; arr[13] = 0x90C30054;
		link = GetMemory(GetMemory(0x75ae28) + (0x30 * ImportMonsterStrikeFunc + 0x1c));
	}
	return link;
}

int GetVictimUnit()
{
	int ptr = GetMemory(0x834a40);

	if (ptr)
		return GetMemory(ptr + 0x2c);
	return 0;
}

int GetVictimUnit2(int cre)
{
    int ptr = UnitToPtr(cre), ecPtr;

    if (ptr)
    {
        ecPtr = GetMemory(ptr + 0x2ec);
        if (GetMemory(ecPtr + 0x46c))
            return GetMemory(GetMemory(ecPtr + 0x46c) + 0x2c);
    }
    return 0;
}

void RegistryUnitStrikeFunction(int sUnit, int sFunc)
{
    int ptr = UnitToPtr(sUnit), ecPtr, binScrPtr;

    if (ptr)
    {
        ecPtr = GetMemory(ptr + 0x2ec);
        binScrPtr = GetMemory(GetMemory(ptr + 0x2ec) + 0x1e4);
        if (binScrPtr)
        {
            SetMemory(binScrPtr + 0xec, ImportMonsterStrikeFunc());
            //SetMemory(ecPtr + 0x830, sFunc);
            SetMemory(ecPtr + 0x4c8, sFunc);
        }
    }
}

void FONCollide()
{
    int owner = GetOwner(self);

    while (owner)
    {
        if (CurrentHealth(other) && IsAttackedBy(other, owner))
        {
            Damage(other, owner, 130, 14);
            Enchant(other, EnchantList(4), 1.0);
        }
        else if (!GetCaller())
            1;
        else
            break;
        Delete(self);
        break;
    }
}

int FONCreate(int me, float xProfile, float yProfile)
{
    int mis = CreateObjectAt("DeathBall", xProfile, yProfile);
    int ptr = GetMemory(0x750710);

    if (ptr)
    {
        SetMemory(ptr + 0x2e8, 5483536); //projectile update
        SetMemory(ptr + 0x2b8, ImportUnitCollideFunc());
        SetMemory(ptr + 0x2fc, FONCollide);
        SetOwner(me, mis);
    }
    return mis;
}

void AbsoluteTargetStrike(int owner, int target, float threshold, int func)
{
    int unit = CreateObjectAt("InvisibleLightBlueLow", GetObjectX(target), GetObjectY(target));

    Raise(CreateObjectAt("InvisibleLightBlueLow", GetObjectX(owner), GetObjectY(owner)), threshold);

    SetOwner(owner, unit);
    Raise(unit, target);
    FrameTimerWithArg(1, unit, func);
}

void OrbHecubahOneShot(int sUnit)
{
    int owner = GetOwner(sUnit), target = ToInt(GetObjectZ(sUnit)), mis;
    float dt = Distance(GetObjectX(sUnit), GetObjectY(sUnit), GetObjectX(target), GetObjectY(target));
    float thresHold;

    if (CurrentHealth(owner) && CurrentHealth(target))
    {
        mis = FONCreate(owner, GetObjectX(owner) + UnitRatioX(target, owner, 19.0), GetObjectY(owner) + UnitRatioY(target, owner, 19.0));
        thresHold = DistanceUnitToUnit(mis, target) / GetObjectZ(sUnit + 1);
        MoveObject(sUnit, GetObjectX(target) + UnitRatioX(target, sUnit, dt * thresHold), GetObjectY(target) + UnitRatioY(target, sUnit, dt * thresHold));
        if (IsVisibleTo(sUnit, owner))
        {
            PushObject(mis, -41.0, GetObjectX(sUnit), GetObjectY(sUnit));
        }
        else
        {
            PushObject(mis, -41.0, GetObjectX(target), GetObjectY(target));
        }
        DeleteObjectTimer(mis, 21);
    }
    Delete(sUnit);
    Delete(sUnit + 1);
}

void RedWizStrikeTrigger()
{
    int victim = GetVictimUnit2(self);

    if (MaxHealth(victim))
    {
        ForceCastSpell(self, 0, GetObjectX(self), GetObjectY(self));
        Damage(other, self, 80, 16);
        Effect("SENTRY_RAY", GetObjectX(self), GetObjectY(self), GetObjectX(victim), GetObjectY(victim));
    }
}

void OrbHecubahStrikeTrigger()
{
    int victim = GetVictimUnit2(self);

    if (MaxHealth(victim))
    {
        ForceCastSpell(self, 0, GetObjectX(self), GetObjectY(self));
        AbsoluteTargetStrike(GetTrigger(), victim, 85.0, OrbHecubahOneShot);
    }
}

void WispStrikeTrigger()
{
    int victim = GetVictimUnit2(self);

    if (CurrentHealth(victim))
    {
        Damage(victim, self, 10, 9);
        ForceCastSpell(self, 0, GetObjectX(self), GetObjectY(self));
        Effect("LIGHTNING", GetObjectX(victim), GetObjectY(victim), GetObjectX(self), GetObjectY(self));
    }
}

void ResetHostileCritter()
{
	SetMemory(0x833e64, 0x55b);		//CarnivorousPlant
	//SetMemory(0x833e70, 1329);		//FishBig
	//SetMemory(0x833e74, 1330);		//FishSmall
	//SetMemory(0x833e78, 1359);		//Rat
	SetMemory(0x833e7c, 1313);		//GreenFrog
    SetMemory(0x833e5c, 0);         //wisp
}

void SetHostileCritter()
{
	SetMemory(0x833e64, 0x540);		//CarnivorousPlant
	//SetMemory(0x833e70, 0x540);		//FishBig
	//SetMemory(0x833e74, 0x540);		//FishSmall
	//SetMemory(0x833e78, 0x540);		//Rat
	SetMemory(0x833e7c, 0x540);		//GreenFrog
    SetMemory(0x833e5c, 0x540);     //
}

int MonTypeFrog(int anyArg)
{
    int xyTable = AnyargUnitOrLocation(anyArg);
    int unit = CreateObjectAt("GreenFrog", GetMemoryFloat(xyTable), GetMemoryFloat(xyTable + 4));

    GreenFrogSubProcess(unit);
    return unit;
}

int BatBinTable()
{
	int arr[62], link;
	if (!link)
	{
		arr[0] = 7627074; arr[17] = 60; arr[18] = 1; arr[19] = 95; arr[21] = 1056964608; 
		arr[23] = 32768; arr[24] = 1065353216; arr[25] = 1; arr[26] = 5; arr[27] = 5; 
		arr[28] = 1097859072; arr[29] = 4; arr[31] = 8; arr[59] = 5542784; arr[60] = 1357; 
		arr[61] = 46906368; 
		link = GetMemory(GetMemory(0x75ae28) + (0x30 * BatBinTable + 0x1c));
	}
	return link;
}

void BatSubProcess(int sUnit)
{
	int ptr = UnitToPtr(sUnit);

	if (ptr)
	{
		SetMemory(ptr + 0x220, 1077306982);
		SetMemory(ptr + 0x224, 1077306982);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x5a0, 32768);
		SetMemory(GetMemory(ptr + 0x22c), 60);
		SetMemory(GetMemory(ptr + 0x22c) + 0x4, 60);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x1e4, BatBinTable());
		SetMemory(GetMemory(ptr + 0x2ec) + 0x54c, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x538, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x540, 1056964608);
	}
}

int MonTypeBat(int anyArg)
{
    int xyTable = AnyargUnitOrLocation(anyArg);
    int unit = CreateObjectAt("Bat", GetMemoryFloat(xyTable), GetMemoryFloat(xyTable + 4));

    BatSubProcess(unit);
    return unit;
}

int SmallAlbinoSpiderBinTable()
{
	int arr[62], link;
	if (!link)
	{
		arr[0] = 1818324307; arr[1] = 1651261804; arr[2] = 1399811689; arr[3] = 1701079408; arr[4] = 114; 
		arr[17] = 75; arr[18] = 1; arr[19] = 76; arr[21] = 1065353216; arr[23] = 34816; 
		arr[24] = 1065353216; arr[26] = 4; arr[27] = 5; arr[28] = 1097859072; arr[29] = 6; 
		arr[31] = 8; arr[59] = 5542784; arr[60] = 1356; arr[61] = 46906624; 
		link = GetMemory(GetMemory(0x75ae28) + (0x30 * SmallAlbinoSpiderBinTable + 0x1c));
	}
	return link;
}

void SmallAlbinoSpiderSubProcess(int sUnit)
{
	int ptr = UnitToPtr(sUnit);

	if (ptr)
	{
		SetMemory(ptr + 0x220, 1074916229);
		SetMemory(ptr + 0x224, 1074916229);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x5a0, 34816);
		SetMemory(GetMemory(ptr + 0x22c), 75);
		SetMemory(GetMemory(ptr + 0x22c) + 0x4, 75);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x1e4, SmallAlbinoSpiderBinTable());
		SetMemory(GetMemory(ptr + 0x2ec) + 0x54c, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x538, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x540, 1065353216);
	}
}

int MonTypeSmallSpider(int anyArg)
{
    int xyTable = AnyargUnitOrLocation(anyArg);
    int unit = CreateObjectAt("SmallAlbinoSpider", GetMemoryFloat(xyTable), GetMemoryFloat(xyTable + 4));

    SmallAlbinoSpiderSubProcess(unit);
    return unit;
}

int MonTypeLeech(int anyArg)
{
    int xyTable = AnyargUnitOrLocation(anyArg);
    int unit = CreateObjectAt("GiantLeech", GetMemoryFloat(xyTable), GetMemoryFloat(xyTable + 4));

    SetUnitMaxHealth(unit, 80);
    return unit;
}

int MonTypeSwordman(int anyArg)
{
    int xyTable = AnyargUnitOrLocation(anyArg);
    int unit = CreateObjectAt("Swordsman", GetMemoryFloat(xyTable), GetMemoryFloat(xyTable + 4));

    SetUnitMaxHealth(unit, 130);
    return unit;
}

int FlyingGolemBinTable()
{
	int arr[62], link;
	if (!link)
	{
		arr[0] = 1769565254; arr[1] = 1866950510; arr[2] = 7169388; arr[17] = 98; arr[18] = 10; 
		arr[19] = 90; arr[21] = 1065353216; arr[23] = 32769; arr[24] = 1065353216; arr[26] = 4; 
		arr[37] = 1701605191; arr[38] = 1920090477; arr[39] = 30575; arr[53] = 1125515264; arr[54] = 4; 
		arr[55] = 25; arr[56] = 25; arr[60] = 1316; arr[61] = 46903808; 
		link = GetMemory(GetMemory(0x75ae28) + (0x30 * FlyingGolemBinTable + 0x1c));
	}
	return link;
}

void FlyingGolemSubProcess(int sUnit)
{
	int ptr = UnitToPtr(sUnit);

	if (ptr)
	{
		SetMemory(ptr + 0x220, 1076677837);
		SetMemory(ptr + 0x224, 1076677837);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x5a0, 32769);
		SetMemory(GetMemory(ptr + 0x22c), 98);
		SetMemory(GetMemory(ptr + 0x22c) + 0x4, 98);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x1e4, FlyingGolemBinTable());
		SetMemory(GetMemory(ptr + 0x2ec) + 0x54c, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x538, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x540, 1065353216);
	}
}

int MonTypeMecaFlying(int anyArg)
{
    int xyTable = AnyargUnitOrLocation(anyArg);
    int unit = CreateObjectAt("FlyingGolem", GetMemoryFloat(xyTable), GetMemoryFloat(xyTable + 4));

    FlyingGolemSubProcess(unit);
    return unit;
}

int MonTypeUrchin(int anyArg)
{
    int xyTable = AnyargUnitOrLocation(anyArg);
    int unit = CreateObjectAt("Urchin", GetMemoryFloat(xyTable), GetMemoryFloat(xyTable + 4));

    SetUnitMaxHealth(unit, 120);
    UnitZeroFleeRange(unit);
    return unit;
}

int BlackWidowBinTable()
{
	int arr[62], link;
	if (!link)
	{
		arr[0] = 1667329090; arr[1] = 1684625259; arr[2] = 30575; arr[17] = 180; arr[19] = 85; 
		arr[21] = 1065353216; arr[23] = 32768; arr[24] = 1065353216; arr[26] = 4; arr[27] = 3; 
		arr[28] = 1097859072; arr[29] = 25; arr[31] = 8; arr[32] = 13; arr[33] = 21; 
		arr[34] = 4; arr[35] = 2; arr[36] = 9; arr[37] = 1684631635; arr[38] = 1884516965; 
		arr[39] = 29801; arr[53] = 1128792064; arr[55] = 20; arr[56] = 28; arr[59] = 5544896; 
		arr[61] = 45071360; 
		link = GetMemory(GetMemory(0x75ae28) + (0x30 * BlackWidowBinTable + 0x1c));
	}
	return link;
}

void BlackWidowSubProcess(int sUnit)
{
	int ptr = UnitToPtr(sUnit);

	if (ptr)
	{
		SetMemory(ptr + 0x220, 1076048691);
		SetMemory(ptr + 0x224, 1076048691);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x5a0, 32768);
		SetMemory(GetMemory(ptr + 0x22c), 180);
		SetMemory(GetMemory(ptr + 0x22c) + 0x4, 180);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x1e4, BlackWidowBinTable());
		SetMemory(GetMemory(ptr + 0x2ec) + 0x54c, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x538, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x540, 1065353216);
	}
}

int MonTypeSpider(int anyArg)
{
    int xyTable = AnyargUnitOrLocation(anyArg);
    int unit = CreateObjectAt("BlackWidow", GetMemoryFloat(xyTable), GetMemoryFloat(xyTable + 4));

    BlackWidowSubProcess(unit);
    return unit;
}

int MonTypeArcher(int anyArg)
{
    int xyTable = AnyargUnitOrLocation(anyArg);
    int unit = CreateObjectAt("Archer", GetMemoryFloat(xyTable), GetMemoryFloat(xyTable + 4));

    SetUnitMaxHealth(unit, 180);
    return unit;
}

int MonTypeScorpion(int anyArg)
{
    int xyTable = AnyargUnitOrLocation(anyArg);
    int unit = CreateObjectAt("Scorpion", GetMemoryFloat(xyTable), GetMemoryFloat(xyTable + 4));

    SetUnitMaxHealth(unit, 225);
    return unit;
}

int MonTypeGargoyle(int anyArg)
{
    int xyTable = AnyargUnitOrLocation(anyArg);
    int unit = CreateObjectAt("EvilCherub", GetMemoryFloat(xyTable), GetMemoryFloat(xyTable + 4));

    SetUnitMaxHealth(unit, 180);
    return unit;
}

int MonTypeSkeleton(int anyArg)
{
    int xyTable = AnyargUnitOrLocation(anyArg);
    int unit = CreateObjectAt("Skeleton", GetMemoryFloat(xyTable), GetMemoryFloat(xyTable + 4));

    SetUnitMaxHealth(unit, 260);
    return unit;
}

int MonTypeOgreAxe(int anyArg)
{
    int xyTable = AnyargUnitOrLocation(anyArg);
    int unit = CreateObjectAt("GruntAxe", GetMemoryFloat(xyTable), GetMemoryFloat(xyTable + 4));

    SetUnitMaxHealth(unit, 275);
    return unit;
}

int MonTypeOgre(int anyArg)
{
    int xyTable = AnyargUnitOrLocation(anyArg);
    int unit = CreateObjectAt("OgreBrute", GetMemoryFloat(xyTable), GetMemoryFloat(xyTable + 4));

    SetUnitMaxHealth(unit, 306);
    return unit;
}

int MonTypeBear(int anyArg)
{
    int xyTable = AnyargUnitOrLocation(anyArg);
    int unit = CreateObjectAt("Bear", GetMemoryFloat(xyTable), GetMemoryFloat(xyTable + 4));

    SetUnitMaxHealth(unit, 425);
    return unit;
}

int MonTypeSkullLord(int anyArg)
{
    int xyTable = AnyargUnitOrLocation(anyArg);
    int unit = CreateObjectAt("SkeletonLord", GetMemoryFloat(xyTable), GetMemoryFloat(xyTable + 4));

    SetUnitMaxHealth(unit, 325);
    return unit;
}

int MonTypeShade(int anyArg)
{
    int xyTable = AnyargUnitOrLocation(anyArg);
    int unit = CreateObjectAt("Shade", GetMemoryFloat(xyTable), GetMemoryFloat(xyTable + 4));

    SetUnitMaxHealth(unit, 275);
    return unit;
}

int MonTypeOgreLord(int anyArg)
{
    int xyTable = AnyargUnitOrLocation(anyArg);
    int unit = CreateObjectAt("OgreWarlord", GetMemoryFloat(xyTable), GetMemoryFloat(xyTable + 4));

    SetUnitMaxHealth(unit, 360);
    return unit;
}

int MonTypeFirebat(int anyArg)
{
    int xyTable = AnyargUnitOrLocation(anyArg);
    string fbat = {"EmberDemon", "MeleeDemon", "MeleeDemon", "MeleeDemon"};
    int unit = CreateObjectAt(ToStr(SToInt(fbat) + Random(0, 3)), GetMemoryFloat(xyTable), GetMemoryFloat(xyTable + 4));

    SetUnitMaxHealth(unit, 225);
    return unit;
}

int MonTypeImp(int anyArg)
{
    int xyTable = AnyargUnitOrLocation(anyArg);
    int unit = CreateObjectAt("Imp", GetMemoryFloat(xyTable), GetMemoryFloat(xyTable + 4));

    SetUnitMaxHealth(unit, 192);
    return unit;
}

int FireSpriteBinTable()
{
	int arr[62], link;
	if (!link)
	{
		arr[0] = 1701996870; arr[1] = 1769107539; arr[2] = 25972; arr[17] = 168; arr[19] = 71; 
		arr[21] = 1065353216; arr[23] = 65536; arr[24] = 1065353216; arr[27] = 3; arr[28] = 1106247680; 
		arr[29] = 10; arr[31] = 10; arr[32] = 13; arr[33] = 21; arr[37] = 1769236816; 
		arr[38] = 1181513062; arr[39] = 1650815593; arr[40] = 7105633; arr[53] = 1133903872; arr[55] = 18; 
		arr[56] = 28; arr[58] = 5545472; arr[59] = 5542784; 
		link = GetMemory(GetMemory(0x75ae28) + (0x30 * FireSpriteBinTable + 0x1c));
	}
	return link;
}

void FireSpriteSubProcess(int sUnit)
{
	int ptr = UnitToPtr(sUnit);

	if (ptr)
	{
		SetMemory(ptr + 0x220, 1074287083);
		SetMemory(ptr + 0x224, 1074287083);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x5a0, 65536);
		SetMemory(GetMemory(ptr + 0x22c), 168);
		SetMemory(GetMemory(ptr + 0x22c) + 0x4, 168);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x1e4, FireSpriteBinTable());
		SetMemory(GetMemory(ptr + 0x2ec) + 0x54c, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x538, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x540, 1065353216);
	}
}

int MonTypeFireFairy(int anyArg)
{
    int xyTable = AnyargUnitOrLocation(anyArg);
    int unit = CreateObjectAt("FireSprite", GetMemoryFloat(xyTable), GetMemoryFloat(xyTable + 4));

    FireSpriteSubProcess(unit);
    return unit;
}

int NecromancerBinTable()
{
	int arr[62], link;
	if (!link)
	{
		arr[0] = 1919116622; arr[1] = 1851878767; arr[2] = 7497059; arr[17] = 370; arr[19] = 60; 
		arr[21] = 1065353216; arr[23] = 32768; arr[24] = 1070302495; arr[25] = 1; arr[26] = 2; 
		arr[28] = 1103626240; arr[29] = 48; arr[30] = 1092616192; arr[31] = 11; arr[32] = 7; 
		arr[33] = 15; arr[34] = 1; arr[35] = 1; arr[36] = 10; arr[59] = 5542784; 
		link = GetMemory(GetMemory(0x75ae28) + (0x30 * NecromancerBinTable + 0x1c));
	}
	return link;
}

void NecromancerSubProcess(int sUnit)
{
	int ptr = UnitToPtr(sUnit);

	if (ptr)
	{
		SetMemory(ptr + 0x220, 1072064102);
		SetMemory(ptr + 0x224, 1072064102);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x5a0, 32768);
		SetMemory(GetMemory(ptr + 0x22c), 370);
		SetMemory(GetMemory(ptr + 0x22c) + 0x4, 370);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x1e4, NecromancerBinTable());
		SetMemory(GetMemory(ptr + 0x2ec) + 0x54c, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x538, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x540, 1065353216);
	}
}

int MonTypeNecromancer(int anyArg)
{
    int xyTable = AnyargUnitOrLocation(anyArg);
    int unit = CreateObjectAt("Necromancer", GetMemoryFloat(xyTable), GetMemoryFloat(xyTable + 4));

    NecromancerSubProcess(unit);
    return unit;
}

int HecubahBinTable()
{
	int arr[62], link;
	if (!link)
	{
		arr[0] = 1969448264; arr[1] = 6840674; arr[17] = 720; arr[19] = 100; arr[21] = 1065353216; 
		arr[23] = 32768; arr[24] = 1065353216; arr[25] = 1; arr[26] = 4; arr[27] = 7; 
		arr[28] = 1108082688; arr[29] = 130; arr[30] = 1092616192; arr[32] = 10; arr[33] = 18; 
		arr[59] = 5542784; 
		link = GetMemory(GetMemory(0x75ae28) + (0x30 * HecubahBinTable + 0x1c));
	}
	return link;
}

void HecubahSubProcess(int sUnit)
{
	int ptr = UnitToPtr(sUnit);

	if (ptr)
	{
		SetMemory(ptr + 0x220, 1077936128);
		SetMemory(ptr + 0x224, 1077936128);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x5a0, 32768);
		SetMemory(GetMemory(ptr + 0x22c), 720);
		SetMemory(GetMemory(ptr + 0x22c) + 0x4, 720);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x1e4, HecubahBinTable());
		SetMemory(GetMemory(ptr + 0x2ec) + 0x54c, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x538, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x540, 1065353216);
	}
}

int MonTypeHecubah(int anyArg)
{
    int xyTable = AnyargUnitOrLocation(anyArg);
    int unit = CreateObjectAt("Hecubah", GetMemoryFloat(xyTable), GetMemoryFloat(xyTable + 4));

    HecubahSubProcess(unit);
    return unit;
}

int MonTypeMecaGolem(int anyArg)
{
    int xyTable = AnyargUnitOrLocation(anyArg);
    int unit = CreateObjectAt("MechanicalGolem", GetMemoryFloat(xyTable), GetMemoryFloat(xyTable + 4));

    SetUnitMaxHealth(unit, 900);
    return unit;
}

int MonTypeWisp(int anyArg)
{
    int xyTable = AnyargUnitOrLocation(anyArg);
    int unit = CreateObjectAt("WillOWisp", GetMemoryFloat(xyTable), GetMemoryFloat(xyTable + 4));

    WillOWispSubProcess(unit);
    RegistryUnitStrikeFunction(unit, WispStrikeTrigger);
    return unit;
}

int MonTypeGhost(int anyArg)
{
    int xyTable = AnyargUnitOrLocation(anyArg);
    int unit = CreateObjectAt("Ghost", GetMemoryFloat(xyTable), GetMemoryFloat(xyTable + 4));

    SetUnitMaxHealth(unit, 160);
    return unit;
}

int GoonBinTable()
{
	int arr[62], link;
	if (!link)
	{
		arr[0] = 1852796743; arr[17] = 295; arr[19] = 97; arr[21] = 1065353216; arr[23] = 32768; 
		arr[24] = 1066192077; arr[26] = 4; arr[28] = 1106247680; arr[29] = 50; arr[30] = 1092616192; 
		arr[31] = 4; arr[32] = 18; arr[33] = 21; arr[34] = 3; arr[35] = 6; 
		arr[36] = 20; arr[57] = 5548176; arr[58] = 5546608; arr[59] = 5543680; 
		link = GetMemory(GetMemory(0x75ae28) + (0x30 * GoonBinTable + 0x1c));
	}
	return link;
}

void GoonSubProcess(int sUnit)
{
	int ptr = UnitToPtr(sUnit);

	if (ptr)
	{
		SetMemory(ptr + 0x220, 1077558640);
		SetMemory(ptr + 0x224, 1077558640);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x5a0, 32768);
		SetMemory(GetMemory(ptr + 0x22c), 295);
		SetMemory(GetMemory(ptr + 0x22c) + 0x4, 295);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x1e4, GoonBinTable());
		SetMemory(GetMemory(ptr + 0x2ec) + 0x54c, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x538, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x540, 1065353216);
	}
}

int MonTypeGoon(int anyArg)
{
    int xyTable = AnyargUnitOrLocation(anyArg);
    int unit = CreateObjectAt("Goon", GetMemoryFloat(xyTable), GetMemoryFloat(xyTable + 4));

    GoonSubProcess(unit);
    SetUnitVoice(unit, 63);
    return unit;
}

int LichLordBinTable()
{
	int arr[62], link;
	if (!link)
	{
		arr[0] = 1751345484; arr[1] = 1685221196; arr[17] = 425; arr[19] = 126; arr[21] = 1065353216; 
		arr[23] = 34816; arr[24] = 1065353216; arr[25] = 1; arr[26] = 4; arr[27] = 7; 
		arr[28] = 1113325568; arr[29] = 100; arr[30] = 1092616192; arr[32] = 15; arr[33] = 21; 
		arr[57] = 5548288; arr[59] = 5542784; 
		link = GetMemory(GetMemory(0x75ae28) + (0x30 * LichLordBinTable + 0x1c));
	}
	return link;
}

void LichLordSubProcess(int sUnit)
{
	int ptr = UnitToPtr(sUnit);

	if (ptr)
	{
		SetMemory(ptr + 0x220, 1081207685);
		SetMemory(ptr + 0x224, 1081207685);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x5a0, 34816);
		SetMemory(GetMemory(ptr + 0x22c), 425);
		SetMemory(GetMemory(ptr + 0x22c) + 0x4, 425);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x1e4, LichLordBinTable());
		SetMemory(GetMemory(ptr + 0x2ec) + 0x54c, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x538, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x540, 1065353216);
	}
}

int MonTypeLichlord(int anyarg)
{
    int xyTable = AnyargUnitOrLocation(anyarg);
    int unit = CreateObjectAt("LichLord", GetMemoryFloat(xyTable), GetMemoryFloat(xyTable + 4));

    LichLordSubProcess(unit);
    return unit;
}

int AirshipCaptainBinTable()
{
	int arr[62], link;
	if (!link)
	{
		arr[0] = 1936877889; arr[1] = 1131440488; arr[2] = 1635020897; arr[3] = 28265; arr[17] = 325; 
		arr[19] = 90; arr[21] = 1065353216; arr[23] = 34817; arr[24] = 1065353216; arr[26] = 4; 
		arr[37] = 1919248451; arr[38] = 1916887669; arr[39] = 7827314; arr[53] = 1133903872; arr[55] = 3; 
		arr[56] = 8; arr[58] = 5546320; arr[60] = 1387; arr[61] = 46915328; 
		link = GetMemory(GetMemory(0x75ae28) + (0x30 * AirshipCaptainBinTable + 0x1c));
	}
	return link;
}

void AirshipCaptainSubProcess(int sUnit)
{
	int ptr = UnitToPtr(sUnit);

	if (ptr)
	{
		SetMemory(ptr + 0x220, 1076677837);
		SetMemory(ptr + 0x224, 1076677837);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x5a0, 34817);
		SetMemory(GetMemory(ptr + 0x22c), 325);
		SetMemory(GetMemory(ptr + 0x22c) + 0x4, 325);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x1e4, AirshipCaptainBinTable());
		SetMemory(GetMemory(ptr + 0x2ec) + 0x54c, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x538, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x540, 1065353216);
	}
}

int MonTypeJandor(int anyarg)
{
    int xyTable = AnyargUnitOrLocation(anyarg);
    int unit = CreateObjectAt("AirshipCaptain", GetMemoryFloat(xyTable), GetMemoryFloat(xyTable + 4));

    AirshipCaptainSubProcess(unit);
    return unit;
}

int CarnivorousPlantBinTable2()
{
	int arr[62], link;
	if (!link)
	{
		arr[0] = 1852989763; arr[1] = 1919907433; arr[2] = 1349743983; arr[3] = 1953390956; arr[17] = 600; 
		arr[18] = 200; arr[19] = 100; arr[21] = 1065353216; arr[23] = 32768; arr[24] = 1065353216; 
		arr[25] = 1; arr[26] = 4; arr[27] = 5; arr[28] = 1109393408; arr[29] = 100; 
		arr[31] = 8; arr[34] = 3; arr[35] = 3; arr[36] = 20; arr[59] = 5544320; 
		arr[60] = 1371; arr[61] = 46901760; 
		link = GetMemory(GetMemory(0x75ae28) + (0x30 * CarnivorousPlantBinTable2 + 0x1c));
	}
	return link;
}

void CarnivorousPlantSubProcess2(int sUnit)
{
	int ptr = UnitToPtr(sUnit);

	if (ptr)
	{
		SetMemory(ptr + 0x220, 1077936128);
		SetMemory(ptr + 0x224, 1077936128);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x5a0, 32768);
		SetMemory(GetMemory(ptr + 0x22c), 600);
		SetMemory(GetMemory(ptr + 0x22c) + 0x4, 600);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x1e4, CarnivorousPlantBinTable2());
		SetMemory(GetMemory(ptr + 0x2ec) + 0x54c, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x538, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x540, 1065353216);
	}
}

int MonTypeCarnPlant(int anyarg)
{
    int xyTable = AnyargUnitOrLocation(anyarg);
    int unit = CreateObjectAt("CarnivorousPlant", GetMemoryFloat(xyTable), GetMemoryFloat(xyTable + 4));

    CarnivorousPlantSubProcess2(unit);
    return unit;
}

int MonTypeDryad(int anyarg)
{
    int xyTable = AnyargUnitOrLocation(anyarg);
    int unit = CreateObjectAt("WizardGreen", GetMemoryFloat(xyTable), GetMemoryFloat(xyTable + 4));

    SetUnitMaxHealth(unit, 275);
    Enchant(unit, EnchantList(14), 0.0);

    return unit;
}

int StoneGolemBinTable()
{
	int arr[62], link;
	if (!link)
	{
		arr[0] = 1852798035; arr[1] = 1819232101; arr[2] = 28005; arr[17] = 750; arr[19] = 70; 
		arr[21] = 1065353216; arr[23] = 32768; arr[24] = 1067869798; arr[26] = 4; arr[27] = 5; 
		arr[28] = 1117782016; arr[29] = 100; arr[31] = 2; arr[32] = 60; arr[33] = 90; 
		arr[58] = 5545472; arr[59] = 5543904; arr[60] = 1324; arr[61] = 46901248; 
		link = GetMemory(GetMemory(0x75ae28) + (0x30 * StoneGolemBinTable + 0x1c));
	}
	return link;
}

void StoneGolemSubProcess(int sUnit)
{
	int ptr = UnitToPtr(sUnit);

	if (ptr)
	{
		SetMemory(ptr + 0x220, 1074161254);
		SetMemory(ptr + 0x224, 1074161254);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x5a0, 32768);
		SetMemory(GetMemory(ptr + 0x22c), 750);
		SetMemory(GetMemory(ptr + 0x22c) + 0x4, 750);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x1e4, StoneGolemBinTable());
		SetMemory(GetMemory(ptr + 0x2ec) + 0x54c, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x538, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x540, 1065353216);
	}
}

int MonTypeStoneGiant(int anyarg)
{
    int xyTable = AnyargUnitOrLocation(anyarg);
    int golem = CreateObjectAt("StoneGolem", GetMemoryFloat(xyTable), GetMemoryFloat(xyTable + 4));

    StoneGolemSubProcess(golem);
    return golem;
}

int HorrendousBinTable()
{
	int arr[62], link;
	if (!link)
	{
		arr[0] = 1920102216; arr[1] = 1868852837; arr[2] = 29557; arr[17] = 600; arr[19] = 100; 
		arr[21] = 1065353216; arr[23] = 32768; arr[24] = 1065353216; arr[25] = 1; arr[26] = 9; 
		arr[27] = 5; arr[28] = 1109393408; arr[29] = 62; arr[54] = 4; arr[59] = 5542784; 
		arr[60] = 1386; arr[61] = 46907648; 
		link = GetMemory(GetMemory(0x75ae28) + (0x30 * HorrendousBinTable + 0x1c));
	}
	return link;
}

void HorrendousSubProcess(int sUnit)
{
	int ptr = UnitToPtr(sUnit);

	if (ptr)
	{
		SetMemory(ptr + 0x220, 1077936128);
		SetMemory(ptr + 0x224, 1077936128);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x5a0, 32768);
		SetMemory(GetMemory(ptr + 0x22c), 600);
		SetMemory(GetMemory(ptr + 0x22c) + 0x4, 600);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x1e4, HorrendousBinTable());
		SetMemory(GetMemory(ptr + 0x2ec) + 0x54c, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x538, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x540, 1065353216);
	}
}

int MonTypeHorrendous(int anyarg)
{
    int xyTable = AnyargUnitOrLocation(anyarg);
    int horr = CreateObjectAt("Horrendous", GetMemoryFloat(xyTable), GetMemoryFloat(xyTable + 4));

    HorrendousSubProcess(horr);
    return horr;
}

int StrongWizardWhiteBinTable()
{
	int arr[62], link;
	if (!link)
	{
		arr[0] = 1869771859; arr[1] = 1767335790; arr[2] = 1685217658; arr[3] = 1953065047; arr[4] = 101; 
		arr[17] = 325; arr[19] = 65; arr[21] = 1065353216; arr[23] = 32768; arr[24] = 1069547520; 
		arr[37] = 1701996870; arr[38] = 1819042146; arr[53] = 1128792064; arr[54] = 4; arr[55] = 20; 
		arr[56] = 30; arr[58] = 5546320; 
		link = GetMemory(GetMemory(0x75ae28) + (0x30 * StrongWizardWhiteBinTable + 0x1c));
	}
	return link;
}

void StrongWizardWhiteSubProcess(int sUnit)
{
	int ptr = UnitToPtr(sUnit);

	if (ptr)
	{
		SetMemory(ptr + 0x220, 1073322393);
		SetMemory(ptr + 0x224, 1073322393);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x5a0, 32768);
		SetMemory(GetMemory(ptr + 0x22c), 325);
		SetMemory(GetMemory(ptr + 0x22c) + 0x4, 325);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x1e4, StrongWizardWhiteBinTable());
		SetMemory(GetMemory(ptr + 0x2ec) + 0x54c, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x538, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x540, 1065353216);
	}
}

int MonTypeHovath(int anyarg)
{
    int xyTable = AnyargUnitOrLocation(anyarg);
    int hovath = CreateObjectAt("StrongWizardWhite", GetMemoryFloat(xyTable), GetMemoryFloat(xyTable + 4));

    StrongWizardWhiteSubProcess(hovath);
    return hovath;
}

int CreateYellowPotion(int restoreAmount, float xProfile, float yProfile)
{
    int unit = CreateObjectAt("RedPotion", xProfile, yProfile);
    int ptr = GetMemory(0x750710);

    SetMemory(ptr + 4, 639); //YellowPotion
    SetMemory(GetMemory(ptr + 0x2e0), restoreAmount);

    return unit;
}

int CreateBlackPotion(int restoreAmount, float xProfile, float yProfile)
{
    int unit = CreateObjectAt("RedPotion", xProfile, yProfile);
    int ptr = GetMemory(0x750710);

    SetMemory(ptr + 4, 641); //BlackPotion
    SetMemory(GetMemory(ptr + 0x2e0), restoreAmount);

    return unit;
}

int CreateWhitePotion(int restoreAmount, float xProfile, float yProfile)
{
    int unit = CreateObjectAt("RedPotion", xProfile, yProfile);
    int ptr = GetMemory(0x750710);

    SetMemory(ptr + 4, 640); //WhitePotion
    SetMemory(ptr + 12, GetMemory(ptr + 12) ^ 0x20);
    SetMemory(GetMemory(ptr + 0x2e0), restoreAmount);

    return unit;
}

void GodModePotionFeatureSwap(int potion)
{
    int ptr = UnitToPtr(potion);

    if (ptr)
    {
        SetMemory(ptr + 0x2dc, ImportUseItemFunc());
        SetMemory(ptr + 0x2fc, UseGodModePotion);
        Enchant(potion, EnchantList(22), 0.0);
    }
}

int CheckPotionThingID(int unit)
{
    int thingID = GetUnitThingID(unit), x = unit;

    if (thingID == 639)
        x = CreateYellowPotion(125, GetObjectX(unit), GetObjectY(unit));
    else if (thingID == 640)
        x = CreateWhitePotion(100, GetObjectX(unit), GetObjectY(unit));
    else if (thingID == 641)
        x = CreateBlackPotion(85, GetObjectX(unit), GetObjectY(unit));
    if (x ^ unit) Delete(unit);

    return x;
}

int ImportAllowAllDrop()
{
	int arr[19], link;

	if (!link)
	{
		arr[0] = 0x550CEC83; arr[1] = 0x14246C8B; arr[2] = 0x24748B56; arr[3] = 0xECAE391C; arr[4] = 0x74000001; arr[5] = 0xC0315E08; arr[6] = 0x0CC4835D;
		arr[7] = 0x0845F6C3; arr[8] = 0x68207404; arr[9] = 0x0053EBF0; arr[10] = 0x2454FF56; arr[11] = 0x08C48304; arr[12] = 0x0F74C085; arr[13] = 0x53EC8068;
		arr[14] = 0x56016A00; arr[15] = 0x082454FF; arr[16] = 0x680CC483; arr[17] = 0x004ED301; arr[18] = 0x909090C3;
        link = GetScrDataField(ImportAllowAllDrop);
	}
	return link;
}

int WeaponPower(int num)
{
    int addr[6];

    if (!addr[0])
    {
        addr[0] = 0x5a00a4; addr[1] = 0x5BA714; addr[2] = 0x5BA72C; addr[3] = 0x5BA744; addr[4] = 0x5BA75C; addr[5] = 0x5BA774;
        return 0;
    }
    return GetMemory(addr[num]);
}

int ArmorQuality(int num)
{
    int addr[6];

    if (!addr[0])
    {
        addr[0] = 0x5a00a4; addr[1] = 0x5BA7A4; addr[2] = 0x5BA7BC; addr[3] = 0x5BA7D4; addr[4] = 0x5BA7EC; addr[5] = 0x5BA804;
        return 0;
    }
    return GetMemory(addr[num]);
}

int MaterialList(int num)
{
    int addr[6];

    if (!addr[0])
    {
        //Lv.3 ~ 7, null
        addr[0] = 0x5a00a4; addr[1] = 0x5ba834; addr[2] = 0x5ba84c; addr[3] = 0x5ba864; addr[4] = 0x5ba87c; addr[5] = 0x5ba894;
        return 0;
    }
    return GetMemory(addr[num]);
}

int WeaponEffect(int num)
{
    int addr[37];

    if (!addr[0])
    {
        addr[0] = 0x5a00a4;
        addr[1] = 0x5BA1BC; addr[2] = 0x5BA1D4; addr[3] = 0x5BA1EC; addr[4] = 0x5BA204; addr[5] = 0x5BA21C; addr[6] = 0x5BA234; addr[7] = 0x5BA24C; addr[8] = 0x5BA264;
        addr[9] = 0x5BA27C; addr[10] = 0x5BA294; addr[11] = 0x5BA2AC; addr[12] = 0x5BA2C4; addr[13] = 0x5BA2DC; addr[14] = 0x5BA2F4; addr[15] = 0x5BA30C; addr[16] = 0x5BA324;
        addr[17] = 0x5BA33C; addr[18] = 0x5BA354; addr[19] = 0x5BA36C; addr[20] = 0x5BA384; addr[21] = 0x5BA39C; addr[22] = 0x5BA3B4; addr[23] = 0x5BA3CC; addr[24] = 0x5BA3E4;
        addr[25] = 0x5BA3FC; addr[26] = 0x5BA414; addr[27] = 0x5BA42C; addr[28] = 0x5BA444;
        addr[29] = 0x5BA63C; addr[30] = 0x5BA654; addr[31] = 0x5BA66C; addr[32] = 0x5BA684;
        addr[33] = 0x5BA69C; addr[34] = 0x5BA6B4; addr[35] = 0x5BA6CC; addr[36] = 0x5BA6E4;
        return 0;
    }
    return GetMemory(addr[num]);
}

int ArmorEffect(int num)
{
    int addr[21];

    if (!addr[0])
    {
        addr[0] = 0x5a00a4;
        addr[1] = 0x5BA45C; addr[2] = 0x5BA474; addr[3] = 0x5BA48C; addr[4] = 0x5BA4A4; addr[5] = 0x5BA4BC; addr[6] = 0x5BA4D4; addr[7] = 0x5BA4EC; addr[8] = 0x5BA504;
        addr[9] = 0x5BA51C; addr[10] = 0x5BA534; addr[11] = 0x5BA54C; addr[12] = 0x5BA564; addr[13] = 0x5BA57C; addr[14] = 0x5BA594; addr[15] = 0x5BA5AC; addr[16] = 0x5BA5C4;
        addr[17] = 0x5BA5DC; addr[18] = 0x5BA5F4; addr[19] = 0x5BA60C; addr[20] = 0x5BA624;
        return 0;
    }
    return GetMemory(addr[num]);
}

void InitInvPropertiesSet()
{
    ImportAllowAllDrop();
    WeaponEffect(0);
    ArmorEffect(0);
    WeaponPower(0);
    ArmorQuality(0);
    MaterialList(0);
}

void CheckSpecialItem(int ptr)
{
    int id = GetMemory(ptr + 0x04);

    if (id >= 222 && id <= 225)
    {
        SetMemory(ptr + 0x2c4, 0x53a720);
        SetMemory(ptr + 0x2c8, ImportAllowAllDrop());
    }
    else if (id == 1178)
        SetMemory(GetMemory(ptr + 0x2e0), 0xffff);
    else if (id == 1168)
        SetMemory(GetMemory(ptr + 0x2e0), 0xffff);
}

void SetWeaponProperties(int ptr, int power, int mt_lv, int wfx1, int wfx2)
{
    int k;

    if (ptr)
    {
        SetMemory(GetMemory(ptr + 0x2b4), WeaponPower(power));
        SetMemory(GetMemory(ptr + 0x2b4) + 4, MaterialList(mt_lv));
        SetMemory(GetMemory(ptr + 0x2b4) + 8, WeaponEffect(wfx1));
        SetMemory(GetMemory(ptr + 0x2b4) + 12, WeaponEffect(wfx2));
        for (k = 31 ; k >= 0 ; k --)
            SetMemory(ptr + 0x230 + (k * 4), 0x200);
    }
}
void SetArmorProperties(int ptr, int qual, int mt_lv, int afx1, int afx2)
{
    int k;

    SetMemory(GetMemory(ptr + 0x2b4), ArmorQuality(qual));
    SetMemory(GetMemory(ptr + 0x2b4) + 4, MaterialList(mt_lv));
    SetMemory(GetMemory(ptr + 0x2b4) + 8, ArmorEffect(afx1));
    SetMemory(GetMemory(ptr + 0x2b4) + 12, ArmorEffect(afx2));
    for (k = 31 ; k >= 0 ; k --)
        SetMemory(ptr + 0x230 + (k * 4), 0x200);
}

int ItemDropClassHotPotion(int sUnit)
{
    return CreateObjectAt("RedPotion", GetObjectX(sUnit), GetObjectY(sUnit));
}

int ItemDropClassMagicalPotions(int sUnit)
{
    string potionList = {
        "RedPotion", "BluePotion", "CurePoisonPotion", "VampirismPotion",
        "HastePotion", "InvisibilityPotion", "InfravisionPotion", "WhitePotion",
        "ShieldPotion", "FireProtectPotion", "ShockProtectPotion", "PoisonProtectPotion",
        "YellowPotion", "BlackPotion"
        };
    return CheckPotionThingID(CreateObjectAt(ToStr(SToInt(potionList) + Random(0, 13)), GetObjectX(sUnit), GetObjectY(sUnit)));
}

int ItemDropClassWeapon(int sUnit)
{
    string weaponList = {
        "GreatSword", "Longsword", "Sword", "MorningStar",
        "OgreAxe", "StaffWooden", "BattleAxe", "FanChakram",
        "RoundChakram", "WarHammer", "OblivionHalberd", "OblivionWierdling",
        "OblivionHeart"
    };
    int weaponUnit = CreateObjectAt(ToStr(SToInt(weaponList) + Random(0, 12)), GetObjectX(sUnit), GetObjectY(sUnit));
    int weaponPtr = GetMemory(0x750710), cWave = GameClassWaveCheck();

    CheckSpecialItem(weaponPtr);
    if (cWave >= 4)
        SetWeaponProperties(weaponPtr, Random(0, 5), Random(0, 5), Random(0, 36), Random(0, 36));
    return weaponUnit;
}

int ItemDropClassArmor(int sUnit)
{
    string armorList = {
        "OrnateHelm", "Breastplate", "PlateArms", "PlateBoots",
        "PlateLeggings", "MedievalCloak", "ChainCoif", "ChainLeggings",
        "ChainTunic", "SteelHelm", "LeatherArmbands", "LeatherArmor",
        "LeatherArmoredBoots", "LeatherBoots", "LeatherHelm", "LeatherLeggings",
        "MedievalPants", "MedievalShirt"
    };
    int armorUnit = CreateObjectAt(ToStr(SToInt(armorList) + Random(0, 17)), GetObjectX(sUnit), GetObjectY(sUnit));
    int armorPtr = GetMemory(0x750710), cWave = GameClassWaveCheck();

    if (cWave >= 4)
        SetArmorProperties(armorPtr, Random(0, 5), Random(0, 5), Random(0, 20), Random(0, 20));
    return armorUnit;
}

int ItemDropClassMoney(int sUnit)
{
    int ggg = CreateObjectAt("Gold", GetObjectX(sUnit), GetObjectY(sUnit));
    int ptr = GetMemory(0x750710), incRate = GameClassWaveCheck() * 50;

    SetMemory(GetMemory(ptr + 0x2b4), Random(100 + incRate, 400 + (incRate * 4)));
    if (!(GetMemory(ptr + 0x10) & 0x40))
        SetMemory(ptr + 0x10, GetMemory(ptr + 0x10) ^ 0x40);
    return ggg;
}

int ItemDropClassGerm(int sUnit)
{
    string gmList = {"Ruby", "Ruby", "Emerald", "Diamond"};
    int germ = CreateObjectAt(ToStr(SToInt(gmList) + Random(0, GameClassWaveCheck() / 3)), GetObjectX(sUnit), GetObjectY(sUnit));
    int ptr = GetMemory(0x750710);

    if (!(GetMemory(ptr + 0x10) & 0x40))
        SetMemory(ptr + 0x10, GetMemory(ptr + 0x10) ^ 0x40);
    return germ;
}

int RewardItemFunctionTable(int pickIndex)
{
    int functions[6];

    if (pickIndex < 0)  //@initial mode
    {
        functions[0] = ItemDropClassMoney;
        functions[1] = ItemDropClassGerm;
        functions[2] = ItemDropClassArmor;
        functions[3] = ItemDropClassHotPotion;
        functions[4] = ItemDropClassMagicalPotions;
        functions[5] = ItemDropClassWeapon;
    }
    return functions[pickIndex];
}

int RewardClassItemCreateAtUnitPos(int sUnit)
{
    int pickFunction = RewardItemFunctionTable(Random(0, 5));

    if (!pickFunction)
        pickFunction = ItemDropClassHotPotion;

    return CallFunctionWithArgInt(pickFunction, sUnit);
}

void AllWaveClear(int wave)
{
    if (!GameClassMainIsShutdown())
        GameClassMainSetShutdown();
    AllPlayerTeleportTo(74);
    DrawImageAtLocation(74, 2517);
    UniPrintToAll("** *축하합니다! " + IntToString(wave) + "개의 웨이브를 클리어하셨습니다* **");
}

int LineMobFunctionInfo(int index)
{
    int fTb[34];

    if (!fTb[0])
    {
        fTb[0] = MonTypeArcher; fTb[1] = MonTypeBat; fTb[2] = MonTypeBear; fTb[3] = MonTypeFireFairy;
        fTb[4] = MonTypeFirebat; fTb[5] = MonTypeFrog; fTb[6] = MonTypeWisp; fTb[7] = MonTypeUrchin;
        fTb[8] = MonTypeSwordman; fTb[9] = MonTypeSpider; fTb[10] = MonTypeSmallSpider; fTb[11] = MonTypeSkullLord;
        fTb[12] = MonTypeShade; fTb[13] = MonTypeScorpion; fTb[14] = MonTypeOgreLord; fTb[15] = MonTypeOgreAxe;
        fTb[16] = MonTypeOgre; fTb[17] = MonTypeNecromancer; fTb[18] = MonTypeGargoyle; fTb[19] = MonTypeGhost;
        fTb[20] = MonTypeHecubah; fTb[21] = MonTypeImp; fTb[22] = MonTypeLeech; fTb[23] = MonTypeMecaFlying;
        fTb[24] = MonTypeMecaGolem; fTb[25] = MonTypeSkeleton; fTb[26] = MonTypeGoon; fTb[27] = MonTypeLichlord;
        fTb[28] = MonTypeCarnPlant; fTb[29] = MonTypeDryad; fTb[30] = MonTypeStoneGiant; fTb[31] = MonTypeHorrendous;
        fTb[32] = MonTypeHovath; fTb[33] = MonTypeJandor;
    }
    return fTb[index % 34];
}

void LineMobSetOrder(int arrPtr, int set1, int set2, int set3, int set4)
{
    SetMemory(arrPtr, set1 | (set2 << 8) | (set3 << 16) | (set4 << 24));
}

int LineMobOrder(int wave)
{
    int arr[14], link;

    if (wave < 0)
    {
        link = GetScrDataField(LineMobOrder) + 4;
        LineMobSetOrder(link, 5, 5, 1, 1);
        LineMobSetOrder(link + 4, 22, 22, 10, 10);
        LineMobSetOrder(link + 8, 8, 23, 8, 23);
        LineMobSetOrder(link + 12, 7, 9, 9, 7);     //spider, urchin
        LineMobSetOrder(link + 16, 13, 13, 26, 0);
        LineMobSetOrder(link + 20, 25, 9, 18, 19);
        LineMobSetOrder(link + 24, 14, 16, 2, 26);
        LineMobSetOrder(link + 28, 12, 27, 14, 11);
        LineMobSetOrder(link + 32, 17, 21, 3, 4);
        LineMobSetOrder(link + 36, 6, 19, 20, 24);
        LineMobSetOrder(link + 40, 28, 29, 28, 30);
        LineMobSetOrder(link + 44, 31, 32, 31, 33);
        LineMobSetOrder(link + 48, 24, 6, 27, 33);
        return 0;
    }
    return arr[wave];
}

int LineMobSpawnMarker(int index)
{
    int mark;

    if (!mark)
    {
        mark = CreateObject("ImaginaryCaster", 23);
        LookWithAngle(CreateObject("ImaginaryCaster", 24), 24);
        LookWithAngle(CreateObject("ImaginaryCaster", 25), 25);
        LookWithAngle(CreateObject("ImaginaryCaster", 26), 26);
        LookWithAngle(CreateObject("ImaginaryCaster", 27), 27);
        LookWithAngle(mark, 23);
    }
    return mark + index;
}

void LineSetInit()
{
    LineMobFunctionInfo(0);
    LineMobOrder(-1);
    LineMobSpawnMarker(0);
}

void CompleteCurrentWave()
{
    int wave = GameClassWaveCheck();

    UniPrintToAll("현재 " + IntToString(wave) + " 웨이브를 완료하셨습니다. 시작 버튼이 활성화 되었습니다");
}

void RegistItemPickEvent(int sItem, int eventFunction)
{
    int ptr = UnitToPtr(sItem);

    if (ptr)
        SetMemory(ptr + 0x300, eventFunction);
}

void RewardClassPick()
{
    if (IsObjectOn(GetTrigger() + 1))
    {
        LookWithAngle(GetTrigger() + 1, 1);
    }
}

void RewardClassDrop(int sUnit)
{
    int rwd = RewardClassItemCreateAtUnitPos(sUnit);

    ListClassAddNode(XItemNode, rwd);
    RegistItemPickEvent(rwd, RewardClassPick);
}

void LineMobDeathHandler()
{
    if (LineStatClassMobCountCheck())
    {
        LineStatClassMobCountSet(LineStatClassMobCountCheck() - 1);
        if (!LineStatClassMobCountCheck())
            CompleteCurrentWave();
    }
    LineStatClassKillCountSet(LineStatClassKillCountCheck() + 1);
    if (Random(0, 2))
        RewardClassDrop(self);
    DeleteObjectTimer(self, 90);
}

int IsPoisonedUnit(int unit)
{
    int ptr = UnitToPtr(unit);

    if (ptr)
        return GetMemory(ptr + 0x21c) & 0xff;
    return 0;
}

void LineMobHurtHandler()
{
    if (!GetCaller())
    {
        if (IsPoisonedUnit(self))
        {
            Damage(self, 0, IsPoisonedUnit(self) + 1, 5);
            DeleteObjectTimer(CreateObjectAt("GreenPuff", GetObjectX(self), GetObjectY(self)), 15);
        }
    }
}

void LineMobSightHandler()
{
    return;
}

string LineMobGreetMessage()
{
    string grt =
    "니하오?";
    "이곳 한국도 이제 중국의 일부라는 말이!";
    "중국이 대국임을 명심하고 섬겨라!";
    "그 누구든 공산주의 세력에 반대하면 용서하지 않는다!";
    "다시는 중국을 무시하지 말라!";
    "니 지금 방금 무어라 했니?";
    return ToStr(SToInt(grt) + Random(0, 5));
}

void LineMobGreetOnSight()
{
    SetCallback(self, 3, LineMobSightHandler);
    UniChatMessage(self, LineMobGreetMessage(), 180);
}

void LineMobGoToTarget(int mob)
{
    CreatureFollow(mob, MasterMonster());
    AggressionLevel(mob, 1.0);
}

int MobSummonSingle(int mobInfo, int anyUnit)
{
    int mob = CallFunctionWithArgInt(LineMobFunctionInfo((mobInfo >> (8 * Random(0, 3))) & 0xff), anyUnit);

    RetreatLevel(mob, 0.0);
    ResumeLevel(mob, 1.0);
    SetCallback(mob, 5, LineMobDeathHandler);
    SetCallback(mob, 7, LineMobHurtHandler);
    if (!Random(0, 7))
        SetCallback(mob, 3, LineMobGreetOnSight);
    FrameTimerWithArg(1, mob, LineMobGoToTarget);
    return mob;
}

void MobSummonMultiple(int mobInfo)
{
    int mark = LineMobSpawnMarker(0), i;

    for (i = 0 ; i < 5 ; i ++)
    {
        MobSummonSingle(mobInfo, mark + i);
        MoveObjectVector(mark + i, -60.0, 60.0);
    }
}

void MarkResetPosition(int mark)
{
    int i;

    for (i = 0 ; i < 5 ; i ++)
        MoveObject(mark + i, LocationX(GetDirection(mark + i)), LocationY(GetDirection(mark + i)));
}

void MobWaveClassSummon(int arg)
{
    int wave = (arg >> 4) & 0xff, count = arg & 0xf;

    if (count)
    {
        MobSummonMultiple(LineMobOrder(wave));
        count --;
        FrameTimerWithArg(1, count | (wave << 4), MobWaveClassSummon);
    }
    else
        MarkResetPosition(LineMobSpawnMarker(0));
}

void MobWaveSummonControl(int arg)
{
    int wave = (arg >> 0x4) & 0xff, count = arg & 0xf;

    if (count && !GameClassMainIsShutdown())
    {
        MobWaveClassSummon((wave << 4) | 6);
        count --;
        SecondTimerWithArg(20, count | (wave << 4), MobWaveSummonControl);
    }
    else if (GameClassLineIsStart())
        GameClassLineStartSet();
}

void MobWaveClassStart()
{
    int wave = GameClassWaveCheck();

    if (LineStatClassMobCountCheck())
    {
        UniPrintToAll("라인에 아직 남아있는 적군이 있습니다. 모두 제거 후 다시 시도하세요");
        return;
    }
    GameClassLineStartSet();
    if (wave < 12)
    {
        LineStatClassMobCountSet(300);
        RespawnLocationReset();
        GameClassWaveSet(wave + 1);
        ListClassClearCondition(ListClassGetHeadNext());
        FrameTimerWithArg(15, 10 | (wave << 4), MobWaveSummonControl);
        UniPrintToAll("** *현재 웨이브 " + IntToString(wave + 1) + "을 지금 시작합니다* **");
    }
    else
    {
        AllWaveClear(wave);
    }
}

void GGStart()
{
    MobWaveClassStart();
}

void KillLineMonster(int mob)
{
    Damage(mob, 0, MaxHealth(mob) + 1, -1);
}

void AllPlayerTeleportTo(int location)
{
    int i;

    for (i = 9 ; i >= 0 ; i --)
    {
        if (CurrentHealth(player[i]))
            MoveObject(player[i], LocationX(location), LocationY(location));
    }
}

void GGOver()
{
    if (!GameClassMainIsShutdown())
    {
        GameClassMainSetShutdown();
        AllPlayerTeleportTo(29);
        UniPrintToAll("나라가 점령당했습니다! 패배. ..");
    }
}

void MonsKeepOver()
{
    if (IsMonsterUnit(other))
    {
        if (GameClassLifeCheck())
        {
            KillLineMonster(other);
            GameClassLifeSet(GameClassLifeCheck() - 1);
            UniPrintToAll("중국인 1명이 국경을 넘었습니다!! 남은 기회: " + IntToString(GameClassLifeCheck()));
        }
        else
            GGOver();
    }
}

void ComeInHome()
{
    if (CurrentHealth(other))
    {
        if (IsPlayerUnit(other))
            MoveObject(other, LocationX(15), LocationY(15));
    }
}

string DefaultItem(int num)
{
    string item = {
        "SteelHelm", "Breastplate", "PlateArms", "PlateBoots", "PlateLeggings", "GreatSword", "RedPotion", "RedPotion", "RedPotion", "CurePoisonPotion",
        "CurePoisonPotion"}; //11
    return ToStr(SToInt(item) + num);
}

void PlaceItemOnLine(int arg)
{
    int index = arg & 0xf, count = (arg >> 4) & 0xf, location = (arg >> 8) & 0xffff, i;
    int sub = CreateObjectAt("ImaginaryCaster", LocationX(location), LocationY(location));
    string item = DefaultItem(index);

    for (i = 0 ; i < count ; i ++)
        CreateObjectAt(item, GetObjectX(sub + i) + 23.0, GetObjectY(sub + i) + 23.0);
    Delete(sub);
}

void PlaceDefaultItems(int arg)
{
    int count = arg & 0xff, location = (arg >> 8) & 0xffff;

    if (count)
    {
        PlaceItemOnLine((11 << 4) | (count % 11) | (location << 8));
        TeleportLocationVector(location, -23.0, 23.0);
        count --;
        FrameTimerWithArg(1, count | (location << 8), PlaceDefaultItems);
    }
}

int ListClassGetNext(int node)
{
    return ToInt(GetObjectZ(node));
}

void ListClassSetNext(int node, int nextNode)
{
    Raise(node, nextNode);
}

int ListClassAddNode(int prevNode, int parent)
{
    int nNode = CreateObjectAt("ImaginaryCaster", GetObjectX(parent), GetObjectY(parent));

    ListClassSetNext(nNode, ListClassGetNext(prevNode));
    ListClassSetNext(prevNode, nNode);
    return nNode;
}

void ListClassClearCondition(int node)
{
    int next;

    if (IsObjectOn(node))
    {
        next = ListClassGetNext(node);
        if (!GetDirection(node) && IsObjectOn(node - 1))
            Delete(node - 1);
        Delete(node);
        ListClassClearCondition(next);
    }
}

int ListClassGetHeadNext()
{
    return ListClassGetNext(XItemNode);
}

int OpcodeGetTargetAddr(int curAddr)
{
    return GetMemory(curAddr + 1) + curAddr + 5;
}

void ChangePlayerDeathSound(int handle, int soundNumber)
{
    SetMemory(handle + 0x258, soundNumber);
}

void OpcodeLoadEffectiveAddr(int loadAddr, int codeAddr, int offset)
{
    int targetAddr = OpcodeGetTargetAddr(codeAddr + offset);

    SetMemory(loadAddr + offset + 1, targetAddr - (loadAddr + offset) - 5);
}

void OpcodeCopiesAdvance(int destPtr, int callNodePtr, int startAddr, int endAddr)
{
    int destBase = destPtr, curAddr = startAddr;
    int vptr = GetScrDataField(OpcodeCopiesAdvance);

    while (curAddr <= endAddr)
    {
        Unused59(destPtr, Unknownb9(curAddr));
        if (Unknownb9(callNodePtr))
        {
            if (Unknownb9(callNodePtr) + 1 <= curAddr)
            {
                OpcodeLoadEffectiveAddr(destBase, startAddr, Unknownb9(callNodePtr) - startAddr);
                Unused59(vptr + 4, Unknownb9(vptr + 4) + 4);
            }
        }
        Unused59(vptr + 0x14, Unknownb9(vptr + 0x14) + 4);
        Unused59(vptr, Unknownb9(vptr) + 4);
    }
}

int DiePlayerHandlerCopiedCode()
{
    int arr[314], link;

    if (!link)
    {
        link = GetMemory(GetMemory(0x75ae28) + (0x30 * DiePlayerHandlerCopiedCode + 0x1c));
        OpcodeCopiesAdvance(link, CallNode54d2b0(), 0x54d2b0, 0x54d794);
    }
    return link;
}

void DiePlayerHandlerEntry(int plrUnit)
{
    int ptr = UnitToPtr(plrUnit);

    if (ptr)
    {
        SetMemory(ptr + 0x2d4, DiePlayerHandlerCopiedCode());
        SetMemory(ptr + 0x2e8, PlayerUpdate4f8100());       //@brief. 업데이트 핸들러 추가 28th march 2021 23:01//
    }
}

int CallNode54d2b0()
{
    int arr[40];

    if (!arr[0])
    {
        arr[0] = 0x54d2d1;
        arr[1] = 0x54d2e3;
        arr[2] = 0x54d2f3;
        arr[3] = 0x54d30a;
        arr[4] = 0x54d348;
        arr[5] = 0x54d375;
        arr[6] = 0x54d3aa;
        arr[7] = 0x54d45c;
        arr[8] = 0x54d47b;
        arr[9] = 0x54d513;
        arr[10] = 0x54d527;
        arr[11] = 0x54d566;
        arr[12] = 0x54d574;
        arr[13] = 0x54d588;
        arr[14] = 0x54d594;
        arr[15] = 0x54d5a6;
        arr[16] = 0x54d5b2;
        arr[17] = 0x54d5c4;
        arr[18] = 0x54d5d1;
        arr[19] = 0x54d5e2;
        arr[20] = 0x54d5f4;
        arr[21] = 0x54d610;
        arr[22] = 0x54d622;
        arr[23] = 0x54d62c;
        arr[24] = 0x54d639;
        arr[25] = 0x54d642;
        arr[26] = 0x54d65b;
        arr[27] = 0x54d662;
        arr[28] = 0x54d668;
        arr[29] = 0x54d67a;
        arr[30] = 0x54d680;
        arr[31] = 0x54d693;
        arr[32] = 0x54d6a6;
        arr[33] = 0x54d727;
        arr[34] = 0x54d72d;
        arr[35] = 0x54d733;
        arr[36] = 0x54d73d;
        arr[37] = 0x54d749;
        arr[38] = 0x54d782;
    }
    return GetScrDataField(CallNode54d2b0);
}

void PlayerClassDieHandlerInit(int dieSound)
{
    int ptr = DiePlayerHandlerCopiedCode();

    ChangePlayerDeathSound(ptr, dieSound);
    SetMemory(ptr + 0x386, (GetMemory(ptr + 0x386) & 0xffff0000) | 0x9eb);
}

int Callnode4f8100()
{
    int node[20], link;

    if (!link)
    {
        node[0] = 0x4f8145;
        node[1] = 0x4f816e;
        node[2] = 0x4f81ad;
        node[3] = 0x4f820b;
        node[4] = 0x4f8218;
        node[5] = 0x4f8221;
        node[6] = 0x4f826b;
        node[7] = 0x4f8326;
        node[8] = 0x4f836e;
        node[9] = 0x4f8381;
        node[10] = 0x4f8387;
        node[11] = 0x4f838f;
        node[12] = 0x4f83a3;
        node[13] = 0x4f83ac;
        node[14] = 0x4f83c3;
        node[15] = 0x4f83dc;
        node[16] = 0x4f83eb;
        node[17] = 0x4f8407;
        node[18] = 0; //nullptr
        link = GetScrDataField(Callnode4f8100);
    }
    return link;
}

int PlayerUpdate4f8100()    //@brief. 유저 업데이트 복사본
{
    int codes[200], link;

    if (!link)
    {
        link = GetScrDataField(PlayerUpdate4f8100);
        OpcodeCopiesAdvance(link, Callnode4f8100(), 0x4f8100, 0x4f8414);
        FixCallOpcode(link + 0x287, PlayerUpdate4f8460());  //@brief. 4f8460으로 링크
    }
    return link;
}

int Callnode004f7ef0()
{
    int node[21], link;

    if (!link)
    {
        node[0] = 0x4f7ef7;
        node[1] = 0x4f7f1b;
        node[2] = 0x4f7f48;
        node[3] = 0x4f7f59;
        node[4] = 0x4f7f7c;
        node[5] = 0x4f7f8b;
        node[6] = 0x4f7f98;
        node[7] = 0x4f7fb5;
        node[8] = 0x4f7fd6;
        node[9] = 0x4f7ff1;
        node[10] = 0x4f800d;
        node[11] = 0x4f801a;
        node[12] = 0x4f8028;
        node[13] = 0x4f802f;
        node[14] = 0x4f803d;
        node[15] = 0x4f8055;
        node[16] = 0x4f807a;
        node[17] = 0x4f8087;
        node[18] = 0x4f80a1;
        node[19] = 0; //nullptr
        link = GetScrDataField(Callnode004f7ef0);
    }
    return link;
}

int PlayerRespawn004f7ef0()     //@brief. 유저 리스폰 복사본
{
    int codes[115], link;

    if (!link)
    {
        link = GetScrDataField(PlayerRespawn004f7ef0);
        OpcodeCopiesAdvance(link, Callnode004f7ef0(), 0x4f7ef0, 0x4f80b4);
        SetMemory(link + 0x62, 0x16a9090);
        SetMemory(link + 0x94, (GetMemory(link + 0x94) & (~0xffff)) ^ 0x9090);
        FixCallOpcode(link + 0x9b, RedrawOnRespawn());
    }
    return link;
}

int PlayerUpdate4f8460()
{
    int arr[67], link;

    if (!link)
    {
        arr[0] = 0x530CEC83; arr[1] = 0x748B5655; arr[2] = 0x31571C24; arr[3] = 0xECBE8BC0; arr[4] = 0x89000002; arr[5] = 0x89202444; arr[6] = 0x8A142444;
        arr[7] = 0xF8835847; arr[8] = 0x83427721; arr[9] = 0x077404F8; arr[10] = 0x8C8524FF; arr[11] = 0x8B004F99; arr[12] = 0x84EA0415; arr[13] = 0x88AE8B00;
        arr[14] = 0xA1000000; arr[15] = 0x0085B3FC; arr[16] = 0xE8D1EA29; arr[17] = 0x1776C239; arr[18] = 0x00040068; arr[19] = 0x4CDEE800; arr[20] = 0xC483F28D;
        arr[21] = 0x74C08504; arr[22] = 0x90806812; arr[23] = 0x68C3004F; arr[24] = 0x004F9983; arr[25] = 0x850B68C3; arr[26] = 0x68C3004F; arr[27] = 0x00002000;
        arr[28] = 0x8D4CBBE8; arr[29] = 0x04C483F2; arr[30] = 0x4A74C085; arr[31] = 0x0114878B; arr[32] = 0x80F60000; arr[33] = 0x00000E60; arr[34] = 0x313B7501;
        arr[35] = 0x10888AC9; arr[36] = 0x51000008; arr[37] = 0x9E5227E8; arr[38] = 0x04C483F2; arr[39] = 0x2674C085; arr[40] = 0x000006BB; arr[41] = 0x08583900;
        arr[42] = 0x978B3A74; arr[43] = 0x00000114; arr[44] = 0x8AC03150; arr[45] = 0x00081082; arr[46] = 0x71E85000; arr[47] = 0x83F29E52; arr[48] = 0xC08508C4;
        arr[49] = 0x95E8DF74; arr[50] = 0x85F28D4C; arr[51] = 0x560F74C0; arr[52] = 0x00011BE8; arr[53] = 0x04C48300; arr[54] = 0x4F850B68; arr[55] = 0x8368C300;
        arr[56] = 0xC3004F99; arr[57] = 0x01148F8B; arr[58] = 0xD2310000; arr[59] = 0x0810918A; arr[60] = 0xE8520000; arr[61] = 0xF29E52A8; arr[62] = 0x5604C483;
        arr[63] = 0x9C255FE8; arr[64] = 0x04C483F2; arr[65] = 0x4F850B68; arr[66] = 0x9090C300;
        link = GetScrDataField(PlayerUpdate4f8460);
        FixCallOpcode(link + 0x4d, 0x40a5c0);
        FixCallOpcode(link + 0x70, 0x40a5c0);
        FixCallOpcode(link + 0x94, 0x51ab50);
        FixCallOpcode(link + 0xba, 0x51abc0);
        FixCallOpcode(link + 0xc6, 0x40a5f0);
        // FixCallOpcode(link + 0xd0, 0x4f7ef0);       //@todo. 여기를 서브클래싱 해줘야 한다!
        FixCallOpcode(link + 0xd0, PlayerRespawn004f7ef0());       //@brief. 서브클래싱 링크
        FixCallOpcode(link + 0xf3, 0x51ac30);
        // FixCallOpcode(link + 0xfc, 0x4f7ef0);           //@brief. todo
        FixCallOpcode(link + 0xfc, PlayerRespawn004f7ef0());           //@brief. todo
    }
    return link;
}

int RedrawOnRespawn()
{
    int arr[16], link;

    if (!link)
    {
        arr[0] = 0x50EC8B55; arr[1] = 0x758B5651; arr[2] = 0xF88E8B08; arr[3] = 0x85000001; arr[4] = 0x8B2674C9; arr[5] = 0x00251041; arr[6] = 0x85000001; arr[7] = 0x511274C0;
        arr[8] = 0x1F8AE856; arr[9] = 0x595EFFDA; arr[10] = 0x41E85651; arr[11] = 0x5EFFDA1F; arr[12] = 0xF0898B59; arr[13] = 0xEB000001; arr[14] = 0x58595ED6; arr[15] = 0x9090C35D;
        link = GetScrDataField(RedrawOnRespawn);
        FixCallOpcode(link + 0x21, 0x4f2fb0);
        FixCallOpcode(link + 0x2a, 0x4f2f70);
    }
    return link;
}

int FixCallOpcode(int curAddr, int targetAddr)
{
    SetMemory(curAddr + 1, targetAddr - curAddr - 5);
}

int ImportStreamCopy()
{
    int arr[8], link;

    if (!link)
    {
        arr[0] = 0x50515756; arr[1] = 0xDB6247E8; arr[2] = 0xE8C88BFF; arr[3] = 0xFFDB6240; arr[4] = 0x39E8F88B; arr[5] = 0x8BFFDB62; arr[6] = 0x58A5F3F0; arr[7] = 0xC35E5F59;
        link = GetMemory(GetMemory(0x75ae28) + ((0x30 * ImportStreamCopy) + 0x1c));
        FixCallOpcode(link + 4, 0x507250);
        FixCallOpcode(link + 0xb, 0x507250);
        FixCallOpcode(link + 0x12, 0x507250);
    }
    return link;
}

void StreamCopy(int src, int dst, int len)
{
    int temp = GetMemory(0x5c3320);

    SetMemory(0x5c3320, ImportStreamCopy());
    GroupRunAway(src, dst, len);
    SetMemory(0x5c3320, temp);
}

void GetWeaponMagicFxFunction(int destPtr)
{
    int code;
    int cur = GetMemory(0x75ae40);

    0x0C24448B; 0x850CEC83; 0x8B3074C0; 0x508B3848; 0x244C893C; 0x244C8B04; 0x24548910; 0x2444C708; 0x00000000;
    0x30518B00; 0x00244C8D; 0x50505152; 0xE80A6A50; 0x0004CF98; 0x8318C483; 0x90C30CC4;
    code = 0x979740 + ((cur - 1) * 4);
    StreamCopy(code, destPtr, 16);
    FixCallOpcode(destPtr + 0x33, 0x4fdd20);
}

int WeaponMagicFxFunctionPtr(int spellNumber)
{
    int code[17], link;

    if (!link)
    {
        link = GetMemory(GetMemory(0x75ae28) + ((0x30 * WeaponMagicFxFunctionPtr) + 0x1c)) + 4;
        GetWeaponMagicFxFunction(link);
        SetMemory(link + 0x30, (GetMemory(link + 0x30) & 0xff00ffff) ^ ((spellNumber & 0x7f) << 0x10));
    }
    return link;
}

int WeaponClassPropertyExecScript()
{
    int arr[13], link;

    if (!link)
    {
        arr[0] = 0x24448D50; arr[1] = 0xEC83520C; arr[2] = 0x85108B0C; arr[3] = 0x501C74D2; arr[4] = 0x02FC828B; arr[5] = 0x44890000;
        arr[6] = 0x89580424; arr[7] = 0x8B082454; arr[8] = 0x44890440; arr[9] = 0xE5E80424; arr[10] = 0x83FFDB62; arr[11] = 0x585A0CC4;
        arr[12] = 0x000090C3;
        link = GetMemory(GetMemory(0x75ae28) + ((0x30 * WeaponClassPropertyExecScript) + 0x1c));
        FixCallOpcode(link + 0x26, 0x507310);
    }
    return link;
}

int WeaponClassCProperty1Code()
{
    int code[21], call1 = 0x4e0702, call2 = 0x4e0722, call3 = 0x4e0731, nop;
    int link;

    if (!link)
    {
        link = GetMemory(GetMemory(0x75ae28) + (0x30 * WeaponClassCProperty1Code + 0x1c));
        OpcodeCopiesAdvance(link, link + (21 * 4), 0x4e06f0, 0x4e073c);

        SetMemory(link + 46, 0x83);
        SetMemory(link + 61, 97);
    }
    return link;
}

int WeaponClassCProperty1Table()
{
    int dat[36], link;

    if (!link)
    {
        dat[0] = GetMemory(0x97bb40 + (SToInt("Fire4") * 4));
        dat[1] = 0x61; dat[6] = 0xb40000; dat[5] = 0x4b0; dat[7] = 0x1b2ff2; dat[9] = 1;
        dat[10] = WeaponMagicFxFunctionPtr(27);
        dat[13] = WeaponClassCProperty1Code();
        dat[14] = ToInt(12.0);
        link = GetMemory(GetMemory(0x75ae28) + (0x30 * WeaponClassCProperty1Table + 0x1c));
    }
    return link;
}

int WeaponClassCProperty2Table()
{
    int dat[36], link;

    if (!link)
    {
        dat[0] = GetMemory(0x97bb40 + (SToInt("Fire4") * 4));
        dat[1] = 0x61; dat[6] = 0xb40000; dat[5] = 0x4b0; dat[7] = 0x1b2ff2; dat[9] = 1;
        dat[10] = WeaponClassPropertyExecScript();
        dat[13] = WeaponClassCProperty1Code();
        dat[14] = ToInt(8.0);
        link = GetMemory(GetMemory(0x75ae28) + (0x30 * WeaponClassCProperty2Table + 0x1c));
    }
    return link;
}

void WeaponClassAddProperties(int weapon, int slot, int propertyPtr)
{
    int ptr = UnitToPtr(weapon);

    if (ptr)
        SetMemory(GetMemory(ptr + 0x2b4) + ((slot % 4) * 4), propertyPtr);
}

void EquipClassSetDrawable(int equipment)
{
    int ptr = UnitToPtr(equipment), i;

    if (ptr)
    {
        for (i = 31 ; i >= 0 ; i --)
            SetMemory(ptr + 0x230 + (i * 4), 0x200);
    }
}

int ImportTellStoryUniNamePartB()
{
    int arr[84], link;

    if (!link)
    {
        arr[0] = 0x0424448B; arr[1] = 0x0824548B; arr[2] = 0x008CEC81; arr[3] = 0xC0850000; arr[4] = 0xEC9A8B53; arr[5] = 0x55000002; arr[6] = 0x02ECA88B;
        arr[7] = 0x0F570000; arr[8] = 0x00012184; arr[9] = 0x0840F600; arr[10] = 0x17840F04; arr[11] = 0x8B000001; arr[12] = 0x00A824BC; arr[13] = 0xFF850000;
        arr[14] = 0x0108840F; arr[15] = 0xC9830000; arr[16] = 0x89C033FF; arr[17] = 0x00011C95; arr[18] = 0xAEF25600; arr[19] = 0x748DD1F7; arr[20] = 0xF92B1624;
        arr[21] = 0x7489C18B; arr[22] = 0xF78B1024; arr[23] = 0x10247C8B; arr[24] = 0xC602E9C1; arr[25] = 0xD0142444; arr[26] = 0x152444C6; arr[27] = 0x8BA5F303;
        arr[28] = 0x5CC868C8; arr[29] = 0x1F6A0056; arr[30] = 0xF303E183; arr[31] = 0xC9C8B8A4; arr[32] = 0x4C8D0069; arr[33] = 0x51503E24; arr[34] = 0x0C2454FF;
        arr[35] = 0xB824848B; arr[36] = 0x66000000; arr[37] = 0x842484C7; arr[38] = 0x00000000; arr[39] = 0x38938A00; arr[40] = 0x8D000008; arr[41] = 0x00083ABB;
        arr[42] = 0x24948800; arr[43] = 0x000000AA; arr[44] = 0x86248489; arr[45] = 0x8A000000; arr[46] = 0x10C48307; arr[47] = 0x2374C084; arr[48] = 0x31FFC983;
        arr[49] = 0xF7AEF2C0; arr[50] = 0x8DCF29D1; arr[51] = 0x8B7A2454; arr[52] = 0x8BF78BC1; arr[53] = 0x02E9C1FA; arr[54] = 0xC88BA5F3; arr[55] = 0xF303E183;
        arr[56] = 0x8B2FEBA4; arr[57] = 0x5CD1640D; arr[58] = 0x68158B00; arr[59] = 0xA1005CD1; arr[60] = 0x005CD16C; arr[61] = 0x7A244C89; arr[62] = 0x700D8B66;
        arr[63] = 0x89005CD1; arr[64] = 0x897E2454; arr[65] = 0x00822484; arr[66] = 0x89660000; arr[67] = 0x0086248C; arr[68] = 0x858B0000; arr[69] = 0x00000114;
        arr[70] = 0x4E542068; arr[71] = 0x31016A00; arr[72] = 0x8A006AC9; arr[73] = 0x00081088; arr[74] = 0x24548D00; arr[75] = 0x00876820; arr[76] = 0x51520000;
        arr[77] = 0x142454FF; arr[78] = 0xB424948B; arr[79] = 0x6A000000; arr[80] = 0xC4835200; arr[81] = 0x5D5F5E20; arr[82] = 0x8CC4815B; arr[83] = 0xC3000000;
		link = GetMemory(GetMemory(0x75ae28) + (0x30 * ImportTellStoryUniNamePartB + 0x1c));
    }
    return link;
}

int ImportTellStoryUniNamePartA()
{
    int arr[19], link;

    if (!link)
    {
        arr[0] = 0x8DE06856; arr[1] = 0x50680054; arr[2] = 0xFF005072; arr[3] = 0xF08B2414; arr[4] = 0x8B2414FF; 
        arr[5] = 0xBB40B50C; arr[6] = 0x148B0097; arr[7] = 0x97BB4085; arr[8] = 0x50685100; arr[9] = 0x520040AF; 
        arr[10] = 0x042454FF; arr[11] = 0x97200D8B; arr[12] = 0xC4830097; arr[13] = 0x24A15008; arr[14] = 0x50009797; 
        arr[15] = 0x2454FF51; arr[16] = 0x10C48314; arr[17] = 0xC483C031; arr[18] = 0x90C35E08;
		link = GetMemory(GetMemory(0x75ae28) + (0x30 * ImportTellStoryUniNamePartA + 0x1c));
        SetMemory(link + 2, ImportTellStoryUniNamePartB());
    }
    return link;
}

void TellStoryUnitName(string sAudio, string sDesc, string sUnitName)
{
    int temp = GetMemory(0x5c3290), src = GetMemory(0x97bb40 + (SToInt(sUnitName) * 4));

    SetMemory(0x5c3290, ImportTellStoryUniNamePartA());
    NoxUtf8ToUnicode(src, 0x69C9C8);
    TellStory(sAudio, sDesc);
    SetMemory(0x5c3290, temp);
}

int PowerItemMagicMisHammer(int anyArg)
{
    int xyTable = AnyargUnitOrLocation(anyArg);
    int weapon = CreateObjectAt("WarHammer", GetMemoryFloat(xyTable), GetMemoryFloat(xyTable + 4));

    WeaponClassAddProperties(weapon, 2, WeaponClassCProperty1Table());
    EquipClassSetDrawable(weapon);
    return weapon;
}

int PowerItemFireSword(int anyArg)
{
    int xyTable = AnyargUnitOrLocation(anyArg);
    int weapon = CreateObjectAt("GreatSword", GetMemoryFloat(xyTable), GetMemoryFloat(xyTable + 4));
    int ptr = GetMemory(0x750710);

    if (ptr)
        SetMemory(ptr + 0x2fc, MagicMissileSword);
    WeaponClassAddProperties(weapon, 2, WeaponClassCProperty2Table());
    EquipClassSetDrawable(weapon);
    return weapon;
}

void ShopClassItemDesc()
{
    int remArg = ToInt(GetObjectZ(GetTrigger() + 1)), pay = GetDirection(GetTrigger() + 1) * 1000;
    int dtStr = ToInt(GetObjectZ(GetTrigger() + 2));
    string itemName = ToStr((remArg >> 10) & 0x3ff);

    TellStoryUnitName("oAo", ToStr((dtStr >> 10)& 0x3ff), itemName + "구입");
    UniPrint(other, itemName + "을 구입하시겠어요? 이 작업은" + IntToString(pay) + "골드를 요구합니다");
    UniPrint(other, "거래를 계속 하시려면 '예' 버튼을 누르세요");
}

void ShopClassKeeperRegistDialog(int kp)
{
    SetDialog(kp, "YESNO", ShopClassItemDesc, ShopClassItemTrade);
}

void ShopClassTradeResult()
{
    ShopClassKeeperRegistDialog(self);
}

void ShopClassTradeResultD()
{
    return;
}

void ShopClassItemTrade()
{
    int remArg = ToInt(GetObjectZ(GetTrigger() + 1)), pay = GetDirection(GetTrigger() + 1) * 1000;
    string tradeStr = ToStr((ToInt(GetObjectZ(GetTrigger() + 2)) >> 20) & 0x3ff);
    string itemName = ToStr((remArg >> 10) & 0x3ff);

    if (GetAnswer(self) ^ 1) return;
    if (GetGold(other) >= pay)
    {
        ChangeGold(other, -pay);
        CallFunctionWithArgInt((remArg >> 20) & 0x3ff, other);
        SetDialog(self, "NORMAL", ShopClassTradeResultD, ShopClassTradeResultD);
        TellStoryUnitName("oAo", tradeStr, itemName + "구입완료");
        ShopClassKeeperRegistDialog(self);
        UniPrint(other, "거래가 완료되었습니다! 구입하신 " + itemName + "은 당신 발 아래에 있어요");
    }
    else
        UniPrint(other, "거래가 취소되었습니다. 사유: 잔액 부족");
}

int DeadUnitCreateAtUnitPos(int sUnit, string unitName)
{
    int dead = CreateObjectAt(unitName, GetObjectX(sUnit), GetObjectY(sUnit));

    ObjectOff(dead);
    Damage(dead, 0, CurrentHealth(dead) + 1, -1);
    return dead;
}

int DeadUnitCreateAt(float xProfile, float yProfile, string unitName)
{
    int dead = CreateObjectAt(unitName, xProfile, yProfile);

    ObjectOff(dead);
    Damage(dead, 0, CurrentHealth(dead) + 1, -1);
    return dead;
}

int DeadUnitCreate(int location, string unitName)
{
    int dead = CreateObjectAt(unitName, LocationX(location), LocationY(location));

    ObjectOff(dead);
    Damage(dead, 0, CurrentHealth(dead) + 1, -1);
    return dead;
}

int ShopClassPlaceShopkeeper(int loLochiPay, int remArg, int dtStr)
{
    int location = loLochiPay & 0x3ff;
    int kp = DeadUnitCreate(location, ToStr(remArg & 0x3ff));

    Frozen(CreateObjectAt("ImaginaryCaster", LocationX(location), LocationY(location)) - 1, 1);
    Raise(CreateObjectAt("ImaginaryCaster", LocationX(location), LocationY(location)) - 1, remArg);
    Raise(kp + 2, dtStr);
    LookWithAngle(kp + 1, (loLochiPay >> 10) & 0xff);
    ShopClassKeeperRegistDialog(kp);
    StoryPic(kp, ToStr(dtStr & 0x3ff));
    return kp;
}

void ShopClassInitPlace()
{
    ShopClassPlaceShopkeeper(83 | (99 << 10), SToInt("Mimic") | (SToInt("부처님 완드") << 10) | (PlaceBucherStaff << 20),
        SToInt("HorrendousPic") | (SToInt("NoxDemo:BuyNox") << 10) | (SToInt("GUITrade.c:TradeVendorAccept") << 20));
    ShopClassPlaceShopkeeper(35 | (43 << 10), SToInt("Horrendous") | (SToInt("오우거로드엑스") << 10) | (PlaceAxeForOgre << 20),
        SToInt("HorrendousPic") | (SToInt("NoxDemo:BuyNox") << 10) | (SToInt("GUITrade.c:TradeVendorAccept") << 20));
    ShopClassPlaceShopkeeper(31 | (40 << 10), SToInt("Wizard") | (SToInt("화이어볼 해머\n") << 10) | (PowerItemMagicMisHammer << 20),
        SToInt("AirshipCaptainPic") | (SToInt("NoxDemo:BuyNox") << 10) | (SToInt("GUITrade.c:TradeVendorAccept") << 20));
    ShopClassPlaceShopkeeper(32 | (38 << 10), SToInt("EmberDemon") | (SToInt("마법미사일 서드\n") << 10) | (PowerItemFireSword << 20),
        SToInt("DemonPic") | (SToInt("NoxDemo:BuyNox") << 10) | (SToInt("GUITrade.c:TradeVendorAccept") << 20));
    ShopClassPlaceShopkeeper(33 | (42 << 10), SToInt("Archer") | (SToInt("화살서드\n") << 10) | (PlaceArrowSword << 20),
        SToInt("GerardPic") | (SToInt("NoxDemo:BuyNox") << 10) | (SToInt("GUITrade.c:TradeVendorAccept") << 20));
    ShopClassPlaceShopkeeper(34 | (47 << 10), SToInt("WizardWhite") | (SToInt("드레인서드\n") << 10) | (PlaceDrainSword << 20),
        SToInt("HorvathPic") | (SToInt("NoxDemo:BuyNox") << 10) | (SToInt("GUITrade.c:TradeVendorAccept") << 20));
    ShopClassPlaceShopkeeper(36 | (48 << 10), SToInt("WizardGreen") | (SToInt("포오네서드\n") << 10) | (PlaceFonSword << 20),
        SToInt("DryadPic") | (SToInt("War08z:EstimatedGoodies") << 10) | (SToInt("GUITrade.c:TradeVendorAccept") << 20));
    ShopClassPlaceShopkeeper(37 | (44 << 10), SToInt("Spider") | (SToInt("유도탄 메이스\n") << 10) | (PlaceAutoMissileMace << 20),
        SToInt("CreatureCageSpider") | (SToInt("thing.db:SPELL_MAGIC_MISSILE_DESC") << 10) | (SToInt("GUITrade.c:TradeVendorAccept") << 20));
    ShopClassPlaceShopkeeper(54 | (53 << 10), SToInt("Beholder") | (SToInt("자동타겟\n데스레이서드\n") << 10) | (PlaceAutoTargetSword << 20),
        SToInt("MaleStaffDeathRay") | (SToInt("thing.db:DeathRay") << 10) | (SToInt("GUITrade.c:TradeVendorAccept") << 20));
    ShopClassPlaceShopkeeper(62 | (12 << 10), SToInt("Lich") | (SToInt("아마겟돈 목걸이\n1회용\n") << 10) | (PlaceMeteorAmulet << 20),
        SToInt("MaleStaffDeathRay") | (SToInt("thing.db:SPELL_METEOR_DESC") << 10) | (SToInt("GUITrade.c:TradeVendorAccept") << 20));
    ShopClassPlaceShopkeeper(65 | (11 << 10), SToInt("Demon") | (SToInt("용의숨결지팡이\n") << 10) | (PlaceDemonWand << 20),
        SToInt("MaleStaffDeathRay") | (SToInt("thing.db:LesserFireballWandDescription") << 10) | (SToInt("GUITrade.c:TradeVendorAccept") << 20));
}

int GreenFrogBinTable()
{
	int arr[62], link;
	if (!link)
	{
		arr[0] = 1701147207; arr[1] = 1869760110; arr[2] = 103; arr[17] = 35; arr[19] = 64; 
		arr[21] = 1065353216; arr[23] = 32769; arr[24] = 1067869798; arr[25] = 1; arr[26] = 1; 
		arr[28] = 1103626240; arr[29] = 8; arr[31] = 10; arr[32] = 14; arr[33] = 24; 
		arr[59] = 5542784; arr[60] = 1313; arr[61] = 46905856; 
		link = GetMemory(GetMemory(0x75ae28) + (0x30 * GreenFrogBinTable + 0x1c));
	}
	return link;
}

void GreenFrogSubProcess(int sUnit)
{
	int ptr = UnitToPtr(sUnit);

	if (ptr)
	{
		SetMemory(ptr + 0x220, 1073070735);
		SetMemory(ptr + 0x224, 1073070735);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x5a0, 32769);
		SetMemory(GetMemory(ptr + 0x22c), 35);
		SetMemory(GetMemory(ptr + 0x22c) + 0x4, 35);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x1e4, GreenFrogBinTable());
		SetMemory(GetMemory(ptr + 0x2ec) + 0x54c, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x538, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x540, 1065353216);
	}
}

void UnitLinkBinScript(int unit, int binScrAddr)
{
    int ptr = UnitToPtr(unit);

    if (ptr)
        SetMemory(GetMemory(ptr + 0x2ec) + 0x1e4, binScrAddr);
}

int WeaponClassCProperty3Table()
{
    int dat[36], link;

    if (!link)
    {
        dat[0] = GetMemory(0x97bb40 + (SToInt("Fire4") * 4));
        dat[1] = 0x61; dat[6] = 0xb40000; dat[5] = 0x4b0; dat[7] = 0x1b2ff2; dat[9] = 1;
        dat[10] = WeaponClassPropertyExecScript();
        dat[13] = WeaponClassCProperty1Code();
        dat[14] = ToInt(4.0);
        link = GetMemory(GetMemory(0x75ae28) + (0x30 * WeaponClassCProperty3Table + 0x1c));
    }
    return link;
}

void WeaponExecScript1()
{
    int arw = CreateObjectAt("ArcherArrow", GetObjectX(other) + UnitAngleCos(other, 8.0), GetObjectY(other) + UnitAngleSin(other, 8.0));

    LookWithAngle(arw, GetDirection(other));
    SetOwner(other, arw);
    PushObject(arw, 34.0, GetObjectX(other), GetObjectY(other));
}

void DrainTouched()
{
    int owner = GetOwner(self);

    while (owner)
    {
        if (CurrentHealth(other) && IsAttackedBy(other, owner))
        {
            Damage(other, owner, 100, 7);
            Effect("RICOCHET", GetObjectX(self), GetObjectY(self), 0.0, 0.0);
        }
        else if (!GetCaller())
            1;
        else
            break;
        Delete(self);
        break;
    }
}

void NatureShotCollide()
{
    int owner = GetOwner(self);

    while (owner)
    {
        if (CurrentHealth(other) && IsAttackedBy(other, owner))
        {
            Damage(other, owner, 210, 14);
            Effect("RICOCHET", GetObjectX(self), GetObjectY(self), 0.0, 0.0);
        }
        else if (!GetCaller())
            1;
        else
            break;
        Delete(self);
        break;
    }
}

void OgreJinCollide()
{
    int owner = GetOwner(self);

    while (owner)
    {
        if (CurrentHealth(other) && IsAttackedBy(other, owner))
        {
            Damage(other, owner, 130, 14);
            Enchant(other, EnchantList(28), 0.3);
            Effect("RICOCHET", GetObjectX(self), GetObjectY(self), 0.0, 0.0);
            break;
        }
        else if (!GetCaller())
            1;
        else
            break;
        Delete(self);
        break;
    }
}

void BreakingBarrelFx(int owner, float xProfile, float yProfile)
{
    int subD = DeadUnitCreateAt(xProfile, yProfile, "Necromancer");

    Frozen(subD, 1);
    SetCallback(CreateObjectAt("PiledBarrels3Breaking", xProfile, yProfile) - 1, 9, OgreJinCollide);
    DeleteObjectTimer(subD, 1);
    SetOwner(owner, subD);
}

void AxeJinHandler(int sub)
{
    float xVect = GetObjectZ(sub), yVect = GetObjectZ(sub + 1);
    int amount = GetDirection(sub), owner = GetOwner(sub), i;

    for (i = amount ; i ; i --)
    {
        if (IsVisibleTo(sub, sub + 1))
        {
            MoveObjectVector(sub, xVect, yVect);
            BreakingBarrelFx(owner, GetObjectX(sub), GetObjectY(sub));
        }
        else
        {
            break;
        }
    }
    Delete(sub);
    Delete(sub + 1);
}

void BreakingAxeJin()
{
    float xVect = UnitAngleCos(other, 21.0), yVect = UnitAngleSin(other, 21.0);
    int sub = CreateObjectAt("InvisibleLightBlueLow", GetObjectX(other) + xVect, GetObjectY(other) + yVect);

    FrameTimerWithArg(1, sub, AxeJinHandler);
    Raise(sub, xVect);
    Raise(CreateObjectAt("InvisibleLightBlueLow", GetObjectX(sub), GetObjectY(sub)), yVect);
    LookWithAngle(sub, 12);
    SetOwner(other, sub);
}

void DrainSubUnitCreate(int sub, int owner)
{
    int dm = DeadUnitCreateAtUnitPos(sub, "Troll");

    Frozen(dm, 1);
    DeleteObjectTimer(dm, 1);
    SetCallback(dm, 9, DrainTouched);
    SetOwner(owner, dm);
}

void DrainSwordHandler(int sub)
{
    int count = GetDirection(sub), owner = GetOwner(sub);

    while (IsObjectOn(sub))
    {
        if (count && CurrentHealth(owner))
        {
            if (IsVisibleTo(sub, sub + 1))
            {
                FrameTimerWithArg(1, sub, DrainSwordHandler);
                LookWithAngle(sub, count - 1);
                DrainSubUnitCreate(sub, owner);
                MoveObjectVector(sub, GetObjectZ(sub), GetObjectZ(sub + 1));
                Effect("CHARM", GetObjectX(sub), GetObjectY(sub), GetObjectX(sub + 1), GetObjectY(sub + 1));
                Effect("CHARM", GetObjectX(sub + 1), GetObjectY(sub + 1), GetObjectX(sub), GetObjectY(sub));
                break;
            }
        }
        Delete(sub);
        Delete(sub + 1);
        break;
    }
}

void DrainSwordFx()
{
    float xVect = UnitAngleCos(other, 19.0),yVect = UnitAngleSin(other, 19.0);
    int sub = CreateObjectAt("InvisibleLightBlueLow", GetObjectX(other) + xVect, GetObjectY(other) + yVect);

    FrameTimerWithArg(1, sub, DrainSwordHandler);
    LookWithAngle(CreateObjectAt("InvisibleLightBlueLow", GetObjectX(sub), GetObjectY(sub)) - 1, 18);
    SetOwner(other, sub);
    Raise(sub, xVect);
    Raise(sub + 1, yVect);
}

void MagicMissileSword()
{
    float xVect = UnitAngleCos(other, 23.0), yVect = UnitAngleSin(other, 23.0);
    int sub = CreateObjectAt("ImaginaryCaster", GetObjectX(other) + xVect, GetObjectY(other) + yVect);

    SetOwner(other, sub);
    CastSpellObjectLocation("SPELL_MAGIC_MISSILE", sub, GetObjectX(sub) + xVect, GetObjectY(sub) + yVect);
    DeleteObjectTimer(sub, 90);
}

void ForceOfNatureShot()
{
    float xVect = UnitAngleCos(other, 16.0), yVect = UnitAngleSin(other, 16.0);
    int mis = CreateObjectAt("DeathBall", GetObjectX(other) + xVect, GetObjectY(other) + yVect);
    int ptr = GetMemory(0x750710);

    SetOwner(other, mis);
    SetMemory(ptr + 0x2e8, 5483536); //projectile update
    SetMemory(ptr + 0x2b8, ImportUnitCollideFunc());
    SetMemory(ptr + 0x2fc, NatureShotCollide);
    PushObject(mis, 30.0, GetObjectX(other), GetObjectY(other));
}

int MakeMagicMissile(string misName, int owner)
{
    float xVect = UnitAngleCos(owner, 18.0), yVect = UnitAngleSin(owner, 18.0);
    int target = CreateObjectAt("ImaginaryCaster", GetObjectX(owner) + (xVect * 10.0), GetObjectY(owner) + (yVect * 10.0));
    int mis = CreateObjectAt(misName, GetObjectX(owner) + xVect, GetObjectY(owner) + yVect);
    int ptr = GetMemory(0x750710);
    int ecPtr;
    int casterPtr = UnitToPtr(target);

    DeleteObjectTimer(target, 3);
    if (ptr)
    {
        SetOwner(owner, mis);
        SetMemory(ptr + 0x220, ToInt(3.6)); //Speed
        SetMemory(ptr + 0x224, 0); //accel
        ecPtr = MemAlloc(20);
        SetMemory(ecPtr, UnitToPtr(owner));
        SetMemory(ecPtr + 4, casterPtr);
        SetMemory(ptr + 0x2ec, ecPtr);
        SetMemory(ptr + 0x2e8, 5488032);
    }
    return mis;
}

void AutoDetectMissileCollide()
{
    int owner = GetOwner(self);

    while (owner)
    {
        if (CurrentHealth(other) && IsAttackedBy(other, owner))
        {
            Damage(other, owner, 230, 7);
            Effect("LESSER_EXPLOSION", GetObjectX(self), GetObjectY(self), 0.0, 0.0);
        }
        else if (!GetCaller())
            1;
        else
            break;
        Delete(self);
        break;
    }
}

void ShotAutoDetectMissile()
{
    int mis = MakeMagicMissile("Pixie", other);
    int ptr = GetMemory(0x750710);

    if (ptr)
    {
        PlaySoundAround(other, 348);
        SetMemory(ptr + 0x2b8, ImportUnitCollideFunc());
        SetMemory(ptr + 0x2fc, AutoDetectMissileCollide);
    }
}

void WeaponClassCProperty1Entry(int wUnit, int slot, int execFunctionNumber, int tablePtr)
{
    int ptr = UnitToPtr(wUnit);

    if (ptr)
    {
        SetMemory(ptr + 0x2fc, execFunctionNumber);
        SetMemory(GetMemory(ptr + 0x2b4) + (slot * 4), tablePtr);
    }
}

int WizardRedBinTable()
{
	int arr[62], link;
	if (!link)
	{
		arr[0] = 1635412311; arr[1] = 1699898482; arr[2] = 100; arr[17] = 300; arr[18] = 100; 
		arr[19] = 50; arr[21] = 1065353216; arr[23] = 34816; arr[24] = 1067869798; arr[26] = 4; 
		arr[28] = 1128792064; arr[29] = 20; arr[31] = 16; arr[32] = 8; arr[33] = 15; 
		arr[53] = 1128792064; arr[54] = 4; arr[59] = 5542784; 
		link = GetMemory(GetMemory(0x75ae28) + (0x30 * WizardRedBinTable + 0x1c));
	}
	return link;
}

void WizardRedSubProcess(int sUnit)
{
	int ptr = UnitToPtr(sUnit);

	if (ptr)
	{
		SetMemory(ptr + 0x220, 1069547520);
		SetMemory(ptr + 0x224, 1069547520);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x5a0, 34816);
		SetMemory(GetMemory(ptr + 0x22c), 700);
		SetMemory(GetMemory(ptr + 0x22c) + 0x4, 700);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x1e4, WizardRedBinTable());
		SetMemory(GetMemory(ptr + 0x2ec) + 0x54c, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x538, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x540, 1065353216);
        RegistryUnitStrikeFunction(sUnit, RedWizStrikeTrigger);
	}
}

int HecubahWithOrbBinTable()
{
	int arr[62], link;
	if (!link)
	{
		arr[0] = 1969448264; arr[1] = 1466458466; arr[2] = 1332245609; arr[3] = 25202; arr[17] = 700; 
		arr[19] = 85; arr[21] = 1065353216; arr[23] = 65536; arr[25] = 1; arr[26] = 2; 
		arr[28] = 1128792064; arr[29] = 20; arr[31] = 16; arr[32] = 5; 
		arr[33] = 11; arr[59] = 5542784; arr[60] = 1384; arr[61] = 46914560; 
		link = GetMemory(GetMemory(0x75ae28) + (0x30 * HecubahWithOrbBinTable + 0x1c));
	}
	return link;
}

void HecubahWithOrbSubProcess(int sUnit)
{
	int ptr = UnitToPtr(sUnit);

	if (ptr)
	{
		SetMemory(ptr + 0x220, 1076048691);
		SetMemory(ptr + 0x224, 1076048691);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x5a0, 65536);
		SetMemory(GetMemory(ptr + 0x22c), 700);
		SetMemory(GetMemory(ptr + 0x22c) + 0x4, 700);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x1e4, HecubahWithOrbBinTable());
		SetMemory(GetMemory(ptr + 0x2ec) + 0x54c, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x538, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x540, 1065353216);
        RegistryUnitStrikeFunction(sUnit, OrbHecubahStrikeTrigger);
	}
}

int MechanicalGolemBinTable()
{
	int arr[62], link;
	if (!link)
	{
		arr[0] = 1751344461; arr[1] = 1667853921; arr[2] = 1866951777; arr[3] = 7169388; arr[17] = 800; 
		arr[19] = 55; arr[21] = 1065353216; arr[23] = 1; arr[24] = 1067869798; arr[26] = 4; 
		arr[27] = 5; arr[28] = 1112014848; arr[29] = 100; arr[30] = 1120403456; arr[31] = 2; 
		arr[32] = 24; arr[33] = 48; arr[58] = 5545616; arr[59] = 5544288; arr[60] = 1318; 
		arr[61] = 46900992; 
		link = GetMemory(GetMemory(0x75ae28) + (0x30 * MechanicalGolemBinTable + 0x1c));
	}
	return link;
}

void MechanicalGolemSubProcess(int sUnit)
{
	int ptr = UnitToPtr(sUnit);

	if (ptr)
	{
		SetMemory(ptr + 0x220, 1070805811);
		SetMemory(ptr + 0x224, 1070805811);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x5a0, 1);
		SetMemory(GetMemory(ptr + 0x22c), 800);
		SetMemory(GetMemory(ptr + 0x22c) + 0x4, 800);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x1e4, MechanicalGolemBinTable());
		SetMemory(GetMemory(ptr + 0x2ec) + 0x54c, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x538, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x540, 1065353216);
	}
}

int CarnivorousPlantBinTable()
{
	int arr[62], link;
	if (!link)
	{
		arr[0] = 1852989763; arr[1] = 1919907433; arr[2] = 1349743983; arr[3] = 1953390956; arr[17] = 800; 
		arr[19] = 84; arr[21] = 1065353216; arr[23] = 32768; arr[24] = 1065353216; arr[25] = 1; 
		arr[26] = 2; arr[27] = 5; arr[28] = 1109393408; arr[29] = 150; arr[31] = 8; 
		arr[59] = 5542784; arr[60] = 1371; arr[61] = 46901760; 
		link = GetMemory(GetMemory(0x75ae28) + (0x30 * CarnivorousPlantBinTable + 0x1c));
	}
	return link;
}

void CarnivorousPlantSubProcess(int sUnit)
{
	int ptr = UnitToPtr(sUnit);

	if (ptr)
	{
		SetMemory(ptr + 0x220, 1075922862);
		SetMemory(ptr + 0x224, 1075922862);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x5a0, 32768);
		SetMemory(GetMemory(ptr + 0x22c), 800);
		SetMemory(GetMemory(ptr + 0x22c) + 0x4, 800);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x1e4, CarnivorousPlantBinTable());
		SetMemory(GetMemory(ptr + 0x2ec) + 0x54c, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x538, 0);
		SetMemory(GetMemory(ptr + 0x2ec) + 0x540, 1065353216);
	}
}

void CreClassRevive(int sub)
{
    int time = GetDirection(sub), nameProcF;
    int cre;

    while (1)
    {
        if (GetDirection(sub))
        {
            FrameTimerWithArg(2, sub, CreClassRevive);
            LookWithAngle(sub, time - 1);
            break;
        }
        else
        {
            nameProcF = ToInt(GetObjectZ(sub));
            cre = CreClassSummon(nameProcF, sub);
            CreClassCommonProperty(cre, GetOwner(sub));
            UniChatMessage(cre, "크리쳐 부활했당!\n한꺼번에 다 덤벼봐랑!", 120);
            Delete(sub);
        }
        Delete(sub);
        break;
    }
}

void CreClassDeath()
{
    int sub = GetTrigger() + 1;

    MoveObject(sub, GetObjectX(self), GetObjectY(self));
    DeleteObjectTimer(self, 120);
    LookWithAngle(sub, 250); //TODO: Revive Timer
    FrameTimerWithArg(3, sub, CreClassRevive);
    UniChatMessage(self, "크리쳐가 적에게 피습당함...\n잠시 후 부활합니다", 150);
}

int CreClassSummon(int nameProcF, int anyArg)
{
    int xyTable = AnyargUnitOrLocation(anyArg), procF = (nameProcF >> 10) & 0x3ff;
    int cre, subF = (nameProcF >> 20) & 0x3ff;

    cre = CreateObjectAt(ToStr(nameProcF & 0x3ff), GetMemoryFloat(xyTable), GetMemoryFloat(xyTable + 4));
    if (cre)
    {
        if (procF)
            CallFunctionWithArg(procF, CreateObjectAt("ImaginaryCaster", GetObjectX(cre), GetObjectY(cre)) - 1);
        if (subF)
            CallFunctionWithArg(subF, cre);
        SetCallback(cre, 5, CreClassDeath);
        Enchant(cre, EnchantList(30), 0.0);
        Raise(cre + 1, nameProcF);
    }
    return cre;
}

int CreClassSummonBuffer(int nameProcF, int anyArg)
{
    if (CreClassGetCurrentCount() < 30)
    {
        CreClassIncreaseCurrentCount();
        return CreClassSummon(nameProcF, anyArg);
    }
    return 0;
}

void CreClassGuardMode(int cre, int caster)
{
    UnitActionGuard(cre);
    UniChatMessage(cre, "홀드모드로 설정되었습니다", 150);
}

void CreClassEscort(int cre, int caster)
{
    CreatureFollow(cre, caster);
    UniChatMessage(cre, "에스코트 모드로 전환되었습니다", 150);
}

void CreClassOnClick()
{
    int act = CreClassGetAction(self), owner = GetOwner(self), cFps = GetMemory(0x84ea04);

    if (MathAbs(cFps - GetUnit1C(GetTrigger() + 1)) < 12)
    {
        if (owner ^ GetCaller())
            SetOwner(other, self);
        LookAtObject(self, other);
        if (act ^ 4) //isNotGuard
            CreClassGuardMode(self, other);
        else
            CreClassEscort(self, other);
        PlaySoundAround(self, 312);
        Effect("BLUE_SPARKS", GetObjectX(self), GetObjectY(self), 0.0, 0.0);
    }
    SetUnit1C(GetTrigger() + 1, cFps);
}

void CreClassCommonProperty(int cre, int owner)
{
    SetDialog(cre, "NORMAL", CreClassOnClick, CreClassOnClick);
    if (!MaxHealth(owner))
        owner = GetHost();
    SetOwner(owner, cre);
    SetOwner(owner, cre + 1);
}

void CreClassShowSumError()
{
    UniPrintToAll("**예외발생** 생산 가능한 최대치에 도달했기 때문에 더 이상 유닛을 만들 수 없습니다");
}

void CreSumClassMecaGolem(int anyArg, int owner)
{
    int pay = 57917, cre;

    if (owner)
    {
        cre = CreClassSummonBuffer(SToInt("MechanicalGolem") | (MechanicalGolemSubProcess << 10), anyArg);
        if (cre)
            CreClassCommonProperty(cre, owner);
        else
            CreClassShowSumError();
    }
}

void CreSumClassPlant(int anyArg, int owner)
{
    int pay = 51008, cre;

    if (owner)
    {
        cre = CreClassSummonBuffer(SToInt("CarnivorousPlant") | (CarnivorousPlantSubProcess << 10), anyArg);
        if (cre)
            CreClassCommonProperty(cre, owner);
        else
            CreClassShowSumError();
    }
}

void CreSumClassOrbHecubah(int anyArg, int owner)
{
    int pay = 50033, cre;

    if (owner)
    {
        cre = CreClassSummonBuffer(SToInt("HecubahWithOrb") | (HecubahWithOrbSubProcess << 10), anyArg);
        if (cre)
        {
            CreClassCommonProperty(cre, owner);
        }
        else
            CreClassShowSumError();
    }
}

void CreSumClassRedWiz(int anyArg, int owner)
{
    int pay = 52349, cre;

    if (owner)
    {
        cre = CreClassSummonBuffer(SToInt("WizardRed") | (WizardRedSubProcess << 10), anyArg);
        if (cre)
        {
            CreClassCommonProperty(cre, owner);
        }
        else
            CreClassShowSumError();
    }
}

int CreClassGetSumPay(int lFunction)
{
    int link = GetMemory(GetMemory(0x75ae28) + (0x30 * lFunction + 0x1c)) + 8;

    return GetMemory(link);
}

void CreClassMarketDesc()
{
    int lFunction = ToInt(GetObjectZ(GetTrigger() + 1));
    int pay = CreClassGetSumPay(lFunction);

    TellStoryUnitName("oAo", "War08b:HenrickSaleSuccessful", "크리쳐 구입?");
    UniPrint(other, "이 크리쳐를 구입하시겠어요? 가격은 " + IntToString(pay) + " 입니다");
    UniPrint(other, "거래를 계속하려면 예를 누르세요");
}

void CreClassMarketTrade()
{
    int lFunction, pay;

    if (GetAnswer(self) ^ 1) return;
    lFunction = ToInt(GetObjectZ(GetTrigger() + 1));
    pay = CreClassGetSumPay(lFunction);
    if (GetGold(other) >= pay)
    {
        CallFunctionWithTwoArg(lFunction, other, GetCaller());
        ChangeGold(other, -pay);
        UniPrint(other, "크리쳐 구입에 성공했습니다");
    }
    else
    {
        UniPrint(other, "잔액이 부족하여 거래가 취소되었습니다");
    }
}

int CreClassPlaceMarket(int args)
{
    int location = args & 0x3ff, loadFunction = (args >> 10) & 0x3ff;
    string kpName = ToStr((args >> 20) & 0x3ff);
    int kp = DeadUnitCreateAt(LocationX(location), LocationY(location), kpName);

    Frozen(CreateObjectAt("ImaginaryCaster", LocationX(location), LocationY(location)) - 1, 1);
    Raise(kp + 1, loadFunction);
    SetDialog(kp, "YESNO", CreClassMarketDesc, CreClassMarketTrade);
    return kp;
}

void CreClassMarketPlace()
{
    CreSumClassMecaGolem(0, 0);
    CreSumClassOrbHecubah(0, 0);
    CreSumClassPlant(0, 0);
    CreSumClassRedWiz(0, 0);
    CreClassPlaceMarket(38 | (CreSumClassMecaGolem << 10) | (SToInt("Maiden") << 20));
    CreClassPlaceMarket(48 | (CreSumClassOrbHecubah << 10) | (SToInt("Hecubah") << 20));
    CreClassPlaceMarket(49 | (CreSumClassPlant << 10) | (SToInt("CarnivorousPlant") << 20));
    CreClassPlaceMarket(64 | (CreSumClassRedWiz << 10) | (SToInt("WizardRed") << 20));
    AliveLifePlaceMarket(73);
}

void SellCre()
{
    int owner;

    if (IsMonsterUnit(other))
    {
        owner = GetOwner(other);
        if (UnitCheckEnchant(other, GetLShift(30)))
        {
            Delete(GetCaller() + 1);
            Delete(other);
            CreClassDecreaseCurrentCount();
            if (CurrentHealth(owner) && IsPlayerUnit(owner))
            {
                ChangeGold(owner, 3000);
                UniPrint(owner, "크리쳐 1개를 지웠습니다 (+3000골드 돌려받음)");
            }
        }
    }
}

void BucherOneShot()
{
    int cFps = GetMemory(0x84ea04), ptr = UnitToPtr(self), stf;

    if (ptr)
    {
        stf = GetMemory(ptr + 0x2e0);
        if (MathAbs(cFps - GetMemory(stf + 0x64)) > 50)
        {
            SetMemory(stf + 0x64, cFps);
            ThrowBucherFx(other);
        }
    }
}

int PlaceArrowSword(int sArg)
{
    int xyTable = AnyargUnitOrLocation(sArg);
    int sd = CreateObjectAt("Sword", GetMemoryFloat(xyTable), GetMemoryFloat(xyTable + 4));
    int ptr = GetMemory(0x750710);

    SetWeaponProperties(ptr, 5, 5, 8, 3);
    WeaponClassCProperty1Entry(sd, 2, WeaponExecScript1, WeaponClassCProperty3Table());
    return sd;
}

int PlaceDrainSword(int sArg)
{
    int xyTable = AnyargUnitOrLocation(sArg);
    int sd = CreateObjectAt("GreatSword", GetMemoryFloat(xyTable), GetMemoryFloat(xyTable + 4));
    int ptr = GetMemory(0x750710);

    SetWeaponProperties(ptr, 5, 5, 8, 3);
    WeaponClassCProperty1Entry(sd, 2, DrainSwordFx, WeaponClassCProperty3Table());
    return sd;
}

int PlaceFonSword(int sArg)
{
    int xyTable = AnyargUnitOrLocation(sArg);
    int sd = CreateObjectAt("GreatSword", GetMemoryFloat(xyTable), GetMemoryFloat(xyTable + 4));
    int ptr = GetMemory(0x750710);

    SetWeaponProperties(ptr, 5, 5, 8, 3);
    WeaponClassCProperty1Entry(sd, 2, ForceOfNatureShot, WeaponClassCProperty3Table());
    return sd;
}

int PlaceAxeForOgre(int sArg)
{
    int xyTable = AnyargUnitOrLocation(sArg);
    int sd = CreateObjectAt("OgreAxe", GetMemoryFloat(xyTable), GetMemoryFloat(xyTable + 4));
    int ptr = GetMemory(0x750710);

    SetWeaponProperties(ptr, 0, 5, 0, 0);
    WeaponClassCProperty1Entry(sd, 2, BreakingAxeJin, WeaponClassCProperty3Table());
    return sd;
}

int PlaceAutoMissileMace(int sArg)
{
    int xyTable = AnyargUnitOrLocation(sArg);
    int sd = CreateObjectAt("MorningStar", GetMemoryFloat(xyTable), GetMemoryFloat(xyTable + 4));
    int ptr = GetMemory(0x750710);

    SetWeaponProperties(ptr, 0, 5, 0, 0);
    WeaponClassCProperty1Entry(sd, 2, ShotAutoDetectMissile, WeaponClassCProperty3Table());
    return sd;
}

int PlaceBucherStaff(int sArg)
{
    int xyTable = AnyargUnitOrLocation(sArg);
    int staff = CreateObjectAt("OblivionOrb", GetMemoryFloat(xyTable), GetMemoryFloat(xyTable + 4));
    int ptr = GetMemory(0x750710);

    SetMemory(ptr + 0x2dc, ImportUseItemFunc());
    SetMemory(ptr + 0x2fc, BucherOneShot);
    SetMemory(ptr + 0x2c4, 0x53a720);
    SetMemory(ptr + 0x2c8, ImportAllowAllDrop());
    return staff;
}

int NetClientExec()
{
    int arr[3], link;

    arr[0] = 0xdf;
    link = GetMemory(GetMemory(0x75ae28) + (0x30 * NetClientExec + 0x1c));
    return link;
}

void ClientSetMemory(int user, int targetAddr, int byte)
{
    int ptr = NetClientExec();

    SetMemory(ptr + 1, targetAddr - 0x6d495c);
    SetMemory(ptr + 5, byte);
    NetClientSend(user, ptr, 6);
}

void DelayLink(int pUnit)
{
    ClientSetMemory(pUnit, 0x69ba98 + 0, 0);
    ClientSetMemory(pUnit, 0x69ba98 + 1, 0x10);
    ClientSetMemory(pUnit, 0x69ba98 + 2, 0x75);
}

void ClientEntry(int cliUnit)
{
    //6A 00 6A 00/ 68 7F 00 00/ 00 E8 02 63/ DB FF 83 C4/ 0C 68 B0 95/ 4B 00 C3 90: 24Byte
    ClientSetMemory(cliUnit, 0x751000, 0x6a);
    ClientSetMemory(cliUnit, 0x751001, 0x00);
    ClientSetMemory(cliUnit, 0x751002, 0x6a);
    ClientSetMemory(cliUnit, 0x751003, 0x00);
    ClientSetMemory(cliUnit, 0x751004, 0x68);
    ClientSetMemory(cliUnit, 0x751005, ClientMain & 0xff);
    ClientSetMemory(cliUnit, 0x751006, (ClientMain >> 8) & 0xff);
    ClientSetMemory(cliUnit, 0x751007, 0);
    ClientSetMemory(cliUnit, 0x751008, 0);
    ClientSetMemory(cliUnit, 0x751009, 0xe8);
    ClientSetMemory(cliUnit, 0x75100a, 0x02);
    ClientSetMemory(cliUnit, 0x75100b, 0x63);
    ClientSetMemory(cliUnit, 0x75100c, 0xdb);
    ClientSetMemory(cliUnit, 0x75100d, 0xff);
    ClientSetMemory(cliUnit, 0x75100e, 0x83);
    ClientSetMemory(cliUnit, 0x75100f, 0xc4);
    ClientSetMemory(cliUnit, 0x751010, 0x0c);
    ClientSetMemory(cliUnit, 0x751011, 0x68);
    ClientSetMemory(cliUnit, 0x751012, 0x10);
    ClientSetMemory(cliUnit, 0x751013, 0xde);
    ClientSetMemory(cliUnit, 0x751014, 0x43);
    ClientSetMemory(cliUnit, 0x751015, 0x00);
    ClientSetMemory(cliUnit, 0x751016, 0xc3);
    FrameTimerWithArg(1, cliUnit, DelayLink);
}

int ImportNetSendClient()
{
    int arr[15], link;

    if (!link)
    {
        arr[0] = 0x40EBC068; arr[1] = 0x72506800; arr[2] = 0x83500050; arr[3] = 0x54FF10EC; arr[4] = 0x44891424;
        arr[5] = 0x54FF0C24; arr[6] = 0x44891424; arr[7] = 0x54FF0824; arr[8] = 0x44891424; arr[9] = 0x54FF0424;
        arr[10] = 0x04891424; arr[11] = 0x2454FF24; arr[12] = 0x10C48318; arr[13] = 0x08C48358; arr[14] = 0x909090C3;
        link = GetMemory(GetMemory(0x75ae28) + (0x30 * ImportNetSendClient + 0x1c));
    }
    return link;
}

void NetClientSend(int plrUnit, int buffPtr, int buffSize)
{
    //netClientSend,0x0040EBC0
    int plrPtr = UnitToPtr(plrUnit), plrIdx;
    int temp = GetMemory(0x5c315c);

    if (plrPtr)
    {
        if (GetMemory(plrPtr + 0x08) & 0x04)
        {
            plrIdx = GetMemory(GetMemory(GetMemory(plrPtr + 0x2ec) + 0x114) + 0x810);
            //5c31ac
            SetMemory(0x5c315c, ImportNetSendClient());
            GroupDamage(plrIdx, 1, buffPtr, buffSize);
            SetMemory(0x5c315c, temp);
        }
    }
}

int PlayMusicPacket()
{
    int packet = 0x6466e5, link;

    if (!link)
    {
        link = GetMemory(GetMemory(0x75ae28) + (0x30 * PlayMusicPacket + 0x1c));
    }
    return link;
}

void NetPlayBgm(int user)
{
    if (CurrentHealth(user))
    {
        NetClientSend(user, PlayMusicPacket(), 3);
    }
}

int ImportWriteBinaryFile()
{
    int arr[17], link;

    if (!link)
    {
        arr[0] = 0xDB624BE8; arr[1] = 0x246850FF; arr[2] = 0xFF005882; arr[3] = 0x485AE830; arr[4] = 0xC483FFE1;
        arr[5] = 0x74C08508; arr[6] = 0x748B5624; arr[7] = 0x768B0424; arr[8] = 0x8D0E8B04; arr[9] = 0x50500476; arr[10] = 0x5651016A; arr[11] = 0xE149D1E8;
        arr[12] = 0x10C483FF; arr[13] = 0xCB64FAE8; arr[14] = 0x04C483FF; arr[15] = 0x04C4835E; arr[16] = 0x909090C3;
        link = GetScrDataField(ImportWriteBinaryFile);
        FixCallOpcode(link + 0, 0x507250);
        FixCallOpcode(link + 0xd, 0x56586c);
        FixCallOpcode(link + 0x2c, 0x565a02);
        FixCallOpcode(link + 0x34, 0x407533);
    }
    return link;
}

void WriteBinaryFile(string fileName, int stream)
{
    int temp = 0x5c310c;

    fileName = ToStr(GetMemory(0x97bb40 + (SToInt(fileName) * 4)));
    SetMemory(0x5c310c, ImportWriteBinaryFile());
    Unused20(GetMemory(GetMemory(0x75ae28) + (0x30 * WriteBinaryFile + 0x1c)));
    SetMemory(0x5c310c, temp);
}

int ShowMessageBoxImport()
{
    int arr[9], link;

    if (!link)
    {
        arr[0] = 0x006A5650; arr[1] = 0x216A006A; arr[2] = 0xDB6243E8; arr[3] = 0x0470FFFF; arr[4] = 0x35FF30FF; arr[5] = 0x006E08E4;
        arr[6] = 0xCF89F3E8; arr[7] = 0x18C483FF; arr[8] = 0x90C3585E;
        link = GetMemory(GetMemory(0x75ae28) + (0x30 * ShowMessageBoxImport) + 0x1c);
        FixCallOpcode(link + 8, 0x507250);
        FixCallOpcode(link + 0x18, 0x449a10);
    }
    return link;
}

void ShowMessageBoxCore(int ttDest, int cDest)
{
    int link, temp = GetMemory(0x5c3108);

    link = GetMemory(GetMemory(0x75ae28) + (0x30 * ShowMessageBoxCore) + 0x1c);
    SetMemory(0x5c3108, ShowMessageBoxImport());
    Unused1f(link);
    SetMemory(0x5c3108, temp);
}

void ShowMessageBox(string title, string content)
{
    int ttDest[100], cDest[100], link;
    int ttPtr = GetMemory(0x97bb40 + (SToInt(title) * 4));
    int cPtr = GetMemory(0x97bb40 + (SToInt(content) * 4));

    link = GetMemory(GetMemory(0x75ae28) + (0x30 * ShowMessageBox) + 0x1c);
    NoxUtf8ToUnicode(ttPtr, link + 8);
    NoxUtf8ToUnicode(cPtr, link + 408);

    ShowMessageBoxCore(link + 8, link + 408);
}

void WriteMusicStrings(int targetAddr)
{
    int arr[78], i;

    arr[0] = 0x70616863; arr[1] = 0x61772E31; arr[2] = 0x68630076; arr[3] = 0x77327061; arr[4] = 0x772E7A69; arr[5] = 0x63007661; arr[6] = 0x32706168;
    arr[7] = 0x2E6E6F63; arr[8] = 0x00766177; arr[9] = 0x70616863; arr[10] = 0x72617732; arr[11] = 0x7661772E; arr[12] = 0x61686300; arr[13] = 0x772E3370;
    arr[14] = 0x63007661; arr[15] = 0x34706168; arr[16] = 0x7661772E; arr[17] = 0x61686300; arr[18] = 0x772E3570; arr[19] = 0x63007661; arr[20] = 0x36706168;
    arr[21] = 0x7661772E; arr[22] = 0x61686300; arr[23] = 0x772E3770; arr[24] = 0x63007661; arr[25] = 0x38706168; arr[26] = 0x7661772E; arr[27] = 0x61686300;
    arr[28] = 0x772E3970; arr[29] = 0x63007661; arr[30] = 0x61706168; arr[31] = 0x7661772E; arr[32] = 0x61686300; arr[33] = 0x772E6270; arr[34] = 0x74007661;
    arr[35] = 0x656C7469; arr[36] = 0x7661772E; arr[37] = 0x776F7400; arr[38] = 0x772E316E; arr[39] = 0x74007661; arr[40] = 0x326E776F; arr[41] = 0x7661772E;
    arr[42] = 0x776F7400; arr[43] = 0x772E336E; arr[44] = 0x73007661; arr[45] = 0x2E316275; arr[46] = 0x00766177; arr[47] = 0x32627573; arr[48] = 0x7661772E;
    arr[49] = 0x62757300; arr[50] = 0x61772E33; arr[51] = 0x61770076; arr[52] = 0x7265646E; arr[53] = 0x61772E31; arr[54] = 0x61770076; arr[55] = 0x7265646E;
    arr[56] = 0x61772E32; arr[57] = 0x61770076; arr[58] = 0x7265646E; arr[59] = 0x61772E33; arr[60] = 0x72630076; arr[61] = 0x74696465; arr[62] = 0x61772E73;
    arr[63] = 0x68730076; arr[64] = 0x2E6C6C65; arr[65] = 0x00766177; arr[66] = 0x69746361; arr[67] = 0x2E316E6F; arr[68] = 0x00766177; arr[69] = 0x69746361;
    arr[70] = 0x2E326E6F; arr[71] = 0x00766177; arr[72] = 0x69746361; arr[73] = 0x2E336E6F; arr[74] = 0x00766177; arr[75] = 0x646E6177; arr[76] = 0x2E347265;
    arr[77] = 0x00766177;
    for (i = 0 ; i < 78 ; i ++)
        SetMemory(targetAddr + (i * 4), arr[i]);
}

void PreProcessPlayBgm(int targetAddr)
{
    int oldBase = 0x59da7c;

    WriteMusicStrings(targetAddr);
    SetMemory(oldBase + 0, targetAddr);
    SetMemory(oldBase + 4, targetAddr + 0xa);
    SetMemory(oldBase + 8, targetAddr + 0x17);
    SetMemory(oldBase + 12, targetAddr + 0x24);
    SetMemory(oldBase + 16, targetAddr + 0x31);
    SetMemory(oldBase + 20, targetAddr + 0x3b);
    SetMemory(oldBase + 24, targetAddr + 0x45);
    SetMemory(oldBase + 28, targetAddr + 0x4f);
    SetMemory(oldBase + 32, targetAddr + 0x59);
    SetMemory(oldBase + 36, targetAddr + 0x63);
    SetMemory(oldBase + 40, targetAddr + 0x6d);
    SetMemory(oldBase + 44, targetAddr + 0x77);
    SetMemory(oldBase + 48, targetAddr + 0x81);
    SetMemory(oldBase + 52, targetAddr + 0x8b);
    SetMemory(oldBase + 56, targetAddr + 0x95);
    SetMemory(oldBase + 60, targetAddr + 0x9f);
    SetMemory(oldBase + 64, targetAddr + 0xa9);
    SetMemory(oldBase + 68, targetAddr + 0xb3);
    SetMemory(oldBase + 72, targetAddr + 0xbc);
    SetMemory(oldBase + 76, targetAddr + 0xc5);
    SetMemory(oldBase + 80, targetAddr + 0xce);
    SetMemory(oldBase + 84, targetAddr + 0xda);
    SetMemory(oldBase + 88, targetAddr + 0xe6);
    SetMemory(oldBase + 92, targetAddr + 0xf2);
    SetMemory(oldBase + 96, targetAddr + 0xfe);
    SetMemory(oldBase + 100, targetAddr + 0x108);
    SetMemory(oldBase + 104, targetAddr + 0x114);
    SetMemory(oldBase + 108, targetAddr + 0x120);
    SetMemory(oldBase + 112, targetAddr + 0x12c);
    SetMemory(0x59dbfc, 0);
}

void ResourceBGMdata()
{
    return;
}

void ExtractMapBgm(int arg)
{
    string fileName = ToStr(arg >> 0x10);
    int rscF = arg & 0xffff;
    int stream = GetMemory(GetMemory(0x75ae28) + (0x30 * rscF + 0x20));

    SetMemory(0x59dc10, GetMemory(0x97bb40 + (SToInt(fileName) * 4)));
    WriteBinaryFile("music\\" + fileName, stream);

    PreProcessPlayBgm(0x5becc4);
}

void MakeMusicDirectory()
{
    int temp = GetMemory(0x5c33b8);
    int code = 0x979740 + ((GetMemory(0x75ae40) - 2) * 4);

    //6A 00 68 C8/ 17 58 00 FF
    0xf468006a; 0xff0059db; 0x58116815; 0x9090C300;
    SetMemory(0x5c33b8, code);
    MusicPopEvent();
    SetMemory(0x5c33b8, temp);
}

int ObelMecaGolemAnim()
{
	int imgCount = 10, arr[10];

	arr[0] = ImagePtrFromID(138405);arr[1] = ImagePtrFromID(138404);arr[2] = ImagePtrFromID(138403);arr[3] = ImagePtrFromID(138402);
	arr[4] = ImagePtrFromID(138401);arr[5] = ImagePtrFromID(138400);arr[6] = ImagePtrFromID(138399);arr[7] = ImagePtrFromID(138398);
	arr[8] = ImagePtrFromID(138397);arr[9] = ImagePtrFromID(138396);
	return GetMemory(GetMemory(0x75ae28) + (0x30 * ObelMecaGolemAnim + 0x1c));
}

void AnimateImagePackage(int thingId, int imgTable)
{
    MakeAnimateImage(thingId, imgTable);
    InnerImageZeroHeight(thingId);
    RemoveSpriteFromThingId(thingId);
}

void SetupBottmText(int thingId, int ptr, int colorSet, string desc)
{
    ModifyThingClassDescription(thingId, desc, colorSet);
    ModifyThingClassDrawFunction(thingId, ptr);
    InnerImageZeroHeight(thingId);
    RemoveSpriteFromThingId(thingId);
}

void PlayerClassCommonWhenEntry()
{
    int ptr = BuildTextDrawFunction();

    SetupBottmText(2508, ptr, 0x7f6, "부활터 가는 문");
    SetupBottmText(2509, ptr, 0x7f6, "게임을 시작하지...");
    SetupBottmText(2510, ptr, 0x7f6, "필드로 나가는 포탈");
    AnimateImagePackage(2507, ObelMecaGolemAnim());
    SetupBottmText(2517, ptr, 0x7f6, "임.무.완.료.!.");
    SetupBottmText(2518, ptr, 0xff60, "중국인 입장하는 곳");
    SetupBottmText(2558, ptr, 0xff60, "중국인 입국완료 지점");
    SetupBottmText(2559, ptr, 0xfa02, "우리는 중국인");
    SetupBottmText(2560, ptr, 0xf8bd, "제작 및 기획- 237");
    SetMemory(0x69b974, 0x64);
    SetMemory(0x59dbe4, 1);
    MakeMusicDirectory();
    ExtractMapBgm((SToInt("chn01.mp3") << 0x10) | ResourceBGMdata);
    AddDemonBreathsWand(0x611C64);
    ImageInit();
    ShowMessageBox("중국인 입국막기", "중국인들의 무분별한 국내 입국을 대 학살을 통해 막아보아요");
}

int AnimateRealloc(int ptr, int imgCount)
{
    int alloc = MemAlloc(24);
    int iLinkTable = MemAlloc((imgCount + 1) * 4);

    SetMemory(alloc, 0x10);
    SetMemory(alloc + 4, iLinkTable);
    SetMemory(alloc + 8, imgCount);
    SetMemory(alloc + 12, 2);
    SetMemory(alloc + 16, 0);
    SetMemory(alloc + 20, 0);
    SetMemory(ptr + 92, alloc);
    return iLinkTable;
}

void ImageTableMapping(int dest, int src, int count)
{
    int i;

    for (i = 0 ; i < count ; i ++)
        SetMemory(dest + (i * 4), GetMemory(src + (i * 4)));
    SetMemory(dest + (i * 4), 0);
}

int MakeAnimateImage(int thingId, int imgTable)
{
    int ptr = GetMemory(GetMemory(0x69f224) + (thingId * 4));
    int imgPtr = GetMemory(ptr + 92), mapped, freePtr = 0;
    int imgCount = GetMemory(imgTable);

    while (1)
    {
        if (GetMemory(imgPtr) == 0x08)
            1;
        else if (GetMemory(imgPtr + 0x8) ^ imgCount)
            freePtr = GetMemory(imgPtr + 4);
        else
        {
            mapped = GetMemory(imgPtr + 4);
            break;
        }
        mapped = AnimateRealloc(ptr, imgCount);
        if (freePtr)
            MemFree(freePtr);
        break;
    }
    ImageTableMapping(mapped, imgTable + 4, imgCount);
    SetMemory(ptr + 116, 134719);
    SetMemory(ptr + 88, 0x4bbd60);
}

int DrawImageAt(float x, float y, int thingId)
{
    int unit = CreateObjectAt("AirshipBasketShadow", x, y);
    int ptr = GetMemory(0x750710);

    SetMemory(ptr + 0x04, thingId);
    return unit;
}

int DrawImageAtLocation(int location, int thingId)
{
    return DrawImageAt(LocationX(location), LocationY(location), thingId);
}

int GetImageTableFirstImgPtr(int iTablePtr)
{
    return GetMemory(iTablePtr + 4);
}

int ImagePtrFromID(int imgId)
{
    return GetMemory(0x694864) + (12 * imgId);
}

void InnerImageZeroHeight(int thingId)
{
    int ptr = GetMemory(GetMemory(0x69f224) + (thingId * 4));

    if (GetMemory(ptr + 20) >> 0x10)
        SetMemory(ptr + 20, GetMemory(ptr + 20) & 0xffff);
    if (GetMemory(ptr + 32) & 0x400000)
        SetMemory(ptr + 32, GetMemory(ptr + 32) ^ 0x400000);
}

void InnerImageSwap(int thingId, int imgId)
{
    int ptr = GetMemory(GetMemory(0x69f224) + (thingId * 4));
    int imgPtr = GetMemory(ptr + 92);
    SetMemory(ptr + 116, imgId);

    if (GetMemory(imgPtr) == 0x10)
    {
        SetMemory(imgPtr, 0x08);
        MemFree(GetMemory(imgPtr + 4));
    }
    SetMemory(ptr + 88, 0x4bcc20);
    SetMemory(imgPtr + 4, ImagePtrFromID(imgId));
}

int ImportRemoveSpriteFromThingId()
{
    int arr[16], link, fNumb;

    if (!link)
    {
        arr[0] = 0x5008EC83; arr[1] = 0x6D3DC0A1; arr[2] = 0x24448900; arr[3] = 0x623EE808; arr[4] = 0x4489FFDB; arr[5] = 0x8B560424;
        arr[6] = 0x850C2474; arr[7] = 0x8B1B74F6; arr[8] = 0xFF082444; arr[9] = 0x000170B6; arr[10] = 0x768B5600; arr[11] = 0x75F0396C;
        arr[12] = 0x94AAE805; arr[13] = 0x5E58FFD0; arr[14] = 0x585EE1EB; arr[15] = 0xC308C483;
        ImportRemoveSpriteFromThingId;
        fNumb = GetMemory(0x979740 + ((GetMemory(0x75ae40) - 4) * 4));
        link = GetMemory(GetMemory(0x75ae28) + ((0x30 * fNumb) + 0x1c));
        FixCallOpcode(link + 0x0d, 0x507250);
        FixCallOpcode(link + 0x31, 0x45a4e0);
    }
    return link;
}

void RemoveSpriteFromThingId(int thingId)
{
    int temp = GetMemory(0x5c3108);

    SetMemory(0x5c3108, ImportRemoveSpriteFromThingId());
    Unused1f(thingId);
    SetMemory(0x5c3108, temp);
}

void MappingTextDrawCode(int ptr)
{
    SetMemory(ptr + 0, 0x8B20EC83); SetMemory(ptr + 4, 0x84EA040D);
    SetMemory(ptr + 8, 0x56555300); SetMemory(ptr + 12, 0x3424748B); 
    SetMemory(ptr + 16, 0xAC3D8B57); SetMemory(ptr + 20, 0x8B00853B);
    SetMemory(ptr + 24, 0x00012086); SetMemory(ptr + 28, 0x72C83900); 
    SetMemory(ptr + 32, 0xE03D8B06); SetMemory(ptr + 36, 0x570084C9);
    SetMemory(ptr + 40, 0xCE336FE8); SetMemory(ptr + 44, 0x988e8bff); //SetMemory(ptr + 44, 0xC00D8BFF); 
    SetMemory(ptr + 48, 0x51000000); //SetMemory(ptr + 48, 0x510083C8);
    SetMemory(ptr + 52, 0xCE3293E8);
    SetMemory(ptr + 56, 0x244C8BFF); SetMemory(ptr + 60, 0x0C468B3C); 
    SetMemory(ptr + 64, 0x8B08C483); SetMemory(ptr + 68, 0x118B1059);
    SetMemory(ptr + 72, 0x2914698B); SetMemory(ptr + 76, 0x105E8BD8); 
    SetMemory(ptr + 80, 0x518BD001); SetMemory(ptr + 84, 0x704E8B04);
    SetMemory(ptr + 88, 0x4489EA29); SetMemory(ptr + 92, 0xDA011024); 
    SetMemory(ptr + 96, 0x14245489); SetMemory(ptr + 100, 0xA16C4E8B);
    SetMemory(ptr + 104, 0x0069F224); SetMemory(ptr + 108, 0x8B88048B); 
    SetMemory(ptr + 112, 0xD2850450); SetMemory(ptr + 116, 0x00BA0575);
    SetMemory(ptr + 120, 0x8B0058D7); SetMemory(ptr + 124, 0x8B142444); 
    SetMemory(ptr + 128, 0x5010244C); SetMemory(ptr + 132, 0x006A5251);
    SetMemory(ptr + 136, 0xCEE58FE8); SetMemory(ptr + 140, 0x10C483FF); 
    SetMemory(ptr + 144, 0x000001B8); SetMemory(ptr + 148, 0x5D5E5F00);
    SetMemory(ptr + 152, 0x20C4835B); SetMemory(ptr + 156, 0x909090C3);
    FixCallOpcode(ptr + 40, 0x434460);
    FixCallOpcode(ptr + 52, 0x434390);
    FixCallOpcode(ptr + 136, 0x43f6e0);
}

void ModifyThingClassDescription(int thingId, string desc, int textColor)
{
    int tPtr = GetMemory(GetMemory(0x69f224) + (thingId * 4));
    int dest = MemAlloc(48), prevPtr = GetMemory(tPtr + 4);
    int src = GetMemory(0x97bb40 + (SToInt(desc) * 4));

    NoxUtf8ToUnicode(src, dest);
    if (textColor)
        SetMemory(tPtr + 48, textColor);
    SetMemory(tPtr + 4, dest);
    if (prevPtr)
        MemFree(prevPtr);
}

void ModifyThingClassDrawFunction(int thingId, int fPtr)
{
    int tPtr = GetMemory(GetMemory(0x69f224) + (thingId * 4));

    SetMemory(tPtr + 88, fPtr);
}

int BuildTextDrawFunction()
{
    int offset = 0x5cebdc;
    
    MappingTextDrawCode(offset);
    return offset;
}

void ClientMain()
{
    int v0;

    if (!v0)
    {
        v0 = EnableMemoryReadWriteFunction(0);
        SetMemory(0x69ba98, 0x43de10);
        PlayerClassCommonWhenEntry();

        v0 ++;
    }
}

void UpdateRepairItem(int pIndex, int item)
{
    int arr[9], link, temp = GetMemory(0x5c3108), ptr = UnitToPtr(item);

    if (!link)
    {
        arr[0] = 0x50685056; arr[1] = 0xFF005072; arr[2] = 0x708B2414; arr[3] = 0x04C48304; arr[4] = 0x4D87A068; arr[5] = 0x30FF5600; arr[6] = 0x082454FF;
        arr[7] = 0x580CC483; arr[8] = 0x9090C35E;
		link = GetMemory(GetMemory(0x75ae28) + (0x30 * UpdateRepairItem + 0x1c));
    }
    if (ptr)
    {
        item = ptr;
        SetMemory(0x5c3108, link + 8);
        Unused1f(link);
        SetMemory(0x5c3108, temp);
    }
}

int SellGerm(int inv)
{
    int thingId = GetUnitThingID(inv), pay, pic;

    if (thingId >= 2795 && thingId <= 2797)
    {
        Delete(inv);
        pic = 2797 - thingId;
        10000; 5000; 1000;
        return GetMemory(0x979740 + ((GetMemory(0x75ae40) - (2 + pic)) * 4));
    }
    else
        return 0;
}

int FindItemGerm(int holder)
{
    int inv = GetLastItem(holder), res = 0, nextInv;

    while (inv)
    {
        nextInv = GetPreviousItem(inv);
        res += SellGerm(inv);
        inv = nextInv;
    }
    return res;
}

void SellGermDesc()
{
    UniPrint(other, "당신이 소유하고 있는 모든 보석을 저에게 파시겠어요? 거래를 계속하려면 '예' 버튼을 누르세요");
    TellStoryUnitName("oAo", "thing.db:DiscDiamond", "보석 감별사");
}

void SellGermTrade()
{
    int trdRes;

    if (GetAnswer(self) ^ 1) return;
    trdRes = FindItemGerm(other);
    if (trdRes)
    {
        ChangeGold(other, trdRes);
        UniPrint(other, "가지고 있던 모든 보석을 팔아서 " + IntToString(trdRes) + " 골드를 추가했습니다");
    }
    else
        UniPrint(other, "당신은 보석을 하나도 가지고 있지 않아요. 거래를 계속할 수 없습니다");
}

int SellGermPlace(int location)
{
    int kp = DeadUnitCreateAt(LocationX(location), LocationY(location), "UrchinShaman");

    Frozen(kp, 1);
    SetDialog(kp, "YESNO", SellGermDesc, SellGermTrade);
    return kp;
}

int RepairSingle(int inv, int pIndex)
{
    if (MaxHealth(inv) ^ CurrentHealth(inv))
    {
        RestoreHealth(inv, 99999);
        UpdateRepairItem(pIndex, inv);
        return 1;
    }
    return 0;
}

int RepairItemOnInventory(int holder)
{
    int count = 0, inv = GetLastItem(holder), pIndex = GetPlayerIndex(holder);

    while (inv)
    {
        count += RepairSingle(inv, pIndex);
        inv = GetPreviousItem(inv);
    }
    return count;
}

void RepairItemDesc()
{
    TellStoryUnitName("oAo", "WarriorHint:Repair", "아이템 수리?");
    UniPrint(other, "인벤토리 내 모든 아이템을 금화 4천에 수리해 드려요~ 계속 거래하시려면 '예' 를 누르세요");
}

void RepairItemTrade()
{
    int iRes = 0;

    if (GetAnswer(self) ^ 1) return;
    if (GetGold(other) >= 4000)
    {
        iRes = RepairItemOnInventory(other);
        if (iRes)
        {
            ChangeGold(other, -4000);
            PlaySoundAround(self, 803);
            UniPrint(other, IntToString(iRes) + "개 아이템이 수리되었습니다 (-4000 골드 차감됨)");
            Effect("LESSER_EXPLOSION", GetObjectX(self), GetObjectY(self), 0.0, 0.0);
        }
    }
    else
        UniPrint(other, "금화가 부족하여 처리되지 않았습니다. 금화를 모은 후 다시 시도해 보세요");
}

int RepairItemPlaceKp(int location)
{
    int kp = DeadUnitCreateAt(LocationX(location), LocationY(location), "Urchin");

    Frozen(kp, 1);
    SetDialog(kp, "YESNO", RepairItemDesc, RepairItemTrade);
    return kp;
}

void SetUnitScanRange(int unit, float range)
{
    int ptr = UnitToPtr(unit);

    if (ptr)
    {
        SetMemory(GetMemory(ptr + 0x2ec) + 0x520, ToInt(range));
    }
}

void ExplosionMeteor(int sub)
{
    int owner = GetOwner(sub);

    SplashDamageAt(owner, 300, GetObjectX(sub), GetObjectY(sub), 200.0);
    PlaySoundAround(sub, 87);
    DeleteObjectTimer(CreateObjectAt("Explosion", GetObjectX(sub), GetObjectY(sub)), 12);
    DeleteObjectTimer(CreateObjectAt("MeteorExplode", GetObjectX(sub), GetObjectY(sub)), 12);
}

void ThrowMeteor(int sub)
{
    int count = GetDirection(sub), owner = GetOwner(sub);

    while (IsObjectOn(sub))
    {
        if (CurrentHealth(owner))
        {
            if (count)
            {
                Raise(sub + 1, GetObjectZ(sub + 1) - 5.0);
                FrameTimerWithArg(1, sub, ThrowMeteor);
                LookWithAngle(sub, count - 1);
                break;
            }
            else
                ExplosionMeteor(sub);
        }
        Delete(sub);
        Delete(sub + 1);
        break;
    }
}

void AmuletUseHitMeteor()
{
    int sub;

    if (IsObjectOn(self) && CurrentHealth(other))
    {
        sub = CreateObjectAt("ImaginaryCaster", GetObjectX(other), GetObjectY(other));
        Raise(CreateObjectAt("BoulderMine", GetObjectX(sub), GetObjectY(sub)), 250.0);
        FrameTimerWithArg(1, sub, ThrowMeteor);
        PlaySoundAround(sub, 85);
        UnitNoCollide(sub + 1);
        SetOwner(other, sub);
        LookWithAngle(sub, 50);
        Delete(self);
    }
}

void AutoTargetDeathraySight()
{
    int owner = GetOwner(self);

    if (CurrentHealth(other) && CurrentHealth(self))
    {
        Damage(other, owner, 100, 16);
        PlaySoundAround(other, 299);
        Effect("DEATH_RAY", GetObjectX(self), GetObjectY(self), GetObjectX(other), GetObjectY(other));
    }
}

void AutoDeathRaySword()
{
    int sub = CreateObjectAt("WeirdlingBeast", GetObjectX(other) + UnitAngleCos(other, 6.0), GetObjectY(other) + UnitAngleSin(other, 6.0));

    UnitNoCollide(sub);
    SetOwner(other, sub);
    SetCallback(sub, 3, AutoTargetDeathraySight);
    LookWithAngle(sub, GetDirection(other));
    DeleteObjectTimer(sub, 1);
    PlaySoundAround(sub, 27);
    Effect("VIOLET_SPARKS", GetObjectX(other), GetObjectY(other), 0.0, 0.0);
}

int PlaceAutoTargetSword(int sArg)
{
    int xyTable = AnyargUnitOrLocation(sArg);
    int sd = CreateObjectAt("GreatSword", GetMemoryFloat(xyTable), GetMemoryFloat(xyTable + 4));
    int ptr = GetMemory(0x750710);

    SetWeaponProperties(ptr, 5, 5, 19, 23);
    WeaponClassCProperty1Entry(sd, 2, AutoDeathRaySword, WeaponClassCProperty3Table());
    return sd;
}

int PlaceMeteorAmulet(int sArg)
{
    int xyTable = AnyargUnitOrLocation(sArg);
    int sd = CreateObjectAt("AmuletofManipulation", GetMemoryFloat(xyTable), GetMemoryFloat(xyTable + 4));
    int ptr = GetMemory(0x750710);

    SetMemory(ptr + 0x2dc, ImportUseItemFunc());
    SetMemory(ptr + 0x2fc, AmuletUseHitMeteor);
    return sd;
}

void UserShowGameInfo(int pUnit)
{
    if (MaxHealth(pUnit))
    {
        UniPrint(pUnit, "우리는 중국인_version. 2                                                         기획 및 제작. 237");
        UniPrint(pUnit, "때는 2025년... 한국 본토 점령 프로젝트 준비를 위해 중국 공산당 간첩들이 대거 국내로 입국하게 되는데... ");
    }
}

int CheckNullTerminate(int srcPtr)
{
    int i, stream = GetMemory(srcPtr);

    for (i = 0 ; i < 4 ; i ++)
    {
        if (stream & 0xff)
            stream = stream >> 0x08;
        else
            return 0;
    }
    return 1;
}

void CopyString(string src, int destPtr)
{
    int srcPtr = GetMemory(0x97bb40 + (SToInt(src) * 4)), i;

    for (i = 0 ; 1; i ++)
    {
        SetMemory(destPtr + (i * 4), GetMemory(srcPtr + (i * 4)));
        if (!CheckNullTerminate(srcPtr + (i * 4)))
            break;
    }
}

int AddDescription(string desc, int size)
{
    int destPtr = MemAlloc(size);
    int srcPtr = GetMemory(0x97bb40 + (SToInt(desc) * 4));

    NoxUtf8ToUnicode(srcPtr, destPtr);
    return destPtr;
}

void CopyDataStream(int srcPtr, int destPtr, int dwordCount)
{
    int i;

    for (i = 0 ; i < dwordCount ; i ++)
        SetMemory(destPtr + (i * 4), GetMemory(srcPtr + (i * 4)));
}

void AddDemonBreathsWand(int offset)
{
    int data[22];
    int ptr, namePtr, descPtr;

    if (GetMemory(GetMemory(GetMemory(offset))) == 0x6b616557)
    {
        ptr = MemAlloc(88);
        namePtr = MemAlloc(20);
        descPtr = MemAlloc(24);
        CopyString("DemonsBreathWand", namePtr);
        data[0] = namePtr;
        data[1] = 215;
        data[2] = AddDescription("용의 숨결 지팡이", 24);
        data[3] = 0xa1000000;
        data[4] = 0x788c;
        data[10] = 1;
        data[15] = 0x70014;
        data[16] = ToInt(0.5);
        data[17] = ToInt(225.0);
        data[18] = 5;
        data[20] = GetMemory(offset);
        CopyDataStream(GetMemory(GetMemory(0x75ae28) + (0x30 * AddDemonBreathsWand) + 0x1c) + 4, ptr, 22);
        SetMemory(offset, ptr);
    }
    SetMemory(0x58f1f0, 0x200000);
}

void AliveLifeDesc()
{
    int cce = GameClassLifeCheck();

    TellStoryUnitName("oAo", "Con10B.scr:HecubahDialog1", "라이프구입?");
    UniPrint(other, "1 라이프를 구입하시겠어요? 가격은 5만 골드에요. 현재 라이프 수: " + IntToString(cce));
}

void AliveLifeTrade()
{
    int cce;

    if (GetAnswer(self) ^ 1) return;
    cce = GameClassLifeCheck();
    if (cce < 48)
    {
        if (GetGold(other) >= 50000)
        {
            ChangeGold(other, -50000);
            GameClassLifeSet(cce + 1);
            PlaySoundAround(other, 1004);
            UniPrint(other, "라이프 1개를 추가 했어요! 남은 라이프 수: " + IntToString(cce));
            Effect("YELLOW_SPARKS", GetObjectX(other), GetObjectY(other), 0.0, 0.0);
        }
        else
            UniPrint(other, "거래 실패! 금화 부족");
    }
    else
        UniPrint(other, "더 이상 라이프를 추가할 수 없어요!");
}

int AliveLifePlaceMarket(int location)
{
    int dm = DeadUnitCreateAt(LocationX(location), LocationY(location), "Maiden");

    Frozen(CreateObjectAt("Ankh", LocationX(location), LocationY(location)) - 1, 1);
    SetDialog(dm, "YESNO", AliveLifeDesc, AliveLifeTrade);
    return dm;
}

int PlaceDemonWand(int anyArg)
{
    int xyTable = AnyargUnitOrLocation(anyArg);
    int sd = CreateObjectAt("DemonsBreathWand", GetMemoryFloat(xyTable), GetMemoryFloat(xyTable + 4));
    int ptr = GetMemory(0x750710);

    SetMemory(GetMemory(ptr + 736) + 108, 0xc8c8);
    return sd;
}

void ManaTileSingle(int location, float xVect, float yVect)
{
    CreateObjectAt("InvisibleObelisk", LocationX(location), LocationY(location));
    TeleportLocationVector(location, xVect, yVect);
}

void ManaTileAll(int count)
{
    int i;

    if (count)
    {
        for (i = 0 ; i < 7 ; i ++)
            ManaTileSingle(i + 66, 23.0, 23.0);
        FrameTimerWithArg(1, count - 1, ManaTileAll);
    }
}

void ImageResourceField1()
{
    return;
}

int GetScrDataField(int functionName)
{
    return GetMemory(GetMemory(0x75ae28) + (0x30 * functionName + 0x1c));
}

int GetScrCodeField(int functionName)
{
    return GetMemory(GetMemory(0x75ae28) + (0x30 * functionName + 0x20));
}

int ImageResourceDrawFunction(int bptr)
{
    int arr[55];

    arr[0] = 0x83EC8B55; arr[1] = 0x8B5608EC; arr[2] = 0x358B0845; arr[3] = 0x0069F224; arr[4] = 0x8BFC4589; arr[5] = 0x348B6C40; arr[6] = 0xF8758986;
    arr[7] = 0x5D5350A1; arr[8] = 0x60768B00; arr[9] = 0x1374F039; arr[10] = 0xB8F8758B; arr[11] = 0x004BCC20; arr[12] = 0x8B584689; arr[13] = 0x4689FC75;
    arr[14] = 0x5EC03158; arr[15] = 0x5D08C483; arr[16] = 0x909090C3; arr[17] = 0x83EC8B55; arr[18] = 0x8B5620EC; arr[19] = 0xE8560C75; arr[20] = 0xFFFFFFAC;
    arr[21] = 0x8504C483; arr[22] = 0x8B2274C0; arr[23] = 0xC0850846; arr[24] = 0x31561B74; arr[25] = 0x708B66F6; arr[26] = 0x4860A108; arr[27] = 0x348D0069;
    arr[28] = 0xB0048DF6; arr[29] = 0x8BF04589; arr[30] = 0xEC458900; arr[31] = 0xE445895E; arr[32] = 0x2674C085; arr[33] = 0x0130B68B; arr[34] = 0x768B0000;
    arr[35] = 0xFC758904; arr[36] = 0x4589068B; arr[37] = 0x04468BF8; arr[38] = 0x8BF44589; arr[39] = 0x758BF045; arr[40] = 0x8B3089F4; arr[41] = 0xF631FC45;
    arr[42] = 0x758D3089; arr[43] = 0x04468B08; arr[44] = 0xE836FF50; arr[45] = 0xFFD6BAA4; arr[46] = 0x5008C483; arr[47] = 0x85E4458B; arr[48] = 0x8B1074C0;
    arr[49] = 0x758BFC45; arr[50] = 0x8B3089F8; arr[51] = 0x758BF045; arr[52] = 0x583089EC; arr[53] = 0x20C4835E; arr[54] = 0x9090C35D;
    StreamCopy(GetScrDataField(ImageResourceDrawFunction) + 4, bptr, 55);
    return bptr + 0x44;
}

void ApplyImageResource(int thingId, int rscPtr, int drawF)
{
    int chandle = GetMemory(0x5d5350);
    int tPtr = GetMemory(GetMemory(0x69f224) + (thingId * 4));
    int imgSec = GetMemory(GetMemory(tPtr + 0x5c) + 0x04);

    //SetMemory(tPtr + 0x54, chandle);
    SetMemory(tPtr + 0x60, chandle);
    SetMemory(tPtr + 0x58, drawF);
    SetMemory(imgSec + 4, rscPtr);
}

int ImageResourceDrawFunctionFix(int bptr)
{
    int arr[58];

    arr[0] = 0x83EC8B55; arr[1] = 0x8B5608EC; arr[2] = 0x358B0845; arr[3] = 0x0069F224; arr[4] = 0x8BFC4589; arr[5] = 0x348B6C40; arr[6] = 0xF8758986;
    arr[7] = 0x5D5350A1; arr[8] = 0x60768B00; arr[9] = 0x1374F039; arr[10] = 0xB8F8758B; arr[11] = 0x004BCC20; arr[12] = 0x8B584689; arr[13] = 0x4689FC75;
    arr[14] = 0x5EC03158; arr[15] = 0x5D08C483; arr[16] = 0x909090C3; arr[17] = 0x83EC8B55; arr[18] = 0x8B5620EC; arr[19] = 0xE8560C75; arr[20] = 0xFFFFFFAC;
    arr[21] = 0x8504C483; arr[22] = 0x8B2274C0; arr[23] = 0xC0850846; arr[24] = 0x31561B74; arr[25] = 0x708B66F6; arr[26] = 0x4860A108; arr[27] = 0x348D0069;
    arr[28] = 0xB0048DF6; arr[29] = 0x8BF04589; arr[30] = 0xEC458900; arr[31] = 0xE445895E; arr[32] = 0x3474C085; arr[33] = 0x896C468B; arr[34] = 0xB68BF445;
    arr[35] = 0x00000130; arr[36] = 0x8904768B; arr[37] = 0x068BFC75; arr[38] = 0x8BF84589; arr[39] = 0x69F22435; arr[40] = 0xF4458B00; arr[41] = 0x8B86348D;
    arr[42] = 0x74468B36; arr[43] = 0x89F0758B; arr[44] = 0xFC458B06; arr[45] = 0x3089F631; arr[46] = 0x8B08758D; arr[47] = 0xFF500446; arr[48] = 0xBA96E836;
    arr[49] = 0xC483FFD6; arr[50] = 0x458B5008; arr[51] = 0x74C085E4; arr[52] = 0xFC458B10; arr[53] = 0x89F8758B; arr[54] = 0xF0458B30; arr[55] = 0x89EC758B;
    arr[56] = 0x835E5830; arr[57] = 0xC35D20C4;
    StreamCopy(GetScrDataField(ImageResourceDrawFunctionFix) + 4, bptr, 58);
    return bptr + 0x44;
}

void ApplyImageResourceFix(int thingId, int rscPtr, int drawF)
{
    int chandle = GetMemory(0x5d5350);
    int tPtr = GetMemory(GetMemory(0x69f224) + (thingId * 4));

    //SetMemory(tPtr + 0x54, chandle);
    SetMemory(tPtr + 0x60, chandle);
    SetMemory(tPtr + 0x58, drawF);
    SetMemory(tPtr + 0x74, rscPtr);
}

void ImageResourceKor() {}
void ImageResourceChin() {}

void RedPotionImage() {}
void PoisonPotionImage() {}
void VampPotionImage() {}
void YellowPotionImage() {}
void MagicPotionImage() {}

void ResourceBucherImage() {}

void ResourceDollar()
{ }

void ImageInit()
{
    int drawF = ImageResourceDrawFunctionFix(0x7510c4);

    ApplyImageResourceFix(357, GetScrCodeField(ImageResourceField1) + 4, drawF);
    ApplyImageResourceFix(636, GetScrCodeField(RedPotionImage) + 4, drawF);
    ApplyImageResourceFix(2682, GetScrCodeField(VampPotionImage) + 4, drawF);
    ApplyImageResourceFix(631, GetScrCodeField(PoisonPotionImage) + 4, drawF);
    ApplyImageResourceFix(2686, GetScrCodeField(MagicPotionImage) + 4, drawF);
    ApplyImageResourceFix(639, GetScrCodeField(YellowPotionImage) + 4, drawF);
    ApplyImageResourceFix(358, GetScrCodeField(ResourceBucherImage) + 4, drawF);
    ApplyImageResourceFix(359, GetScrCodeField(ImageResourceChin) + 4, drawF);
    ApplyImageResourceFix(360, GetScrCodeField(ImageResourceKor) + 4, drawF);
    ApplyImageResourceFix(979, GetScrCodeField(ResourceDollar) + 4, drawF);
}

void PotionImgTest()
{
    CreateYellowPotion(144, LocationX(79), LocationY(79));
    CreateObject("VampirismPotion", 80);
    CreateObject("RedPotion", 80);
    PlaceBucherStaff(81);
}

void RepeatDrawSmokeRing(float x, float y, float gap, int rep)
{
    if (rep)
    {
        DeleteObjectTimer(CreateObjectAt("OldSmoke", x + MathSine(rep * 15 + 90, gap), y + MathSine(rep * 15, gap)), 3);
        RepeatDrawSmokeRing(x, y, gap, rep - 1);
    }
}

void SpreadSmokeRing(int sub, int count, float gap)
{
    float xProfile = GetObjectX(sub), yProfile = GetObjectY(sub);

    if (count)
    {
        RepeatDrawSmokeRing(xProfile, yProfile, gap, 24);
        SpreadSmokeRing(sub, count - 1, gap + 20.0);
    }
}

void SmokeRingBlast(int unit, int count, float gap)
{
    int sub = CreateObjectAt("ImaginaryCaster", GetObjectX(unit), GetObjectY(unit));

    SpreadSmokeRing(sub, count, gap);
    Delete(sub);
}

void ThrowBucherDestroyed(int sub)
{
    SmokeRingBlast(sub, 8, 20.0);
    SplashDamageAt(GetOwner(sub), 240, GetObjectX(sub), GetObjectY(sub), 200.0);
    PlaySoundAround(sub, 759);
    Effect("JIGGLE", GetObjectX(sub), GetObjectY(sub), 20.0, 0.0);
}

void ThrowBucherDurate(int sub)
{
    int owner = GetOwner(sub), durate = GetDirection(sub);

    while (IsObjectOn(sub))
    {
        if (CurrentHealth(owner))
        {
            if (durate)
            {
                FrameTimerWithArg(1, sub, ThrowBucherDurate);
                LookWithAngle(sub, durate - 1);
                Raise(sub + 1, GetObjectZ(sub + 1) - 10.0);
                break;
            }
            else
                ThrowBucherDestroyed(sub);
        }
        Delete(sub);
        Delete(sub + 1);
        break;
    }
}

void ThrowBucherFx(int owner)
{
    float xVect = UnitAngleCos(owner, 23.0),yVect = UnitAngleSin(owner, 23.0);
    int sub = CreateObjectAt("InvisibleLightBlueLow", GetObjectX(owner) + xVect, GetObjectY(owner) + yVect);

    FrameTimerWithArg(1, sub, ThrowBucherDurate);
    LookWithAngle(CreateObjectAt("MovableStatue1b", GetObjectX(sub), GetObjectY(sub)) - 1, 25);
    UnitNoCollide(sub + 1);
    Raise(sub + 1, 250.0);
    SetOwner(owner, sub);
}

void GodModePotionFx(int fxUnit)
{
    int owner = GetOwner(fxUnit);

    while (IsObjectOn(fxUnit))
    {
        if (CurrentHealth(owner))
        {
            int durate = ToInt(GetObjectZ(fxUnit));

            if (durate)
            {
                if (!UnitCheckEnchant(owner, GetLShift(23)))
                    Enchant(owner, EnchantList(23), 0.0);
                FrameTimerWithArg(1, fxUnit, GodModePotionFx);
                Raise(fxUnit, durate - 1);
                MoveObject(fxUnit + 1, GetObjectX(owner), GetObjectY(owner));
            }
            EnchantOff(owner, EnchantList(23));
        }
        Delete(fxUnit);
        Delete(fxUnit + 1);
        break;
    }
}

void UseGodModePotion()
{
    Delete(self);
    if (!UnitCheckEnchant(other, GetLShift(23)))
    {
        UniPrint(other, "무적의 물약을 사용하셨습니다. 15 초간 무적상태가 유지됩니다");
        int fxUnit = CreateObjectAt("InvisibleLightBlueLow", GetObjectX(other), GetObjectY(other));

        SetOwner(other, CreateObjectAt("Smoke", GetObjectX(other), GetObjectY(other)) - 1);
        Raise(fxUnit, 450);
        FrameTimerWithArg(1, fxUnit, GodModePotionFx);
    }
}